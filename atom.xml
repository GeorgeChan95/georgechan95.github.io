<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>George&#39;s Blog</title>
  
  <subtitle>个人邮箱：george_95@126.com</subtitle>
  <link href="https://georgechan95.github.io/atom.xml" rel="self"/>
  
  <link href="https://georgechan95.github.io/"/>
  <updated>2025-04-18T02:18:45.728Z</updated>
  <id>https://georgechan95.github.io/</id>
  
  <author>
    <name>George</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>005-Kubernetes控制器</title>
    <link href="https://georgechan95.github.io/blog/c790096a.html"/>
    <id>https://georgechan95.github.io/blog/c790096a.html</id>
    <published>2025-04-02T12:12:00.000Z</published>
    <updated>2025-04-18T02:18:45.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、控制器概述"><a href="#一、控制器概述" class="headerlink" title="一、控制器概述"></a>一、控制器概述</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Kubernetes 中运行了一系列控制器来确保集群的当前状态与期望状态保持一致，它们就是 Kubernetes 集群内部的管理控制中心或者说是”中心大脑”。例如，ReplicaSet 控制器负责维护集群中运行的 Pod 数量；Node 控制器负责监控节点的状态，并在节点出现故障时，执行自动化修复流程，确保集群始终处于预期的工作状态。</p><p><strong>控制器-控制循环</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/04/02/20250402-201433.png" alt="控制器-控制循环"></p><h2 id="2-控制器分类"><a href="#2-控制器分类" class="headerlink" title="2. 控制器分类"></a>2. 控制器分类</h2><p>Pod控制器有如下几类：</p><ul><li>ReplicationController 和 ReplicaSet<ul><li><strong>功能</strong>：确保指定数量的 Pod 副本始终运行。<ul><li><strong>ReplicationController</strong>（旧版）：通过标签选择器管理 Pod 副本数，但功能较基础。</li><li><strong>ReplicaSet</strong>（推荐）：新一代控制器，支持更灵活的<strong>集合型标签选择器</strong>（如 <code>matchLabels</code> 和 <code>matchExpressions</code>），通常被 Deployment 间接使用。</li></ul></li><li><strong>典型场景</strong>：无状态应用的副本维护（如 Web 服务）。</li></ul></li><li>Deployment<ul><li><strong>功能</strong>：管理 ReplicaSet 并提供声明式更新（如滚动升级、回滚）。<ul><li>通过控制 ReplicaSet 实现 Pod 的副本管理。</li><li>支持版本控制和更新策略（如 <code>RollingUpdate</code> 或 <code>Recreate</code>）。</li></ul></li><li><strong>典型场景</strong>：需要滚动更新或回滚的无状态应用（如微服务）。</li></ul></li><li>DaemonSet<ul><li><strong>功能</strong>：确保每个节点（或指定节点）运行一个指定的 Pod。<ul><li>Pod 通常与节点绑定（如日志收集、网络插件）。</li><li>节点加入集群时自动创建 Pod，节点移除时删除。</li></ul></li><li><strong>典型场景</strong>：集群级守护进程（如 <code>kube-proxy</code>、<code>fluentd</code>）。</li></ul></li><li>StateFulSet<ul><li><strong>功能</strong>：管理有状态应用的 Pod，提供稳定的标识和持久化存储。<ul><li>每个 Pod 有唯一名称（如 <code>web-0</code>、<code>web-1</code>）和持久化存储（PVC）。</li><li>支持有序部署&#x2F;扩展（按序号顺序操作）。</li></ul></li><li><strong>典型场景</strong>：数据库、分布式存储（如 MySQL、ZooKeeper）。</li></ul></li><li>Job&#x2F;CronJob<ul><li><strong>Job</strong>：<ul><li>创建一次性 Pod 并确保其成功完成。</li><li>支持并行执行和重试机制。</li><li><strong>场景</strong>：批处理任务（如数据处理）。</li></ul></li><li><strong>CronJob</strong>：<ul><li>基于时间表（Cron 表达式）周期性运行 Job。</li><li><strong>场景</strong>：定时任务（如每日备份）。</li></ul></li></ul></li><li>Horizontal Pod Autoscaling<ul><li><strong>功能</strong>：根据 CPU 使用率或其他自定义指标自动调整 Pod 副本数。<ul><li>与 ReplicaSet&#x2F;Deployment 配合使用。</li><li>支持动态扩缩容（如流量高峰时扩容）。</li></ul></li><li><strong>典型场景</strong>：应对负载波动的服务（如电商大促）。</li></ul></li></ul><h1 id="二、ReplicationController-和-ReplicaSet"><a href="#二、ReplicationController-和-ReplicaSet" class="headerlink" title="二、ReplicationController 和 ReplicaSet"></a>二、ReplicationController 和 ReplicaSet</h1><p>ReplicationController（RC）用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收；</p><p>在新版本的 Kubernetes 中建议使用 ReplicaSet 来取代 ReplicationController 。ReplicaSet 跟 ReplicationController 没有本质的不同，只是名字不一样，并且 ReplicaSet 支持集合式的 selector；</p><h2 id="1-案例：ReplicationController"><a href="#1-案例：ReplicationController" class="headerlink" title="1. 案例：ReplicationController"></a>1. 案例：ReplicationController</h2><p><code>001-replication-controller.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">ReplicationController</span> <span class="comment"># 资源类型为 ReplicationController（旧版副本控制器）</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">rc-demo</span> <span class="comment"># RC 的名称，在命名空间中唯一</span>  <span class="attr">namespace:</span> <span class="string">default</span><span class="attr">spec:</span>  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 确保始终有 3 个 Pod 副本在运行</span>  <span class="attr">selector:</span>    <span class="attr">app:</span> <span class="string">rc-demo</span>  <span class="comment"># 选择标签为 `app: rc-demo` 的 Pod 进行管理</span>  <span class="attr">template:</span> <span class="comment"># Pod 模板</span>    <span class="attr">metadata:</span>      <span class="attr">labels:</span>        <span class="attr">app:</span> <span class="string">rc-demo</span> <span class="comment"># 给 Pod 打上标签，与 selector 对应</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rc-demo-container</span> <span class="comment"># 容器名称</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>          <span class="attr">env:</span> <span class="comment"># 定义环境变量</span>            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GET_HOSTS_FROM</span> <span class="comment"># 环境变量1 key</span>              <span class="attr">value:</span> <span class="string">dns</span>            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">zhangsan</span> <span class="comment"># 环境变量2 key</span>              <span class="attr">value:</span> <span class="string">&quot;123&quot;</span>          <span class="attr">ports:</span>            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 容器暴露的端口</span></code></pre><p><strong>运行 ReplicationController</strong></p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f 001-replication-controller.yaml</span></code></pre><p><strong>查看Pod的运行情况</strong></p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -o wide -w</span>NAME            READY   STATUS    RESTARTS         AGE   IP              NODE         NOMINATED NODE   READINESS GATESrc-demo-47nqt   1/1     Running   0                36s   172.16.85.199   k8s-node01   &lt;none&gt;           &lt;none&gt;rc-demo-74hbx   1/1     Running   0                36s   172.16.58.198   k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-zp8ck   1/1     Running   0                36s   172.16.85.200   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>在两个node子节点上，运行了三个 Pod</p><p><strong>测试Pod自动恢复</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">新起一个shell终端，杀死一个pod</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete pod rc-demo-74hbx</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">观察Pod运行情况</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -o wide -w</span>NAME            READY   STATUS    RESTARTS         AGE   IP              NODE         NOMINATED NODE   READINESS GATESrc-demo-47nqt   1/1     Running   0                36s   172.16.85.199   k8s-node01   &lt;none&gt;           &lt;none&gt;rc-demo-74hbx   1/1     Running   0                36s   172.16.58.198   k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-zp8ck   1/1     Running   0                36s   172.16.85.200   k8s-node01   &lt;none&gt;           &lt;none&gt;rc-demo-74hbx   1/1     Terminating   0                63s   172.16.58.198   k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-fgfmr   0/1     Pending       0                1s    &lt;none&gt;          &lt;none&gt;       &lt;none&gt;           &lt;none&gt;rc-demo-fgfmr   0/1     Pending       0                1s    &lt;none&gt;          k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-fgfmr   0/1     ContainerCreating   0                2s    &lt;none&gt;          k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-74hbx   1/1     Terminating         0                65s   172.16.58.198   k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-74hbx   0/1     Terminating         0                71s   172.16.58.198   k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-74hbx   0/1     Terminating         0                75s   &lt;none&gt;          k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-74hbx   0/1     Terminating         0                75s   &lt;none&gt;          k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-74hbx   0/1     Terminating         0                75s   &lt;none&gt;          k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-fgfmr   0/1     ContainerCreating   0                13s   &lt;none&gt;          k8s-node02   &lt;none&gt;           &lt;none&gt;rc-demo-fgfmr   1/1     Running             0                20s   172.16.58.199   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre><p>杀死了 Pod <code>rc-demo-74hbx</code>， k8s又自动创建了Pod <code>rc-demo-fgfmr</code>。</p><h2 id="2-案例：ReplicaSet"><a href="#2-案例：ReplicaSet" class="headerlink" title="2. 案例：ReplicaSet"></a>2. 案例：ReplicaSet</h2><h3 id="2-1-RS-yaml-文件"><a href="#2-1-RS-yaml-文件" class="headerlink" title="2.1 RS yaml 文件"></a>2.1 RS yaml 文件</h3><p><code>002-ReplicaSet.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span><span class="attr">kind:</span> <span class="string">ReplicaSet</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">replica-set-demo</span> <span class="comment"># rs的名字，全局唯一，生成的Pod的名字：replica-set-demo-xxxx</span>  <span class="attr">namespace:</span> <span class="string">default</span><span class="attr">spec:</span>  <span class="attr">replicas:</span> <span class="number">3</span>  <span class="attr">selector:</span>    <span class="attr">matchLabels:</span> <span class="comment"># 基于标签匹配</span>      <span class="attr">app:</span> <span class="string">rs-ml-demo</span> <span class="comment"># ReplicaSet 将管理带有标签 app=rs-ml-demo 的 Pod</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">namespace:</span> <span class="string">default</span>      <span class="attr">labels:</span> <span class="comment"># 为 Pod 设置标签</span>        <span class="attr">app:</span> <span class="string">rs-ml-demo</span> <span class="comment"># 给 Pod 打上标签 app=rs-ml-demo，与 selector 中的 matchLabels 对应</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rs-ml-container</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>          <span class="attr">env:</span> <span class="comment"># 定义容器的环境变量</span>            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GET_HOSTS_FROM</span>              <span class="attr">value:</span> <span class="string">dns</span>            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">George</span>              <span class="attr">value:</span> <span class="string">&quot;30&quot;</span>          <span class="attr">ports:</span>            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></code></pre><h3 id="2-2-启动RS"><a href="#2-2-启动RS" class="headerlink" title="2.2 启动RS"></a>2.2 启动RS</h3><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f 002-ReplicaSet.yaml</span></code></pre><h3 id="2-3-查看RS启动详情"><a href="#2-3-查看RS启动详情" class="headerlink" title="2.3 查看RS启动详情"></a>2.3 查看RS启动详情</h3><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe replicaset replica-set-demo</span>Name:         replica-set-demoNamespace:    defaultSelector:     app=rs-ml-demoLabels:       &lt;none&gt;Annotations:  &lt;none&gt;Replicas:     3 current / 3 desiredPods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 FailedPod Template:  Labels:  app=rs-ml-demo  Containers:   rs-ml-container:    Image:      wangyanglinux/myapp:v1.0    Port:       80/TCP    Host Port:  0/TCP    Environment:      GET_HOSTS_FROM:  dns      George:          30    Mounts:            &lt;none&gt;  Volumes:             &lt;none&gt;Events:  Type    Reason            Age   From                   Message  ----    ------            ----  ----                   -------  Normal  SuccessfulCreate  67s   replicaset-controller  Created pod: replica-set-demo-p4tpb  Normal  SuccessfulCreate  67s   replicaset-controller  Created pod: replica-set-demo-hnddq  Normal  SuccessfulCreate  67s   replicaset-controller  Created pod: replica-set-demo-89pz7</code></pre><p>RS 创建了3个 Pod 副本，均已启动成功。</p><h3 id="2-4-查看-RS-启动的-Pod"><a href="#2-4-查看-RS-启动的-Pod" class="headerlink" title="2.4  查看 RS 启动的 Pod"></a>2.4  查看 RS 启动的 Pod</h3><p>根据 Pod 的标签过滤</p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -l app=rs-ml-demo -o wide</span>NAME                     READY   STATUS    RESTARTS   AGE     IP              NODE         NOMINATED NODE   READINESS GATESreplica-set-demo-89pz7   1/1     Running   0          2m58s   172.16.58.203   k8s-node02   &lt;none&gt;           &lt;none&gt;replica-set-demo-hnddq   1/1     Running   0          2m58s   172.16.85.202   k8s-node01   &lt;none&gt;           &lt;none&gt;replica-set-demo-p4tpb   1/1     Running   0          2m58s   172.16.58.202   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre><h3 id="2-5-查看Pod的日志"><a href="#2-5-查看Pod的日志" class="headerlink" title="2.5 查看Pod的日志"></a>2.5 查看Pod的日志</h3><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">查看最近1000行日志</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs -f --<span class="built_in">tail</span>=1000 replica-set-demo-89pz7</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看最近1小时的日志</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs -f --<span class="built_in">tail</span>=1000 replica-set-demo-89pz7 --since=1h</span></code></pre><h3 id="2-6-验证Pod设置的环境变量是否有效"><a href="#2-6-验证Pod设置的环境变量是否有效" class="headerlink" title="2.6 验证Pod设置的环境变量是否有效"></a>2.6 验证Pod设置的环境变量是否有效</h3><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">进入Pod容器</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> -it replica-set-demo-89pz7 /bin/bash</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">打印环境变量</span>replica-set-demo-89pz7:/# echo $GET_HOSTS_FROMdnsreplica-set-demo-89pz7:/# echo $George30</code></pre><h3 id="2-7-验证RS对于Pod副本数量的自动恢复"><a href="#2-7-验证RS对于Pod副本数量的自动恢复" class="headerlink" title="2.7 验证RS对于Pod副本数量的自动恢复"></a>2.7 验证RS对于Pod副本数量的自动恢复</h3><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">在一个shell中监控RS</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl get replicaset replica-set-demo -o wide -w</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">在另一个shell中，杀死这个RS管理的其中一个Pod</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete pod replica-set-demo-89pz7</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">可以看到RS管理的Pod从最开始3个，变成2个，又迅速恢复成3个</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl get replicaset replica-set-demo -o wide -w</span>NAME               DESIRED   CURRENT   READY   AGE   CONTAINERS        IMAGES                     SELECTORreplica-set-demo   3         3         3       10m   rs-ml-container   wangyanglinux/myapp:v1.0   app=rs-ml-demoreplica-set-demo   3         2         2       11m   rs-ml-container   wangyanglinux/myapp:v1.0   app=rs-ml-demoreplica-set-demo   3         3         2       11m   rs-ml-container   wangyanglinux/myapp:v1.0   app=rs-ml-demoreplica-set-demo   3         3         3       11m   rs-ml-container   wangyanglinux/myapp:v1.0   app=rs-ml-demo</code></pre><h3 id="2-8-验证-yaml-文件中定义的Pod的标签与RS标签选择器不一致时，是否可以启动"><a href="#2-8-验证-yaml-文件中定义的Pod的标签与RS标签选择器不一致时，是否可以启动" class="headerlink" title="2.8 验证 yaml 文件中定义的Pod的标签与RS标签选择器不一致时，是否可以启动"></a>2.8 验证 yaml 文件中定义的Pod的标签与RS标签选择器不一致时，是否可以启动</h3><p><strong>yaml文件如下：</strong></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span><span class="attr">kind:</span> <span class="string">ReplicaSet</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">replica-set-demo</span> <span class="comment"># rs命名，全局唯一</span>  <span class="attr">namespace:</span> <span class="string">default</span><span class="attr">spec:</span>  <span class="attr">replicas:</span> <span class="number">3</span>  <span class="attr">selector:</span>    <span class="attr">matchLabels:</span> <span class="comment"># 基于标签匹配</span>      <span class="attr">app:</span> <span class="string">rs-ml-demo</span> <span class="comment"># ReplicaSet 将管理带有标签 app=rs-ml-demo 的 Pod</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">namespace:</span> <span class="string">default</span>      <span class="attr">labels:</span> <span class="comment"># 为 Pod 设置标签</span>        <span class="attr">app:</span> <span class="string">rs-ml-demo-123</span> <span class="comment"># 给 Pod 打上标签 app=rs-ml-demo，与 selector 中的 matchLabels 对应</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rs-ml-container</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>          <span class="attr">env:</span>            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GET_HOSTS_FROM</span>              <span class="attr">value:</span> <span class="string">dns</span>            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">George</span>              <span class="attr">value:</span> <span class="string">&quot;30&quot;</span>          <span class="attr">ports:</span>            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></code></pre><p>RS 标签选择器管理的标签是 rs-ml-demo ， 而 Pod模板定义的标签是 rs-ml-demo-123 ，这样 RS 将无法管理此 Pod。</p><p><strong>启动RS</strong></p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f 002-ReplicaSet.yaml</span> The ReplicaSet &quot;replica-set-demo&quot; is invalid: spec.template.metadata.labels: Invalid value: map[string]string&#123;&quot;app&quot;:&quot;rs-ml-demo-123&quot;&#125;: `selector` does not match template `labels`</code></pre><p>启动报错，K8S不允许定义定Pod标签与RS标签选择器无法匹配的情况。</p><h2 id="3-标签选择器"><a href="#3-标签选择器" class="headerlink" title="3. 标签选择器"></a>3. 标签选择器</h2><p>在 Kubernetes 的 ReplicaSet（或其他资源如 Deployment、Service 等）中，matchLabels 是 selector 的一部分，用于指定如何选择要管理的 Pod。它基于<strong>标签（labels）</strong>进行匹配。matchLabels 本身只支持一种匹配模式：<strong>精确匹配（exact match）</strong>，即键值对必须完全相等。但 Kubernetes 提供了更灵活的标签选择器机制，比如 matchExpressions，可以实现更复杂的匹配模式。</p><h3 id="3-1-matchLabels-的匹配模式"><a href="#3-1-matchLabels-的匹配模式" class="headerlink" title="3.1 matchLabels 的匹配模式"></a>3.1 matchLabels 的匹配模式</h3><ul><li><p><strong>定义</strong>：matchLabels 是一个键值对映射，要求被选中的 Pod 的标签与 matchLabels 中定义的键值对完全一致。</p></li><li><p><strong>模式</strong>：仅支持<strong>精确匹配</strong>。</p></li><li><p><strong>语法</strong>：</p><pre><code class="highlight yaml"><span class="attr">selector:</span>  <span class="attr">matchLabels:</span>    <span class="attr">key1:</span> <span class="string">value1</span>    <span class="attr">key2:</span> <span class="string">value2</span></code></pre></li><li><p><strong>行为</strong>：Pod 必须同时具备所有指定的标签键值对才能被选中。（Pod定的标签可以比 matchLabels 定义的标签多，但是不能比 matchLabels 定义的标签少，否则无法被 RS 管理）</p></li><li><p><strong>示例</strong>： 在你的 ReplicaSet 配置中：</p><pre><code class="highlight yaml"><span class="attr">selector:</span>  <span class="attr">matchLabels:</span>    <span class="attr">app:</span> <span class="string">rs-ml-demo</span>    <span class="attr">key2:</span> <span class="string">value2</span></code></pre><ul><li>这表示 ReplicaSet 只管理带有标签 <code>app=rs-ml-demo</code> 和 <code>key2=value2</code> 的 Pod。</li><li>Pod 的标签必须完全匹配 <code>app: rs-ml-demo</code> 和 <code>key2: value2</code> ，多余的标签不会影响匹配，但缺少这个标签的 Pod 不会被选中。</li></ul></li></ul><h3 id="3-2-matchExpressions-的匹配模式"><a href="#3-2-matchExpressions-的匹配模式" class="headerlink" title="3.2 matchExpressions 的匹配模式"></a>3.2 matchExpressions 的匹配模式</h3><p> Kubernetes 的 selector 还支持 matchExpressions，它提供了更丰富的匹配模式。matchExpressions 是一个可选字段，与 matchLabels 可以一起使用，允许基于逻辑运算进行标签选择。</p><p>它提供了更丰富的匹配模式。matchExpressions 是一个可选字段，与 matchLabels 可以一起使用，允许基于逻辑运算进行标签选择。</p><ul><li><p><strong>语法</strong>：</p><pre><code class="highlight yaml"><span class="attr">selector:</span>  <span class="attr">matchLabels:</span>    <span class="attr">app:</span> <span class="string">rs-ml-demo</span>  <span class="attr">matchExpressions:</span>    <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">environment</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">prod</span>, <span class="string">staging</span>]&#125;</code></pre></li><li><p><strong>支持的运算符（Operator）</strong>：</p><ol><li><strong>In</strong>：<ul><li>标签的值必须在指定值列表中。</li><li>示例：environment 的值必须是 prod 或 staging。</li></ul></li><li><strong>NotIn</strong>：<ul><li>标签的值不能在指定值列表中。</li><li>示例：environment 的值不能是 dev 或 test。</li></ul></li><li><strong>Exists</strong>：<ul><li>标签键必须存在，值无要求。</li><li>示例：Pod 必须有 environment 标签，具体值不限。</li></ul></li><li><strong>DoesNotExist</strong>：<ul><li>标签键不能存在。</li><li>示例：Pod 不能有 environment 标签。</li></ul></li></ol></li><li><p><strong>示例</strong>：</p><pre><code class="highlight yaml"><span class="attr">selector:</span>  <span class="attr">matchExpressions:</span>    <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">tier</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">frontend</span>, <span class="string">backend</span>]&#125;    <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">deprecated</span>, <span class="attr">operator:</span> <span class="string">DoesNotExist</span>&#125;</code></pre><ul><li>匹配条件：Pod 必须有 tier&#x3D;frontend 或 tier&#x3D;backend，且不能有 deprecated 标签。</li></ul></li></ul><h3 id="3-3-matchLabels-和-matchExpressions-的关系"><a href="#3-3-matchLabels-和-matchExpressions-的关系" class="headerlink" title="3.3 matchLabels 和 matchExpressions 的关系"></a>3.3 matchLabels 和 matchExpressions 的关系</h3><ul><li><p>matchLabels 是简化的写法：它会被 Kubernetes 内部转换为等价的 matchExpressions，每个键值对对应一个 In 运算符。</p><ul><li><p>例如：</p><pre><code class="highlight yaml"><span class="attr">matchLabels:</span>  <span class="attr">app:</span> <span class="string">rs-ml-demo</span></code></pre><p>等价于：</p><pre><code class="highlight yaml"><span class="attr">matchExpressions:</span>  <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">rs-ml-demo</span>]&#125;</code></pre></li></ul></li><li><p><strong>组合使用</strong>：如果同时指定 matchLabels 和 matchExpressions，Pod 必须满足两者的条件（逻辑“与”关系）。</p></li></ul><h3 id="3-4-注意事项"><a href="#3-4-注意事项" class="headerlink" title="3.4 注意事项"></a>3.4 注意事项</h3><ul><li><strong>一致性</strong>：selector.matchLabels（或 matchExpressions）必须与 template.metadata.labels 中的标签匹配，否则 ReplicaSet 无法正确管理 Pod。</li><li><strong>大小写敏感</strong>：标签键和值是大小写敏感的，例如 app: Rs-ml-demo 和 app: rs-ml-demo 不匹配。</li><li><strong>Service 的选择器</strong>：虽然问题聚焦于 ReplicaSet，但值得一提的是 Service 的 selector 只支持 matchLabels 风格的精确匹配，不支持 matchExpressions。</li></ul><h3 id="3-5-实际案例"><a href="#3-5-实际案例" class="headerlink" title="3.5 实际案例"></a>3.5 实际案例</h3><p><code>003-matchExpressions.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span><span class="attr">kind:</span> <span class="string">ReplicaSet</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">rs-me-exists-demo</span><span class="attr">spec:</span>  <span class="attr">replicas:</span> <span class="number">3</span>  <span class="attr">selector:</span>    <span class="attr">matchExpressions:</span>      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span> <span class="comment"># Pod 必须有 app 标签</span>        <span class="attr">operator:</span> <span class="string">Exists</span>      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">version</span> <span class="comment"># Pod 必须有 version=v1 或 version=v2</span>        <span class="attr">operator:</span> <span class="string">In</span>        <span class="attr">values:</span>          <span class="bullet">-</span> <span class="string">v1</span>          <span class="bullet">-</span> <span class="string">v2</span>      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">souce</span> <span class="comment"># Pod不能有 souce 标签</span>        <span class="attr">operator:</span> <span class="string">DoesNotExist</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">namespace:</span> <span class="string">default</span>      <span class="attr">labels:</span> <span class="comment"># 为 Pod 设置标签</span>        <span class="attr">app:</span> <span class="string">rs-ml-demo</span> <span class="comment"># 给 Pod 打上标签 app=rs-ml-demo，与 selector 中的 matchLabels 对应</span>        <span class="attr">version:</span> <span class="string">v1</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rs-ml-container</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>          <span class="attr">env:</span> <span class="comment"># 定义容器的环境变量</span>            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GET_HOSTS_FROM</span>              <span class="attr">value:</span> <span class="string">dns</span>            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">George</span>              <span class="attr">value:</span> <span class="string">&quot;30&quot;</span>          <span class="attr">ports:</span>            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></code></pre><h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><ul><li><strong>matchLabels</strong>：只支持<strong>精确匹配</strong>，键值对必须完全相等。</li><li><strong>matchExpressions</strong>（扩展功能）：支持 In、NotIn、Exists、DoesNotExist 四种模式，提供更灵活的匹配。</li></ul><h1 id="三、Deployment-控制器"><a href="#三、Deployment-控制器" class="headerlink" title="三、Deployment 控制器"></a>三、Deployment 控制器</h1><h2 id="1-Deployment-基本概念"><a href="#1-Deployment-基本概念" class="headerlink" title="1. Deployment - 基本概念"></a>1. Deployment - 基本概念</h2><p>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义 ( declarative ) 方法，用来替代以前的 ReplicationController 来方便的管理应用。典型的应用场景包括：</p><ul><li>定义 Deployment 来创建 Pod 和 ReplicaSet</li><li>滚动升级和回滚应用</li><li>扩容和缩容</li><li>暂停和继续 Deployment</li></ul><h2 id="2-Deployment-与-RS-的关联"><a href="#2-Deployment-与-RS-的关联" class="headerlink" title="2. Deployment - 与 RS 的关联"></a>2. Deployment - 与 RS 的关联</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/04/07/20250407-083305.png" alt="Deployment - 与 RS 的关联"></p><p>Deployment 是通过创建 ReplicaSet 来间接的管理 Pod。</p><h2 id="3-Deployment-常用命令"><a href="#3-Deployment-常用命令" class="headerlink" title="3. Deployment - 常用命令"></a>3. Deployment - 常用命令</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">根据资源清单创建 deployment</span> <span class="meta prompt_"># </span><span class="language-bash">--record 参数可以记录命令，我们可以很方便的查看每次 revision 的变化</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f deployment.yaml --record</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改 Deployment 类型的 Pod 的数量</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale deployment nginx-deployment --replicas 10</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置 Pod 自动扩缩容，最大15个，最小 10个，扩缩依据：CPU利用率是否超过 80%</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">更新 deployment 类型的Pod nginx-deployment 下的容器 nginx-deployment-container 的镜像为：wangyanglinux/myapp:v2.0</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">set</span> image deployment/nginx-deployment nginx-deployment-container=wangyanglinux/myapp:v2.0</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">回滚Pod变更 (只能回滚到前一次变更操作，如：1 -&gt; 2 -&gt; 3, 第一次回滚回到2，第二次回滚则回到3，无法回滚到)</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout undo deployment/nginx-deployment</span></code></pre><h2 id="4-apply-、create、replace-区别"><a href="#4-apply-、create、replace-区别" class="headerlink" title="4. apply 、create、replace 区别"></a>4. apply 、create、replace 区别</h2><p><code>kubectl create -f deployment.yaml</code> 和 <code>kubectl apply -f deployment.yaml</code> 都是用于创建或更新 Kubernetes 资源的命令，但它们在行为上有<strong>关键区别</strong>，主要涉及 <strong>声明式管理</strong> 和 <strong>命令式管理</strong> 的不同逻辑。</p><h3 id="4-1-命令式命令"><a href="#4-1-命令式命令" class="headerlink" title="4.1  命令式命令"></a>4.1  命令式命令</h3><pre><code class="highlight shell">kubectl create -f deployment.yaml</code></pre><ul><li><strong>作用</strong>：<strong>严格创建新资源</strong>。</li><li><strong>行为</strong>：<ul><li>如果资源（如 Deployment）<strong>已存在</strong>，会报错并拒绝执行（报 <code>AlreadyExists</code> 错误）。</li><li>仅适用于<strong>首次创建</strong>，不能用于更新。</li></ul></li><li><strong>适用场景</strong>：<ul><li>你明确知道资源不存在，且只需要一次性创建。</li><li>脚本中需要严格避免覆盖现有配置时。</li></ul></li></ul><p><strong>示例输出（资源已存在时）：</strong></p><pre><code class="highlight sh">Error from server (AlreadyExists): deployments.apps <span class="string">&quot;deployment-demo-1&quot;</span> already exists</code></pre><h3 id="4-2-声明式命令"><a href="#4-2-声明式命令" class="headerlink" title="4.2 声明式命令"></a>4.2 声明式命令</h3><ul><li><strong>作用</strong>：<strong>创建或更新资源</strong>，智能合并变更。</li><li><strong>行为</strong>：<ul><li>如果资源<strong>不存在</strong>，则创建它（等同于 <code>create</code>）。</li><li>如果资源<strong>已存在</strong>，则对比当前配置和 YAML 文件的差异，<strong>增量更新</strong>（保留未修改的字段）。</li><li>依赖 <code>metadata.annotations</code> 中的 <code>kubectl.kubernetes.io/last-applied-configuration</code> 记录上次配置，用于计算变更。</li></ul></li><li><strong>适用场景</strong>：<ul><li>日常维护（例如更新镜像版本、调整副本数）。</li><li>GitOps 或 CI&#x2F;CD 流程中（推荐使用 <code>apply</code> 而非 <code>create</code>）。</li></ul></li></ul><p><strong>示例输出（更新时）</strong>：</p><pre><code class="highlight shell">deployment.apps/deployment-demo-1 configured</code></pre><h3 id="4-3-关键区别总结"><a href="#4-3-关键区别总结" class="headerlink" title="4.3 关键区别总结"></a>4.3 关键区别总结</h3><table><thead><tr><th align="left">特性</th><th align="left"><code>kubectl create</code></th><th align="left"><code>kubectl apply</code></th></tr></thead><tbody><tr><td align="left"><strong>资源已存在</strong></td><td align="left">报错，拒绝执行</td><td align="left">合并更新</td></tr><tr><td align="left"><strong>资源不存在</strong></td><td align="left">创建资源</td><td align="left">创建资源</td></tr><tr><td align="left"><strong>管理方式</strong></td><td align="left">命令式（直接执行）</td><td align="left">声明式（对比差异后更新）</td></tr><tr><td align="left"><strong>记录变更</strong></td><td align="left">无</td><td align="left">记录到 <code>last-applied-configuration</code></td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">一次性创建</td><td align="left">持续维护（创建 + 更新）</td></tr></tbody></table><h3 id="4-4-kubectl-replace-f"><a href="#4-4-kubectl-replace-f" class="headerlink" title="4.4 kubectl replace -f"></a>4.4 kubectl replace -f</h3><ul><li>类似 <code>create</code>，但会<strong>强制替换</strong>现有资源（需资源已存在）。</li><li>与 <code>apply</code> 不同：<strong>不合并字段</strong>，直接覆盖整个配置（可能丢失未指定的字段）。</li><li>慎用，通常仅在需要完全重置配置时使用。</li></ul><p><strong>建议</strong>：</p><ul><li>**优先使用 <code>apply</code>**（声明式操作更符合 Kubernetes 设计理念）。</li><li>仅在需要严格控制创建时使用 <code>create</code>。</li><li><strong>自动化流程</strong>：推荐始终使用 <code>apply</code>（避免因资源存在导致失败）。</li></ul><h2 id="5-Deployment-案例实操"><a href="#5-Deployment-案例实操" class="headerlink" title="5. Deployment - 案例实操"></a>5. Deployment - 案例实操</h2><h3 id="5-1-编写资源清单"><a href="#5-1-编写资源清单" class="headerlink" title="5.1 编写资源清单"></a>5.1 编写资源清单</h3><p><code>004-deployment-demo.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 控制器类型为：Deployment</span><span class="attr">metadata:</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">deployment-demo</span> <span class="comment"># 控制器标签</span>  <span class="attr">name:</span> <span class="string">deployment-demo-1</span> <span class="comment"># 控制器名称</span><span class="attr">spec:</span>  <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment"># 初始Pod副本数</span>  <span class="attr">selector:</span>    <span class="attr">matchLabels:</span>      <span class="attr">app:</span> <span class="string">deployment-demo</span> <span class="comment"># Pod标签选择器，管理 标签为 app: deployment-demo 的Pod</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">labels:</span>        <span class="attr">app:</span> <span class="string">deployment-demo</span> <span class="comment"># Pod的标签，与 selector 标签选择器对应</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span> <span class="comment"># 容器使用的镜像</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 镜像拉取策略</span>          <span class="attr">name:</span> <span class="string">deployment-demo-container</span> <span class="comment"># 镜像</span></code></pre><h3 id="5-2-创建-Deployment"><a href="#5-2-创建-Deployment" class="headerlink" title="5.2 创建 Deployment"></a>5.2 创建 Deployment</h3><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">根据资源清单创建 Deployment 和对应的 Pod</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f 004-deployment-demo.yaml</span></code></pre><h3 id="5-3-查看-Deployment-和-Pod"><a href="#5-3-查看-Deployment-和-Pod" class="headerlink" title="5.3 查看 Deployment  和 Pod"></a>5.3 查看 Deployment  和 Pod</h3><p><strong>查看 Deployment 信息</strong></p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployment -o wide</span> NAME                READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS                  IMAGES                     SELECTORdeployment-demo-1   1/1     1            1           2m21s   deployment-demo-container   wangyanglinux/myapp:v1.0   app=deployment-demo</code></pre><p>可以看到创建一个 Deployment 类型的控制器，名称为：deployment-demo-1， 标签为：app&#x3D;deployment-demo，控制器内 Pod的副本数为 1。</p><p><strong>查看 Deployment 详细信息</strong></p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployment deployment-demo-1 -o yaml</span></code></pre><p><em>内容如下：</em></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span><span class="attr">kind:</span> <span class="string">Deployment</span><span class="attr">metadata:</span>  <span class="attr">annotations:</span>    <span class="attr">deployment.kubernetes.io/revision:</span> <span class="string">&quot;1&quot;</span> <span class="comment"># 当前修订版本号（用于回滚）</span>    <span class="attr">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="string">|</span> <span class="comment"># 上次 kubectl apply 使用的完整配置（用于对比变更）</span>      &#123;<span class="string">&quot;apiVersion&quot;</span><span class="string">:&quot;apps/v1&quot;</span>,<span class="string">&quot;kind&quot;</span><span class="string">:&quot;Deployment&quot;</span>,<span class="string">&quot;metadata&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;annotations&quot;</span><span class="string">:</span>&#123;&#125;,<span class="string">&quot;labels&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;app&quot;</span><span class="string">:&quot;deployment-demo&quot;</span>&#125;,<span class="string">&quot;name&quot;</span><span class="string">:&quot;deployment-demo-1&quot;</span>,<span class="string">&quot;namespace&quot;</span><span class="string">:&quot;default&quot;</span>&#125;,<span class="string">&quot;spec&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;replicas&quot;</span><span class="string">:1</span>,<span class="string">&quot;selector&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;matchLabels&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;app&quot;</span><span class="string">:&quot;deployment-demo&quot;</span>&#125;&#125;,<span class="string">&quot;template&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;metadata&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;labels&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;app&quot;</span><span class="string">:&quot;deployment-demo&quot;</span>&#125;&#125;,<span class="string">&quot;spec&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;containers&quot;</span><span class="string">:</span>[&#123;<span class="string">&quot;image&quot;</span><span class="string">:&quot;wangyanglinux/myapp:v1.0&quot;</span>,<span class="string">&quot;imagePullPolicy&quot;</span><span class="string">:&quot;IfNotPresent&quot;</span>,<span class="string">&quot;name&quot;</span><span class="string">:&quot;deployment-demo-container&quot;</span>&#125;]&#125;&#125;&#125;&#125;  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2025-04-09T01:59:05Z&quot;</span>  <span class="attr">generation:</span> <span class="number">1</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">deployment-demo</span>  <span class="attr">name:</span> <span class="string">deployment-demo-1</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">resourceVersion:</span> <span class="string">&quot;1484447&quot;</span>  <span class="attr">uid:</span> <span class="string">8cec6671-c1e9-4292-921c-dbe8bae8c357</span><span class="attr">spec:</span>  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span>  <span class="attr">replicas:</span> <span class="number">1</span>  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span> <span class="comment"># 保留最近 10 个历史版本（用于回滚），超出部分会被自动清理</span>  <span class="attr">selector:</span>    <span class="attr">matchLabels:</span>      <span class="attr">app:</span> <span class="string">deployment-demo</span>  <span class="attr">strategy:</span>    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新策略 (strategy)</span>      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span> <span class="comment"># 允许临时超出期望副本数的比例（例如 1.25 个 Pod）</span>      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span> <span class="comment"># 更新时允许不可用的 Pod 比例（例如最多 0.75 个 Pod 不可用）</span>    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 更新策略类型: 滚动更新,逐步替换旧 Pod，确保服务不中断。</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">creationTimestamp:</span> <span class="literal">null</span>      <span class="attr">labels:</span>        <span class="attr">app:</span> <span class="string">deployment-demo</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>        <span class="attr">name:</span> <span class="string">deployment-demo-container</span>        <span class="attr">resources:</span> &#123;&#125;        <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span>        <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span>      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span>      <span class="attr">restartPolicy:</span> <span class="string">Always</span>      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span>      <span class="attr">securityContext:</span> &#123;&#125;      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span> <span class="comment"># 终止前等待 30 秒（优雅退出）</span><span class="attr">status:</span>  <span class="attr">availableReplicas:</span> <span class="number">1</span> <span class="comment"># 当前可用的 Pod 数量</span>  <span class="attr">conditions:</span>  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2025-04-09T01:59:07Z&quot;</span>    <span class="attr">lastUpdateTime:</span> <span class="string">&quot;2025-04-09T01:59:07Z&quot;</span>    <span class="attr">message:</span> <span class="string">Deployment</span> <span class="string">has</span> <span class="string">minimum</span> <span class="string">availability.</span>    <span class="attr">reason:</span> <span class="string">MinimumReplicasAvailable</span>    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span>    <span class="attr">type:</span> <span class="string">Available</span>  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2025-04-09T01:59:05Z&quot;</span>    <span class="attr">lastUpdateTime:</span> <span class="string">&quot;2025-04-09T01:59:07Z&quot;</span>    <span class="attr">message:</span> <span class="string">ReplicaSet</span> <span class="string">&quot;deployment-demo-1-6995c75668&quot;</span> <span class="string">has</span> <span class="string">successfully</span> <span class="string">progressed.</span>    <span class="attr">reason:</span> <span class="string">NewReplicaSetAvailable</span>    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span>    <span class="attr">type:</span> <span class="string">Progressing</span>  <span class="attr">observedGeneration:</span> <span class="number">1</span>  <span class="attr">readyReplicas:</span> <span class="number">1</span> <span class="comment"># 已就绪的 Pod 数量</span>  <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment"># 实际运行的 Pod 数量</span>  <span class="attr">updatedReplicas:</span> <span class="number">1</span> <span class="comment"># 已更新到最新版本的 Pod 数量</span></code></pre><p><strong>查看Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -o wide</span>NAME                                 READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATESdeployment-demo-1-6995c75668-klh7h   1/1     Running   0          33m   172.16.58.208   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre><p>注意看 Pod 的名字是 <code>deployment-demo-1-6995c75668-klh7h</code> ，这是由 Deployment 创建时，自动创建了 对应的 ReplicaSet 的名字(<code>deployment-demo-1-6995c75668</code>) 再拼接上 随机字符串：<code>klh7h</code> 生成的，可以查看是否有 ReplicaSet 验证：</p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get rs</span>NAME                           DESIRED   CURRENT   READY   AGEdeployment-demo-1-6995c75668   1         1         1       33m</code></pre><h3 id="5-4-Pod-副本扩缩容"><a href="#5-4-Pod-副本扩缩容" class="headerlink" title="5.4 Pod 副本扩缩容"></a>5.4 Pod 副本扩缩容</h3><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">查看当前Pod副本数</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span>NAME                                 READY   STATUS    RESTARTS   AGEdeployment-demo-1-6995c75668-klh7h   1/1     Running   0          29h<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">扩展 Pod 数量</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale deployment deployment-demo-1 --replicas 10</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">再次查看 Pod 数量</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod</span> NAME                                 READY   STATUS    RESTARTS   AGEdeployment-demo-1-6995c75668-44fnz   1/1     Running   0          10sdeployment-demo-1-6995c75668-64zdm   1/1     Running   0          10sdeployment-demo-1-6995c75668-9xxbc   1/1     Running   0          10sdeployment-demo-1-6995c75668-klh7h   1/1     Running   0          29hdeployment-demo-1-6995c75668-kqqhj   1/1     Running   0          10sdeployment-demo-1-6995c75668-mmdrx   1/1     Running   0          10sdeployment-demo-1-6995c75668-twr24   1/1     Running   0          10sdeployment-demo-1-6995c75668-vq67h   1/1     Running   0          10sdeployment-demo-1-6995c75668-wpq6x   1/1     Running   0          10sdeployment-demo-1-6995c75668-zxvwc   1/1     Running   0          10s<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">缩小 Pod 副本数</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale deployment deployment-demo-1 --replicas 1</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">再次查看Pod</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod</span> NAME                                 READY   STATUS    RESTARTS   AGEdeployment-demo-1-6995c75668-klh7h   1/1     Running   0          29h</code></pre><h3 id="5-5-动态更新-Deployment-的-Pod-容器镜像"><a href="#5-5-动态更新-Deployment-的-Pod-容器镜像" class="headerlink" title="5.5 动态更新 Deployment 的 Pod 容器镜像"></a>5.5 动态更新 Deployment 的 Pod 容器镜像</h3><p>当前资源清单中使用的镜像是：<code>wangyanglinux/myapp:v1.0</code> ，现在测试在不停止Pod运行的情况下，将镜像升级到  <code>wangyanglinux/myapp:v2.0</code></p><p><strong>查看当前运行中的Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建 Pod</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f 004-deployment-demo.yaml --record</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -o wide</span>NAME                                 READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATESdeployment-demo-1-6995c75668-4rljk   1/1     Running   0          28m   172.16.58.213   k8s-node02   &lt;none&gt;           &lt;none&gt;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">访问Pod，确认当前版本是 1.0</span><span class="meta prompt_">$ </span><span class="language-bash">curl 172.16.58.213</span>www.xinxianghf.com | hello MyAPP | version v1.0</code></pre><p><em>命令后面添加  <code>--record</code> 目的是为了让 kubectl 记住Pod操作历史，以便于后期回滚操作。</em></p><p><strong>升级容器镜像版本</strong></p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">set</span> image deployment/deployment-demo-1 deployment-demo-container=wangyanglinux/myapp:v2.0 --record</span><span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -o wide</span>NAME                                 READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATESdeployment-demo-1-6465d4c5c9-b5dsn   1/1     Running   0          89s   172.16.58.214   k8s-node02   &lt;none&gt;           &lt;none&gt;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">访问Pod，镜像版本已更新到 2.0</span><span class="meta prompt_">$ </span><span class="language-bash">curl 172.16.58.214</span>www.xinxianghf.com | hello MyAPP | version v2.0</code></pre><p><strong>查看Pod更新的历史记录</strong></p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="built_in">history</span> deployment/deployment-demo-1</span>deployment.apps/deployment-demo-1 REVISION  CHANGE-CAUSE1         kubectl apply --filename=004-deployment-demo.yaml --record=true2         kubectl set image deployment/deployment-demo-1 deployment-demo-container=wangyanglinux/myapp:v2.0 --record=true</code></pre><h2 id="6-Deployment-滚动升级"><a href="#6-Deployment-滚动升级" class="headerlink" title="6. Deployment 滚动升级"></a>6. Deployment 滚动升级</h2><p>在 Kubernetes 中，<strong>Deployment</strong> 是管理 Pod 副本和实现无缝升级的核心资源。<strong>滚动升级（Rolling Update）</strong> 是默认的更新策略，它允许逐步替换旧版本的 Pod，确保应用在升级过程中<strong>不中断服务</strong>。</p><h3 id="6-1-滚动升级的核心机制"><a href="#6-1-滚动升级的核心机制" class="headerlink" title="6.1 滚动升级的核心机制"></a>6.1 滚动升级的核心机制</h3><h3 id="（1）更新流程"><a href="#（1）更新流程" class="headerlink" title="（1）更新流程"></a>（1）更新流程</h3><ol><li><strong>创建新版本的 ReplicaSet</strong><ul><li>当修改 Deployment 的 Pod 模板（如镜像版本）时，Kubernetes 会创建一个新的 ReplicaSet。</li><li>新 ReplicaSet 逐步启动新 Pod，旧 ReplicaSet 逐步缩减旧 Pod。</li></ul></li><li><strong>逐步替换 Pod</strong><ul><li>通过 <code>maxSurge</code> 和 <code>maxUnavailable</code> 控制替换速度：<ul><li>**<code>maxSurge</code>**：允许临时超出 <code>replicas</code> 的 Pod 数量（默认 25%）。</li><li>**<code>maxUnavailable</code>**：升级过程中允许不可用的 Pod 比例（默认 25%）。</li></ul></li></ul></li><li><strong>完成升级</strong><ul><li>所有旧 Pod 被替换后，旧 ReplicaSet 保留（便于回滚），但 Pod 数为 0。</li></ul></li></ol><h3 id="（2）关键配置参数"><a href="#（2）关键配置参数" class="headerlink" title="（2）关键配置参数"></a>（2）关键配置参数</h3><p>在 Deployment 的 <code>spec.strategy</code> 中定义：</p><pre><code class="highlight yaml"><span class="attr">spec:</span>  <span class="attr">strategy:</span>    <span class="attr">type:</span> <span class="string">RollingUpdate</span>    <span class="attr">rollingUpdate:</span>      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span>     <span class="comment"># 允许临时多启动 25% 的 Pod（例如 replicas=4 时，最多 5 个 Pod）</span>      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span>  <span class="comment"># 允许最多 25% 的 Pod 不可用（例如 replicas=4 时，至少 3 个 Pod 可用）</span></code></pre><h3 id="6-2-触发滚动升级的方式"><a href="#6-2-触发滚动升级的方式" class="headerlink" title="6.2 触发滚动升级的方式"></a>6.2 触发滚动升级的方式</h3><h3 id="（1）直接修改-YAML-并应用"><a href="#（1）直接修改-YAML-并应用" class="headerlink" title="（1）直接修改 YAML 并应用"></a>（1）直接修改 YAML 并应用</h3><pre><code class="highlight shell">kubectl apply -f deployment.yaml</code></pre><p>适用于通过版本控制的 YAML 文件管理部署。</p><h3 id="（2）命令式更新镜像版本"><a href="#（2）命令式更新镜像版本" class="headerlink" title="（2）命令式更新镜像版本"></a>（2）命令式更新镜像版本</h3><pre><code class="highlight shell">kubectl set image deployment/&lt;deployment-name&gt; &lt;container-name&gt;=&lt;new-image&gt;:&lt;tag&gt;</code></pre><p>例如：</p><pre><code class="highlight shell">kubectl set image deployment/deployment-demo-1 deployment-demo-container=wangyanglinux/myapp:v2.0</code></pre><h3 id="（3）其他可触发升级的操作"><a href="#（3）其他可触发升级的操作" class="headerlink" title="（3）其他可触发升级的操作"></a>（3）其他可触发升级的操作</h3><ul><li>修改环境变量、资源限制（CPU&#x2F;内存）、标签等 Pod 模板内容。</li><li><strong>调整副本数（<code>kubectl scale</code>）不会触发滚动升级。</strong></li></ul><h3 id="6-3-查看升级状态"><a href="#6-3-查看升级状态" class="headerlink" title="6.3 查看升级状态"></a>6.3 查看升级状态</h3><h3 id="（1）检查升级进度"><a href="#（1）检查升级进度" class="headerlink" title="（1）检查升级进度"></a>（1）检查升级进度</h3><pre><code class="highlight bash">kubectl rollout status deployment/&lt;deployment-name&gt;</code></pre><p>输出示例：</p><pre><code class="highlight bash">Waiting <span class="keyword">for</span> rollout to finish: 2 out of 3 new replicas have been updated...</code></pre><h3 id="（2）查看历史版本"><a href="#（2）查看历史版本" class="headerlink" title="（2）查看历史版本"></a>（2）查看历史版本</h3><pre><code class="highlight bash">kubectl rollout <span class="built_in">history</span> deployment/&lt;deployment-name&gt;</code></pre><p>输出示例：</p><pre><code class="highlight bash">REVISION  CHANGE-CAUSE1         kubectl apply --filename=deployment.yaml2         kubectl <span class="built_in">set</span> image deployment/deployment-demo-1 deployment-demo-container=myapp:v2.0</code></pre><h3 id="（3）查看具体版本的配置"><a href="#（3）查看具体版本的配置" class="headerlink" title="（3）查看具体版本的配置"></a>（3）查看具体版本的配置</h3><pre><code class="highlight bash">kubectl rollout <span class="built_in">history</span> deployment/&lt;deployment-name&gt; --revision=&lt;revision-number&gt;</code></pre><p>例如：</p><pre><code class="highlight plaintext">kubectl rollout history deployment/deployment-demo-1 --revision=2</code></pre><h3 id="6-4-回滚升级"><a href="#6-4-回滚升级" class="headerlink" title="6.4 回滚升级"></a>6.4 回滚升级</h3><p>如果新版本出现问题，可快速回滚到之前的版本：</p><h3 id="（1）回滚到上一个版本"><a href="#（1）回滚到上一个版本" class="headerlink" title="（1）回滚到上一个版本"></a>（1）回滚到上一个版本</h3><pre><code class="highlight bash">kubectl rollout undo deployment/&lt;deployment-name&gt;</code></pre><h3 id="（2）回滚到指定版本"><a href="#（2）回滚到指定版本" class="headerlink" title="（2）回滚到指定版本"></a>（2）回滚到指定版本</h3><pre><code class="highlight bash">kubectl rollout undo deployment/&lt;deployment-name&gt; --to-revision=&lt;revision-number&gt;</code></pre><p>例如：</p><pre><code class="highlight bash">kubectl rollout undo deployment/deployment-demo-1 --to-revision=1</code></pre><h3 id="6-5-高级控制技巧"><a href="#6-5-高级控制技巧" class="headerlink" title="6.5 高级控制技巧"></a>6.5 高级控制技巧</h3><h3 id="（1）暂停-恢复升级"><a href="#（1）暂停-恢复升级" class="headerlink" title="（1）暂停&#x2F;恢复升级"></a>（1）暂停&#x2F;恢复升级</h3><ul><li><p><strong>暂停升级</strong>（手动分阶段发布）：</p><pre><code class="highlight bash">kubectl rollout pause deployment/&lt;deployment-name&gt;</code></pre></li><li><p><strong>恢复升级</strong>：</p><pre><code class="highlight bash">kubectl rollout resume deployment/&lt;deployment-name&gt;</code></pre></li></ul><h3 id="（2）强制重建-Pod（非滚动更新）"><a href="#（2）强制重建-Pod（非滚动更新）" class="headerlink" title="（2）强制重建 Pod（非滚动更新）"></a>（2）强制重建 Pod（非滚动更新）</h3><p>删除所有 Pod 触发重建（慎用）：</p><pre><code class="highlight bash">kubectl delete pods -l app=&lt;deployment-label&gt;</code></pre><h3 id="（3）修改默认滚动策略"><a href="#（3）修改默认滚动策略" class="headerlink" title="（3）修改默认滚动策略"></a>（3）修改默认滚动策略</h3><p>默认滚动策略如下：</p><pre><code class="highlight yaml"><span class="attr">spec:</span>  <span class="attr">strategy:</span>    <span class="attr">type:</span> <span class="string">RollingUpdate</span>    <span class="attr">rollingUpdate:</span>      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span>     <span class="comment"># 允许临时多启动 25% 的 Pod（例如 replicas=4 时，最多 5 个 Pod）</span>      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span>  <span class="comment"># 允许最多 25% 的 Pod 不可用（例如 replicas=4 时，至少 3 个 Pod 可用）</span></code></pre><p>查看当前 Deployment 滚动策略：</p><pre><code class="highlight bash"><span class="variable">$kubectl</span> get deployment my-deployment-demo -o jsonpath=<span class="string">&#x27;&#123;.spec.strategy&#125;&#x27;</span>&#123;<span class="string">&quot;rollingUpdate&quot;</span>:&#123;<span class="string">&quot;maxSurge&quot;</span>:<span class="string">&quot;25%&quot;</span>,<span class="string">&quot;maxUnavailable&quot;</span>:<span class="string">&quot;25%&quot;</span>&#125;,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;RollingUpdate&quot;</span>&#125;</code></pre><p>修改滚动策略，</p><pre><code class="highlight bash"><span class="variable">$kubectl</span> edit deployment my-deployment-demo --record</code></pre><p>修改完成后保存，会自动生效。</p><h3 id="6-6-故障排查"><a href="#6-6-故障排查" class="headerlink" title="6.6 故障排查"></a>6.6 故障排查</h3><h3 id="（1）升级卡住怎么办？"><a href="#（1）升级卡住怎么办？" class="headerlink" title="（1）升级卡住怎么办？"></a>（1）升级卡住怎么办？</h3><ul><li><p>检查事件：</p><pre><code class="highlight bash">kubectl describe deployment/&lt;deployment-name&gt;</code></pre></li><li><p>查看 Pod 状态：</p><pre><code class="highlight bash">kubectl get pods</code></pre></li></ul><h3 id="（2）常见原因"><a href="#（2）常见原因" class="headerlink" title="（2）常见原因"></a>（2）常见原因</h3><ul><li><strong>镜像拉取失败</strong>：检查镜像名称或权限。</li><li><strong>资源不足</strong>：节点 CPU&#x2F;内存不足。</li><li><strong>就绪探针失败</strong>：新版本 Pod 未通过健康检查。</li></ul><h2 id="7-滚动升级案例实操"><a href="#7-滚动升级案例实操" class="headerlink" title="7. 滚动升级案例实操"></a>7. 滚动升级案例实操</h2><p>演示一个 Deployment 下有多个 Pod 副本（10个），升级镜像版本，以及回退版本相关操作。</p><h3 id="7-1-资源清单"><a href="#7-1-资源清单" class="headerlink" title="7.1 资源清单"></a>7.1 资源清单</h3><p> <code>005-deployment-demo.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 控制器类型为：Deployment</span><span class="attr">metadata:</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">deployment-demo</span> <span class="comment"># 控制器标签</span>  <span class="attr">name:</span> <span class="string">my-deployment-demo</span> <span class="comment"># 控制器名称</span><span class="attr">spec:</span>  <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment"># 初始Pod副本数</span>  <span class="attr">selector:</span>    <span class="attr">matchLabels:</span>      <span class="attr">app:</span> <span class="string">deployment-demo</span> <span class="comment"># Pod标签选择器，管理 标签为 app: deployment-demo 的Pod</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">labels:</span>        <span class="attr">app:</span> <span class="string">deployment-demo</span> <span class="comment"># Pod的标签，与 selector 标签选择器对应</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deployment-demo-container</span> <span class="comment"># 容器名称</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span> <span class="comment"># 容器使用的镜像</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 镜像拉取策略</span></code></pre><h3 id="7-2-创建-Service"><a href="#7-2-创建-Service" class="headerlink" title="7.2 创建 Service"></a>7.2 创建 Service</h3><p>创建Service的目的是为了通过访问 service，查看 Pod 滚动升级的过程。</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建 Service</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl create svc clusterip deployment-demo --tcp=80:80</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看 Service</span> <span class="meta prompt_">$ </span><span class="language-bash">kubectl get svc</span>NAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGEdeployment-demo   ClusterIP   10.103.97.136   &lt;none&gt;        80/TCP    5m53skubernetes        ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   13d<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">while</span> 命令循环访问 service</span><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> curl 10.103.97.136; <span class="keyword">done</span></span></code></pre><h3 id="7-3-创建Deloyment"><a href="#7-3-创建Deloyment" class="headerlink" title="7.3 创建Deloyment"></a>7.3 创建Deloyment</h3><pre><code class="highlight bash"><span class="comment"># 创建 Deployment ，添加了 --record 会记录操作的命令详情</span>$ kubectl create -f 005-deployment-demo.yaml --recordFlag --record has been deprecated, --record will be removed <span class="keyword">in</span> the futuredeployment.apps/my-deployment-demo created<span class="comment"># 查看 Deployment</span>$ kubectl get deployment -o wide NAME                 READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS                  IMAGES                     SELECTORmy-deployment-demo   1/1     1            1           3s    deployment-demo-container   wangyanglinux/myapp:v1.0   app=deployment-demo</code></pre><h3 id="7-4-Pod副本扩容"><a href="#7-4-Pod副本扩容" class="headerlink" title="7.4 Pod副本扩容"></a>7.4 Pod副本扩容</h3><pre><code class="highlight bash"><span class="comment"># 将当前Pod数量从1个，扩容到10个</span>$ kubectl scale deployment my-deployment-demo --replicas 10deployment.apps/my-deployment-demo scaled<span class="comment"># 查看Deployment</span>$ kubectl get deployment -o wide NAME                 READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS                  IMAGES                     SELECTORmy-deployment-demo   10/10   10           10          2m49s   deployment-demo-container   wangyanglinux/myapp:v1.0   app=deployment-demo<span class="comment"># 查看Pod</span>$ kubectl get pod -l app=deployment-demo -o wideNAME                                  READY   STATUS    RESTARTS   AGE     IP              NODE         NOMINATED NODE   READINESS GATESmy-deployment-demo-6995c75668-5fxrj   1/1     Running   0          2m31s   172.16.85.211   k8s-node01   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-977kq   1/1     Running   0          2m31s   172.16.58.223   k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-lq4kj   1/1     Running   0          2m31s   172.16.58.221   k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-mvdsm   1/1     Running   0          2m31s   172.16.58.220   k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-rt2wp   1/1     Running   0          2m31s   172.16.85.208   k8s-node01   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-ssx86   1/1     Running   0          2m31s   172.16.58.222   k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-v69wv   1/1     Running   0          2m31s   172.16.85.210   k8s-node01   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-vvjg2   1/1     Running   0          2m31s   172.16.85.212   k8s-node01   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-whc7z   1/1     Running   0          5m3s    172.16.58.219   k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-zsgg9   1/1     Running   0          2m31s   172.16.85.209   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><h3 id="7-5-查看当前Pod的镜像版本"><a href="#7-5-查看当前Pod的镜像版本" class="headerlink" title="7.5 查看当前Pod的镜像版本"></a>7.5 查看当前Pod的镜像版本</h3><pre><code class="highlight bash">$ <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> curl 10.103.97.136; <span class="keyword">done</span>www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0</code></pre><p>当前访问的所有Pod 镜像版本都是 1.0</p><h3 id="7-6-升级-Pod-镜像版本"><a href="#7-6-升级-Pod-镜像版本" class="headerlink" title="7.6 升级 Pod 镜像版本"></a>7.6 升级 Pod 镜像版本</h3><p>新开一个shell终端，执行命令升级镜像版本，前一个shell终端循环访问pod，打印Pod镜像版本信息</p><pre><code class="highlight bash"><span class="comment"># 升级镜像版本，并打印当前pod详细信息</span>$ kubectl <span class="built_in">set</span> image deployment/my-deployment-demo deployment-demo-container=wangyanglinux/myapp:v2.0 --record &amp;&amp; kubectl get pod -l app=deployment-demo -o widedeployment.apps/my-deployment-demo image updatedNAME                                  READY   STATUS              RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATESmy-deployment-demo-6465d4c5c9-crrcz   0/1     Pending             0          0s    &lt;none&gt;          k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6465d4c5c9-fckht   0/1     ContainerCreating   0          0s    &lt;none&gt;          k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6465d4c5c9-tkjst   0/1     ContainerCreating   0          0s    &lt;none&gt;          k8s-node01   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-2fg6c   1/1     Running             0          12m   172.16.58.229   k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-bhs4q   1/1     Running             0          11m   172.16.85.221   k8s-node01   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-fj7hf   1/1     Running             0          11m   172.16.85.220   k8s-node01   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-p7bhr   1/1     Running             0          11m   172.16.85.218   k8s-node01   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-qbdmg   1/1     Running             0          11m   172.16.58.230   k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-qprl6   1/1     Running             0          11m   172.16.85.222   k8s-node01   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-qtdbb   1/1     Terminating         0          11m   172.16.58.232   k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-r2xvv   1/1     Running             0          11m   172.16.85.219   k8s-node01   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-sg7vt   1/1     Terminating         0          11m   172.16.58.233   k8s-node02   &lt;none&gt;           &lt;none&gt;my-deployment-demo-6995c75668-wbqn2   1/1     Running             0          11m   172.16.58.231   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre><p>此时Pod正在升级滚动升级中，当前看到共有13个Pod，这是因为Pod在滚动升级的过程中，默认允许新增不超过原设定副本数 25% 副本数量（<code>maxSurge: 25%</code>）。（上面的打印结果有2个Pod的状态是 Terminating，运行中和加载中的Pod数没有超过原设备Pod数的 125%）</p><p>查看前一个shell终端的打印结果如下：</p><pre><code class="highlight bash">w.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v2.0www.xinxianghf.com | hello MyAPP | version v2.0www.xinxianghf.com | hello MyAPP | version v2.0www.xinxianghf.com | hello MyAPP | version v1.0curl: (7) Failed to connect to 10.103.97.136 port 80: Connection refusedwww.xinxianghf.com | hello MyAPP | version v1.0curl: (7) Failed to connect to 10.103.97.136 port 80: Connection refusedwww.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v2.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v2.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0curl: (7) Failed to connect to 10.103.97.136 port 80: Connection refusedcurl: (7) Failed to connect to 10.103.97.136 port 80: Connection refusedwww.xinxianghf.com | hello MyAPP | version v2.0curl: (7) Failed to connect to 10.103.97.136 port 80: Connection refusedwww.xinxianghf.com | hello MyAPP | version v1.0curl: (7) Failed to connect to 10.103.97.136 port 80: Connection refusedwww.xinxianghf.com | hello MyAPP | version v1.0www.xinxianghf.com | hello MyAPP | version v1.0</code></pre><p><strong>可以得出如下结论：</strong></p><ul><li>通过访问 Service 会轮询访问 lable 名称与 Service 名称一样的 Pod</li><li>Pod 正处于滚动升级的过程中，打印的镜像版本有的是 1.0，有的是 2.0，有的处于 Terminating 状态，不可访问</li></ul><h2 id="8-Deloyment-回滚案例实操"><a href="#8-Deloyment-回滚案例实操" class="headerlink" title="8. Deloyment 回滚案例实操"></a>8. Deloyment 回滚案例实操</h2><h3 id="8-1-资源清单"><a href="#8-1-资源清单" class="headerlink" title="8.1 资源清单"></a>8.1 资源清单</h3><p><code>006-deployment-demo.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 控制器类型为：Deployment</span><span class="attr">metadata:</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">deployment-demo</span> <span class="comment"># 控制器标签</span>  <span class="attr">name:</span> <span class="string">my-deployment-demo</span> <span class="comment"># 控制器名称</span><span class="attr">spec:</span>  <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment"># 初始Pod副本数</span>  <span class="attr">selector:</span>    <span class="attr">matchLabels:</span>      <span class="attr">app:</span> <span class="string">deployment-demo</span> <span class="comment"># Pod标签选择器，管理 标签为 app: deployment-demo 的Pod</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">labels:</span>        <span class="attr">app:</span> <span class="string">deployment-demo</span> <span class="comment"># Pod的标签，与 selector 标签选择器对应</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deployment-demo-container</span> <span class="comment"># 容器名称</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span> <span class="comment"># 容器使用的镜像</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 镜像拉取策略</span></code></pre><h3 id="8-2-创建Deployment"><a href="#8-2-创建Deployment" class="headerlink" title="8.2 创建Deployment"></a>8.2 创建Deployment</h3><pre><code class="highlight bash"><span class="comment"># 1.创建 Service</span>$ kubectl create svc clusterip deployment-demo --tcp=80:80<span class="comment"># 查看 Service </span>$ kubectl get svcNAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGEdeployment-demo   ClusterIP   10.103.97.136   &lt;none&gt;        80/TCP    5m53skubernetes        ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   13d<span class="comment"># 2.创建 Deployment ，添加了 --record 会记录操作的命令详情</span>$ kubectl create -f 006-deployment-demo.yaml --record<span class="comment"># 3. 将当前Pod数量从1个，扩容到10个</span>$ kubectl scale deployment my-deployment-demo --replicas 10<span class="comment"># 查看Deployment</span>$ kubectl get deployment -o wide NAME                 READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS                  IMAGES                     SELECTORmy-deployment-demo   10/10   10           10          2m49s   deployment-demo-container   wangyanglinux/myapp:v1.0   app=deployment-demo<span class="comment"># 查看当前 Pod 镜像版本</span>$ curl 10.103.97.136www.xinxianghf.com | hello MyAPP | version v1.0</code></pre><h3 id="8-3-升级镜像"><a href="#8-3-升级镜像" class="headerlink" title="8.3 升级镜像"></a>8.3 升级镜像</h3><pre><code class="highlight bash"><span class="comment"># 1. 将镜像版本升级到 2.0</span>$ kubectl <span class="built_in">set</span> image deployment/my-deployment-demo deployment-demo-container=wangyanglinux/myapp:v2.0 --record<span class="comment"># 测试访问镜像</span>$ curl 10.103.97.136www.xinxianghf.com | hello MyAPP | version v2.0<span class="comment"># 2. 将镜像版本升级到 3.0</span>$ kubectl <span class="built_in">set</span> image deployment/my-deployment-demo deployment-demo-container=wangyanglinux/myapp:v3.0 --record<span class="comment"># 测试访问镜像</span>$ curl 10.103.97.136www.xinxianghf.com | hello MyAPP | version v3.0<span class="comment"># 3. 查看 Deployment 历史版本（创建Deployment、升级镜像命令都添加了 --record 参数，所以CHANGE-CAUSE才有操作记录）</span>$ kubectl rollout <span class="built_in">history</span> deployment/my-deployment-demodeployment.apps/my-deployment-demo REVISION  CHANGE-CAUSE1         kubectl apply --filename=006-deployment-demo.yaml --record=<span class="literal">true</span>2         kubectl <span class="built_in">set</span> image deployment/my-deployment-demo deployment-demo-container=wangyanglinux/myapp:v2.0 --record=<span class="literal">true</span>3         kubectl <span class="built_in">set</span> image deployment/my-deployment-demo deployment-demo-container=wangyanglinux/myapp:v3.0 --record=<span class="literal">true</span></code></pre><h3 id="8-4-回滚镜像版本"><a href="#8-4-回滚镜像版本" class="headerlink" title="8.4 回滚镜像版本"></a>8.4 回滚镜像版本</h3><h4 id="6-4-1-回滚到上一个版本"><a href="#6-4-1-回滚到上一个版本" class="headerlink" title="6.4.1 回滚到上一个版本"></a>6.4.1 回滚到上一个版本</h4><pre><code class="highlight bash"><span class="comment"># 1.回滚到上一个版本（从3.0 -&gt; 2.0）</span>$ kubectl rollout undo deployment/my-deployment-demo<span class="comment"># 测试访问镜像（此时已回滚到 2.0版本）</span>$ curl 10.103.97.136www.xinxianghf.com | hello MyAPP | version v2.0<span class="comment"># 2.再次执行版本回滚</span>$ kubectl rollout undo deployment/my-deployment-demo<span class="comment"># 测试访问镜像（此时又回滚到 3.0版本）</span>$ curl 10.103.97.136www.xinxianghf.com | hello MyAPP | version v3.0</code></pre><p><code>kubectl rollout undo deployment/&lt;deployment-demo&gt;</code> 命令只能回滚到前一次操作，但无法回滚到前前上操作，例如升级操作如下：<br>v1 -&gt; v2 -&gt; v3<br>升级到v3版本后开始回滚：v1 -&gt; v2 -&gt; v3 -&gt; v2 -&gt; v3 -&gt; v2 -&gt; v3 ，<br>这样无法从 v3 -&gt; v1</p><h4 id="8-4-2-回滚到指定版本"><a href="#8-4-2-回滚到指定版本" class="headerlink" title="8.4.2 回滚到指定版本"></a>8.4.2 回滚到指定版本</h4><p>前面的每次升级操作命令，都携带了参数 <code>--record</code> ，此参数会让 kubectl 记录操作命令，通过查看 deployment 历史版本，方便版本回滚。</p><pre><code class="highlight bash"><span class="comment"># 1.查看 Deployment 历史版本（REVISION 就是每次操作后的版本号）</span>$ kubectl rollout <span class="built_in">history</span> deployment/my-deployment-demodeployment.apps/my-deployment-demo REVISION  CHANGE-CAUSE1         kubectl apply --filename=006-deployment-demo.yaml --record=<span class="literal">true</span>4         kubectl <span class="built_in">set</span> image deployment/my-deployment-demo deployment-demo-container=wangyanglinux/myapp:v2.0 --record=<span class="literal">true</span>5         kubectl <span class="built_in">set</span> image deployment/my-deployment-demo deployment-demo-container=wangyanglinux/myapp:v3.0 --record=<span class="literal">true</span><span class="comment"># 2.回滚到 v1.0 版本（通过指定版本号）</span>$ kubectl rollout undo deployment my-deployment-demo --to-revision=1<span class="comment"># 测试访问镜像（此时回滚到 1.0版本）</span>$ curl 10.103.97.136www.xinxianghf.com | hello MyAPP | version v1.0</code></pre><h2 id="9-Deployment-清理策略"><a href="#9-Deployment-清理策略" class="headerlink" title="9. Deployment 清理策略"></a>9. Deployment 清理策略</h2><p>过设置 <code>.spec.revisionHistoryLimit</code> 项来指定 deployment 最多保留多少 revision 历史记录。默认的会保留所有的 revision；如果将该项设置为0，Deployment 就不允许回退了</p><h1 id="四、DaemonSet-控制器"><a href="#四、DaemonSet-控制器" class="headerlink" title="四、DaemonSet 控制器"></a>四、DaemonSet 控制器</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>在 Kubernetes 中，<strong>DaemonSet</strong> 控制器用于确保集群中的每个节点（或指定节点子集）都运行一个 Pod 副本。通常用于部署系统级别的服务，例如日志收集代理（如 Fluentd、Logstash）、监控代理（如 Prometheus Node Exporter）或网络代理（如 kube-proxy）。当有 Node 加入集群时，也会为他们新增一个 Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod</p><p>使用 DaemonSet  的一些典型用法：</p><ul><li>运行集群存储 daemon，例如在每个 Node 上运行 <code>glusterd</code>、<code>ceph</code></li><li>在每个 Node 上运行日志收集 daemon，例如<code>fluentd</code>、<code>logstash</code></li><li>在每个 Node 上运行监控 daemon，例如 Prometheus Node Exporter、<code>collectd</code>、Datadog 代理、New Relic 代理，或 Ganglia <code>gmond</code></li></ul><h2 id="2-DaemonSet-的核心特性"><a href="#2-DaemonSet-的核心特性" class="headerlink" title="2. DaemonSet 的核心特性"></a>2. DaemonSet 的核心特性</h2><ul><li><strong>自动调度</strong>：DaemonSet 确保每个符合条件的节点上运行一个 Pod。如果节点被添加或移除，DaemonSet 会自动调整。</li><li><strong>Pod 一致性</strong>：所有 Pod 通常使用相同的 Pod 模板运行。</li><li><strong>节点选择</strong>：可以通过 nodeSelector 或 taints&#x2F;tolerations 控制 DaemonSet 在哪些节点上运行。</li><li><strong>更新策略</strong>：支持 RollingUpdate 和 OnDelete 两种更新策略，默认是 RollingUpdate。</li></ul><h2 id="3-案例演示"><a href="#3-案例演示" class="headerlink" title="3. 案例演示"></a>3. 案例演示</h2><h3 id="3-1-资源清单"><a href="#3-1-资源清单" class="headerlink" title="3.1 资源清单"></a>3.1 资源清单</h3><p><code>007-DaemonSet-demo.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span><span class="attr">kind:</span> <span class="string">DaemonSet</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">my-daemonset-demo</span> <span class="comment"># DaemonSet 控制器的名字</span>  <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># 命名空间</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">daemonset-demo</span> <span class="comment"># DaemonSet 控制的标签</span><span class="attr">spec:</span>  <span class="attr">selector:</span>    <span class="attr">matchLabels:</span>      <span class="attr">name:</span> <span class="string">daemonset-demo</span> <span class="comment"># 匹配标签为 name: daemonset-demo 的Pod</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">labels:</span> <span class="comment"># Pod模板标签，与 spec.selector.matchLabels 对应</span>        <span class="attr">name:</span> <span class="string">daemonset-demo</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span> <span class="comment"># 主容器</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">daemonset-demo-container</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></code></pre><h3 id="3-1-创建-DaemonSet"><a href="#3-1-创建-DaemonSet" class="headerlink" title="3.1 创建 DaemonSet"></a>3.1 创建 DaemonSet</h3><pre><code class="highlight bash"><span class="comment"># 创建 DaemonSet 控制器</span>$ kubectl apply -f 007-DaemonSet-demo.yaml</code></pre><h3 id="3-2-查看-DeamonSet"><a href="#3-2-查看-DeamonSet" class="headerlink" title="3.2 查看 DeamonSet"></a>3.2 查看 DeamonSet</h3><pre><code class="highlight yaml"><span class="comment"># 查看 DaemonSet (指定了 名称空间、标签)</span><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">ds</span> <span class="string">-n</span> <span class="string">default</span> <span class="string">-l</span> <span class="string">app=daemonset-demo</span> <span class="string">-o</span> <span class="string">wide</span><span class="string">NAME</span>                <span class="string">DESIRED</span>   <span class="string">CURRENT</span>   <span class="string">READY</span>   <span class="string">UP-TO-DATE</span>   <span class="string">AVAILABLE</span>   <span class="string">NODE</span> <span class="string">SELECTOR</span>   <span class="string">AGE</span>    <span class="string">CONTAINERS</span>                 <span class="string">IMAGES</span>                     <span class="string">SELECTOR</span><span class="string">my-daemonset-demo</span>   <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>       <span class="number">2</span>            <span class="number">2</span>           <span class="string">&lt;none&gt;</span>          <span class="string">4m5s</span>   <span class="string">daemonset-demo-container</span>   <span class="string">wangyanglinux/myapp:v1.0</span>   <span class="string">name=daemonset-demo</span></code></pre><h3 id="3-3-查看-Pod"><a href="#3-3-查看-Pod" class="headerlink" title="3.3 查看 Pod"></a>3.3 查看 Pod</h3><pre><code class="highlight bash">$ kubectl get pod -n default -o wideNAME                      READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATESmy-daemonset-demo-kltsf   1/1     Running   0          36s   172.16.58.215   k8s-node02   &lt;none&gt;           &lt;none&gt;my-daemonset-demo-tn554   1/1     Running   0          36s   172.16.85.211   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>DanmonSet 控制器自动创建了两个 Pod，分别运行到两个子节点上（k8s-node01、k8s-node02），而没有运行到 master 节点，这是为什么呢？</p><h3 id="3-4-为什么-DeamonSet-没有运行在主节点上"><a href="#3-4-为什么-DeamonSet-没有运行在主节点上" class="headerlink" title="3.4 为什么 DeamonSet 没有运行在主节点上"></a>3.4 为什么 DeamonSet 没有运行在主节点上</h3><p>在 Kubernetes 中，<strong>DaemonSet 创建的 Pod 默认不会运行到主节点（master 或 control-plane 节点）</strong>，主要是因为主节点通常被配置了<strong>污点（Taints）</strong>，而 DaemonSet 创建的 Pod 没有默认的<strong>容忍（Tolerations）</strong>来匹配这些污点。以下是详细原因及机制：</p><h4 id="3-4-1-主节点的污点（Taints）"><a href="#3-4-1-主节点的污点（Taints）" class="headerlink" title="3.4.1 主节点的污点（Taints）"></a>3.4.1 主节点的污点（Taints）</h4><p>Kubernetes 主节点通常被配置了一个或多个污点，以防止普通的工作负载（包括 DaemonSet 的 Pod）调度到这些节点上。常见的污点是：</p><ul><li><strong>node-role.kubernetes.io&#x2F;master:NoSchedule</strong>（Kubernetes 1.24 及更早版本）</li><li><strong>node-role.kubernetes.io&#x2F;control-plane:NoSchedule</strong>（Kubernetes 1.25 及更新版本）</li></ul><p>这些污点的效果是 NoSchedule，表示除非 Pod 明确声明可以容忍该污点，否则不会被调度到主节点。</p><p>查看主节点污点：</p><pre><code class="highlight bash">kubectl describe node &lt;master-node-name&gt; | grep -i taint</code></pre><p>示例输出：</p><pre><code class="highlight bash">Taints:             node-role.kubernetes.io/control-plane:NoSchedule</code></pre><h3 id="3-4-2-DaemonSet-Pod-的容忍（Tolerations）"><a href="#3-4-2-DaemonSet-Pod-的容忍（Tolerations）" class="headerlink" title="3.4.2 DaemonSet Pod 的容忍（Tolerations）"></a>3.4.2 DaemonSet Pod 的容忍（Tolerations）</h3><p>DaemonSet 的 Pod 模板（spec.template.spec）默认不包含任何 tolerations。这意味着它们无法绕过主节点的 NoSchedule 污点，因此不会被调度到主节点。</p><p>例如资源清单 <code>007-DaemonSet-demo.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span><span class="attr">kind:</span> <span class="string">DaemonSet</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">my-daemonset-demo</span> <span class="comment"># DaemonSet 控制器的名字</span>  <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># 命名空间</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">daemonset-demo</span> <span class="comment"># DaemonSet 控制的标签</span><span class="attr">spec:</span>  <span class="attr">selector:</span>    <span class="attr">matchLabels:</span>      <span class="attr">name:</span> <span class="string">daemonset-demo</span> <span class="comment"># 匹配标签为 name: daemonset-demo 的Pod</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">labels:</span> <span class="comment"># Pod模板标签，与 spec.selector.matchLabels 对应</span>        <span class="attr">name:</span> <span class="string">daemonset-demo</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span> <span class="comment"># 主容器</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">daemonset-demo-container</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></code></pre><p>在这个配置中，spec.template.spec 没有定义 tolerations，因此 Pod 不会调度到带有 NoSchedule 污点的主节点。</p><h4 id="3-4-3-为什么主节点需要污点？"><a href="#3-4-3-为什么主节点需要污点？" class="headerlink" title="3.4.3 为什么主节点需要污点？"></a>3.4.3 为什么主节点需要污点？</h4><p>主节点运行控制平面组件（如 kube-apiserver、kube-scheduler、kube-controller-manager），这些组件对集群的稳定性至关重要。允许普通工作负载（如 DaemonSet 的 Pod）运行在主节点可能会导致以下问题：</p><ul><li><strong>资源竞争</strong>：DaemonSet Pod 可能消耗 CPU、内存等资源，影响控制平面组件的性能。</li><li><strong>稳定性风险</strong>：某些 DaemonSet Pod（例如日志收集或监控代理）可能出现异常，干扰主节点的运行。</li><li><strong>安全隔离</strong>：主节点通常需要更高的隔离级别，避免不受信任的工作负载运行。</li></ul><p>因此，Kubernetes 默认通过污点机制保护主节点，只允许特定的、必要的 Pod（如控制平面组件或特定的系统 DaemonSet）运行。</p><h4 id="3-4-4-例外情况：系统-DaemonSet"><a href="#3-4-4-例外情况：系统-DaemonSet" class="headerlink" title="3.4.4 例外情况：系统 DaemonSet"></a>3.4.4 例外情况：系统 DaemonSet</h4><p>某些系统级的 DaemonSet（如 kube-proxy、CNI 插件）确实需要运行在所有节点上，包括主节点。这些 DaemonSet 的 YAML 通常会显式配置 tolerations 来容忍主节点的污点。例如：</p><pre><code class="highlight yaml"><span class="attr">spec:</span>  <span class="attr">template:</span>    <span class="attr">spec:</span>      <span class="attr">tolerations:</span>      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/control-plane</span>        <span class="attr">operator:</span> <span class="string">Exists</span>        <span class="attr">effect:</span> <span class="string">NoSchedule</span>      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span>        <span class="attr">operator:</span> <span class="string">Exists</span>        <span class="attr">effect:</span> <span class="string">NoSchedule</span></code></pre><p>这种配置允许 Pod 忽略主节点的污点，从而调度到主节点。</p><h4 id="3-4-5-如何让-DaemonSet-Pod-运行在主节点？"><a href="#3-4-5-如何让-DaemonSet-Pod-运行在主节点？" class="headerlink" title="3.4.5 如何让 DaemonSet Pod 运行在主节点？"></a>3.4.5 如何让 DaemonSet Pod 运行在主节点？</h4><p>如果你希望 DaemonSet 的 Pod 运行在主节点上，可以在 DaemonSet 的 Pod 模板中添加相应的 tolerations。</p><p><strong>查看节点列表</strong></p><pre><code class="highlight bash">$ kubectl get nodes --show-labelsNAME         STATUS   ROLES           AGE   VERSION    LABELSk8s-node01   Ready    &lt;none&gt;          14d   v1.29.15   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node01,kubernetes.io/os=linuxk8s-node02   Ready    &lt;none&gt;          14d   v1.29.15   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node02,kubernetes.io/os=linuxnode         Ready    control-plane   14d   v1.29.15   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=node,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node.kubernetes.io/exclude-from-external-load-balancers=</code></pre><p>可以看到有三个节点，其中 name为 node 的就是 master 节点，因为该节点的标签中包含：<code>node-role.kubernetes.io/control-plane</code></p><p><strong>查看 master 节点详情</strong></p><pre><code class="highlight bash">$ kubectl describe nodes nodeName:               nodeRoles:              control-planeLabels:             beta.kubernetes.io/arch=amd64                    beta.kubernetes.io/os=linux                    kubernetes.io/arch=amd64                    kubernetes.io/hostname=node                    kubernetes.io/os=linux                    node-role.kubernetes.io/control-plane=                    node.kubernetes.io/exclude-from-external-load-balancers=Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: unix:///var/run/cri-dockerd.sock                    node.alpha.kubernetes.io/ttl: 0                    projectcalico.org/IPv4Address: 192.168.6.139/24                    projectcalico.org/IPv4IPIPTunnelAddr: 172.16.167.128                    volumes.kubernetes.io/controller-managed-attach-detach: <span class="literal">true</span>CreationTimestamp:  Fri, 28 Mar 2025 17:24:27 +0800<span class="comment"># Node自身设置的污点，key为node-role.kubernetes.io/control-plane，影响效果：:NoSchedule(不是key的值)</span>Taints:             node-role.kubernetes.io/control-plane:NoScheduleUnschedulable:      <span class="literal">false</span>Lease:  HolderIdentity:  node  AcquireTime:     &lt;<span class="built_in">unset</span>&gt;  RenewTime:       Sat, 12 Apr 2025 14:07:56 +0800...</code></pre><p><strong>资源清单内容如下：</strong><br><code>008-DaemonSet-demo.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span><span class="attr">kind:</span> <span class="string">DaemonSet</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">my-daemonset-demo</span> <span class="comment"># DaemonSet 控制器的名字</span>  <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># 命名空间</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">daemonset-demo</span> <span class="comment"># DaemonSet 控制的标签</span><span class="attr">spec:</span>  <span class="attr">selector:</span>    <span class="attr">matchLabels:</span>      <span class="attr">name:</span> <span class="string">daemonset-demo</span> <span class="comment"># 匹配标签为 name: daemonset-demo 的Pod</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">labels:</span> <span class="comment"># Pod模板标签，与 spec.selector.matchLabels 对应</span>        <span class="attr">name:</span> <span class="string">daemonset-demo</span>    <span class="attr">spec:</span>      <span class="attr">tolerations:</span> <span class="comment"># 定义了 Pod 的容忍度，允许 Pod 被调度到带有特定污点的节点上</span>        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/control-plane</span> <span class="comment"># 这里允许 Pod 被调度到控制平面节点（通常有 node-role.kubernetes.io/control-plane:NoSchedule 污点）</span>          <span class="attr">operator:</span> <span class="string">Exists</span> <span class="comment"># 表示只要存在指定的 key 就容忍(Exists：只要节点上有这个键的污点就匹配（不需要检查值）, 如果是Equal：要求键和值都匹配（此时需要指定 value 字段）)</span>          <span class="attr">effect:</span> <span class="string">NoSchedule</span> <span class="comment"># 指定要容忍污点的影响效果</span>      <span class="attr">containers:</span> <span class="comment"># 主容器</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">daemonset-demo-container</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></code></pre><p><strong>创建 DaemonSet</strong></p><pre><code class="highlight bash"><span class="comment"># 创建DS</span>$ kubectl apply -f 008-DaemonSet-demo.yaml --record<span class="comment"># 查看DS，可以看到DS运行了三个 Pod</span>$ kubectl get ds -o wideNAME                DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE     CONTAINERS                 IMAGES                     SELECTORmy-daemonset-demo   3         3         3       3            3           &lt;none&gt;          2m33s   daemonset-demo-container   wangyanglinux/myapp:v1.0   name=daemonset-demo<span class="comment"># 查看Pod（master节点也运行了一个Pod）</span>$ kubectl get pods -o wideNAME                      READY   STATUS    RESTARTS   AGE   IP                NODE         NOMINATED NODE   READINESS GATESmy-daemonset-demo-gsjlk   1/1     Running   0          11s   192.168.167.141   node         &lt;none&gt;           &lt;none&gt;my-daemonset-demo-j5nls   1/1     Running   0          11s   192.168.58.200    k8s-node02   &lt;none&gt;           &lt;none&gt;my-daemonset-demo-vv9cf   1/1     Running   0          11s   192.168.85.204    k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p><strong>查看Pod</strong></p><pre><code class="highlight bash"><span class="comment"># 查看 DaemonSet，此时 DeamonSet 控制器有了三个Pod</span>$ kubectl get ds -o wideNAME                DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE    CONTAINERS                 IMAGES                     SELECTORmy-daemonset-demo   3         3         3       3            3           &lt;none&gt;          135m   daemonset-demo-container   wangyanglinux/myapp:v1.0   name=daemonset-demo<span class="comment"># 查看 Pod</span>$ kubectl get pods -o wideNAME                      READY   STATUS    RESTARTS       AGE    IP                NODE         NOMINATED NODE   READINESS GATESmy-daemonset-demo-gsjlk   1/1     Running   1 (129m ago)   137m   192.168.167.142   node         &lt;none&gt;           &lt;none&gt;my-daemonset-demo-j5nls   1/1     Running   1 (129m ago)   137m   192.168.58.201    k8s-node02   &lt;none&gt;           &lt;none&gt;my-daemonset-demo-vv9cf   1/1     Running   1 (129m ago)   137m   192.168.85.205    k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>master 节点上也运行了一个 Pod，资源清单配置生效。</p><h1 id="五、Job-控制器"><a href="#五、Job-控制器" class="headerlink" title="五、Job 控制器"></a>五、Job 控制器</h1><h2 id="1-Job-控制器特性"><a href="#1-Job-控制器特性" class="headerlink" title="1. Job 控制器特性"></a>1. Job 控制器特性</h2><p>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束</p><p><strong>特殊说明</strong></p><ul><li>spec.template 格式同 Pod</li><li>RestartPolicy 仅支持 Never 或 OnFailure</li><li>单个 Pod 时，默认 Pod 成功运行后 Job 即结束</li><li><code>.spec.completions</code> 标志 Job 结束需要成功运行的 Pod 个数，默认为 1</li><li><code>.spec.parallelism</code> 标志并行运行的 Pod 的个数，默认为 1</li><li><code>spec.activeDeadlineSeconds</code> 设置了 Job 的最长活动时间（单位：秒）。这个计时器从 Job 被创建时开始计时：<ul><li><strong>超时强制终止</strong>：如果 Job 运行时间超过 10 秒（包括 Pod 创建、执行、重试等所有时间），整个 Job 会被 Kubernetes 强制终止。</li><li><strong>状态标记</strong>：超时后 Job 的状态会变为 <code>Failed</code>，并显示原因 <code>Reason: DeadlineExceeded</code>。</li></ul></li></ul><h2 id="2-案例演示"><a href="#2-案例演示" class="headerlink" title="2. 案例演示"></a>2. 案例演示</h2><p>求 π 值，算法：马青公式</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/04/13/20250413-211253.png" alt="马青公式"></p><p>这个公式由英国天文学教授 约翰·马青 于 1706 年发现。他利用这个公式计算到了 100 位的圆周率。马青公式每计算一项可以得到 1.4 位的 十进制精度。因为它的计算过程中被乘数和被除数都不大于长整数，所以可以很容易地在计算机上编程实现</p><h3 id="2-1-Python代码"><a href="#2-1-Python代码" class="headerlink" title="2.1 Python代码"></a>2.1 Python代码</h3><p><code>main.py</code></p><pre><code class="highlight python"><span class="comment"># -*- coding: utf-8 -*-</span><span class="keyword">from</span> __future__ <span class="keyword">import</span> division<span class="comment"># 导入时间模块</span><span class="keyword">import</span> time<span class="comment"># 计算当前时间</span>time1=time.time()<span class="comment"># 算法根据马青公式计算圆周率 #</span>number = <span class="number">1000</span><span class="comment"># 多计算10位，防止尾数取舍的影响</span>number1 = number+<span class="number">10</span><span class="comment"># 算到小数点后number1位</span>b = <span class="number">10</span>**number1<span class="comment"># 求含4/5的首项</span>x1 = b*<span class="number">4</span>//<span class="number">5</span><span class="comment"># 求含1/239的首项</span>x2 = b // -<span class="number">239</span><span class="comment"># 求第一大项</span>he = x1+x2<span class="comment">#设置下面循环的终点，即共计算n项</span>number *= <span class="number">2</span><span class="comment">#循环初值=3，末值2n,步长=2</span><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">3</span>,number,<span class="number">2</span>):  <span class="comment"># 求每个含1/5的项及符号</span>  x1 //= -<span class="number">25</span>  <span class="comment"># 求每个含1/239的项及符号</span>  x2 //= -<span class="number">57121</span>  <span class="comment"># 求两项之和</span>  x = (x1+x2) // i  <span class="comment"># 求总和</span>  he += x<span class="comment"># 求出π</span>pai = he*<span class="number">4</span><span class="comment">#舍掉后十位</span>pai //= <span class="number">10</span>**<span class="number">10</span><span class="comment"># 输出圆周率π的值</span>paistring=<span class="built_in">str</span>(pai)result=paistring[<span class="number">0</span>]+<span class="built_in">str</span>(<span class="string">&#x27;.&#x27;</span>)+paistring[<span class="number">1</span>:<span class="built_in">len</span>(paistring)]<span class="built_in">print</span> resulttime2=time.time()<span class="built_in">print</span> <span class="string">u&#x27;Total time:&#x27;</span> + <span class="built_in">str</span>(time2 - time1) + <span class="string">&#x27;s&#x27;</span></code></pre><h3 id="2-2-Dockerfile"><a href="#2-2-Dockerfile" class="headerlink" title="2.2 Dockerfile"></a>2.2 Dockerfile</h3><pre><code class="highlight dockerfile"><span class="keyword">FROM</span> python:<span class="number">2.7</span><span class="keyword">ADD</span><span class="language-bash"> ./main.py /root</span><span class="keyword">CMD</span><span class="language-bash"> /usr/bin/python /root/main.py</span></code></pre><h3 id="2-3-构建镜像"><a href="#2-3-构建镜像" class="headerlink" title="2.3 构建镜像"></a>2.3 构建镜像</h3><pre><code class="highlight bash"><span class="comment"># 将 main.py 放到 Dockerfile 同级目录下，并在此目录执行下面的命令构建镜像</span>docker build -t tools:maqingpythonv1 .</code></pre><h3 id="2-4-资源清单"><a href="#2-4-资源清单" class="headerlink" title="2.4 资源清单"></a>2.4 资源清单</h3><p><code>009-job-demo.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span><span class="attr">kind:</span> <span class="string">Job</span> <span class="comment"># Job控制器资源类型</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">job-demo</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">my-job</span><span class="attr">spec:</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">name:</span> <span class="string">my-job-pod</span>      <span class="attr">labels:</span>        <span class="attr">app:</span> <span class="string">my-job</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">job-demo-container</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/tools:maqingpythonv1</span>      <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 对于 Job 控制器，容器重启策略仅支持 Never 和 OnFailure</span></code></pre><p>查看日志，可以显示出打印的 2000 位  π 值</p><h3 id="2-5-运行Pod，查看日志"><a href="#2-5-运行Pod，查看日志" class="headerlink" title="2.5 运行Pod，查看日志"></a>2.5 运行Pod，查看日志</h3><p><strong>运行Pod</strong></p><pre><code class="highlight bash"><span class="comment"># 运行job控制器</span>$ kubectl apply -f 009-job-demo.yaml</code></pre><p><strong>查看Job运行状态</strong></p><pre><code class="highlight bash"><span class="comment"># 查看job列表</span>$ kubectl get jobNAME       COMPLETIONS   DURATION   AGEjob-demo   1/1           3s         6m48s<span class="comment"># 查看Job详情</span>$ kubectl describe job job-demoName:             job-demoNamespace:        defaultSelector:         batch.kubernetes.io/controller-uid=ea1dec0d-b8d4-4942-8b72-2d3ac0abde91Labels:           app=my-jobAnnotations:      &lt;none&gt;Parallelism:      1Completions:      1Completion Mode:  NonIndexedStart Time:       Thu, 17 Apr 2025 21:32:13 +0800Completed At:     Thu, 17 Apr 2025 21:32:16 +0800Duration:         3sPods Statuses:    0 Active (0 Ready) / 1 Succeeded / 0 FailedPod Template:  Labels:  app=my-job           batch.kubernetes.io/controller-uid=ea1dec0d-b8d4-4942-8b72-2d3ac0abde91           batch.kubernetes.io/job-name=job-demo           controller-uid=ea1dec0d-b8d4-4942-8b72-2d3ac0abde91           job-name=job-demo  Containers:   job-demo-container:    Image:        wangyanglinux/tools:maqingpythonv1    Port:         &lt;none&gt;    Host Port:    &lt;none&gt;    Environment:  &lt;none&gt;    Mounts:       &lt;none&gt;  Volumes:        &lt;none&gt;Events:  Type    Reason            Age    From            Message  ----    ------            ----   ----            -------  Normal  SuccessfulCreate  6m25s  job-controller  Created pod: job-demo-6q4sh  Normal  Completed         6m22s  job-controller  Job completed</code></pre><p>通过查看Job详情，观察到 Job 已运行完成</p><p><strong>查看Pod列表</strong></p><pre><code class="highlight bash">$ kubectl get pods -o wideNAME             READY   STATUS      RESTARTS   AGE     IP              NODE         NOMINATED NODE   READINESS GATESjob-demo-6q4sh   0/1     Completed   0          7m58s   172.16.58.217   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre><p><strong>查看Pod运行日志</strong></p><pre><code class="highlight bash">$ kubectl logs job-demo-6q4sh -f --<span class="built_in">tail</span>=10003.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941511609433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949129833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132000568127145263560827785771342757789609173637178721468440901224953430146549585371050792279689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927876611195909216420198</code></pre><p>打印出了圆周率！！！</p><h2 id="3-Job-正常退出完成"><a href="#3-Job-正常退出完成" class="headerlink" title="3. Job - 正常退出完成"></a>3. Job - 正常退出完成</h2><p>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束</p><h3 id="3-1-案例一：让容器返回码为1"><a href="#3-1-案例一：让容器返回码为1" class="headerlink" title="3.1 案例一：让容器返回码为1"></a>3.1 案例一：让容器返回码为1</h3><p>目的：指定容器退出的返回码为1，验证当返回码不为0时，Job会异常退出。</p><p><code>010-job-rand-demo.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span><span class="attr">kind:</span> <span class="string">Job</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">rand</span>  <span class="attr">namespace:</span> <span class="string">default</span><span class="attr">spec:</span>  <span class="attr">completions:</span> <span class="number">1</span> <span class="comment"># 标志Job结束需要成功运行的 Pod 个数，默认为1</span>  <span class="attr">parallelism:</span> <span class="number">5</span> <span class="comment"># 标志并行运行的Pod的个数，默认为1</span>  <span class="comment"># activeDeadlineSeconds: 10 # 标志失败Pod 的重试最大时间，由于Pod重启策略为Never，因此超过 10秒，整个Pod强制中止</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">name:</span> <span class="string">rand</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rand</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/tools:randexitv1</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>          <span class="comment"># 指定退出码</span>          <span class="attr">args:</span> [<span class="string">&quot;--exitcode=1&quot;</span>]      <span class="attr">restartPolicy:</span> <span class="string">Never</span></code></pre><p><strong>运行Pod，查看结果</strong></p><pre><code class="highlight bash">$ kubectl apply -f 010-job-rand-demo.yaml</code></pre><p><strong>监控Pod运行结果</strong></p><pre><code class="highlight bash">$ kubectl get pod -o wide -wNAME         READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATESrand-4ftcj   0/1     Error     0          27s   172.16.58.225   k8s-node02   &lt;none&gt;           &lt;none&gt;rand-76fkv   1/1     Running   0          2s    172.16.58.224   k8s-node02   &lt;none&gt;           &lt;none&gt;rand-zd9bp   0/1     Error     0          42s   172.16.58.228   k8s-node02   &lt;none&gt;           &lt;none&gt;rand-76fkv   0/1     Error     0          6s    172.16.58.224   k8s-node02   &lt;none&gt;           &lt;none&gt;rand-76fkv   0/1     Error     0          7s    172.16.58.224   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre><p>上面的Pod监控列表，一个Pod处于运行中，两个返回都是失败（运行中的Pod也会返回失败，因为在资源清单中制定了返回码为 1）。</p><p>由于在资源清单中指定了容器退出返回码为1，所以此清单创建的所有Pod都会返回失败。</p><p><strong>查看Pod日志</strong></p><pre><code class="highlight bash">$ kubectl logs rand-4ftcj -f --<span class="built_in">tail</span>=100休眠 4 秒，返回码为 1！$ kubectl logs rand-76fkv -f --<span class="built_in">tail</span>=100休眠 4 秒，返回码为 1！</code></pre><p>结论：只有当Pod容器返回码不为0为，Pod异常退出。</p><h3 id="3-2-案例二：随机生成返回码"><a href="#3-2-案例二：随机生成返回码" class="headerlink" title="3.2 案例二：随机生成返回码"></a>3.2 案例二：随机生成返回码</h3><p>目的：当Pod容器返回码为1是，Pod成功退出。</p><p><code>011-job-rand-demo.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span><span class="attr">kind:</span> <span class="string">Job</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">rand</span>  <span class="attr">namespace:</span> <span class="string">default</span><span class="attr">spec:</span>  <span class="attr">completions:</span> <span class="number">3</span> <span class="comment"># 标志Job结束需要成功运行的 Pod 个数，默认为1</span>  <span class="attr">parallelism:</span> <span class="number">5</span> <span class="comment"># 标志并行运行的Pod的个数，默认为1</span>  <span class="attr">template:</span>    <span class="attr">metadata:</span>      <span class="attr">name:</span> <span class="string">rand</span>    <span class="attr">spec:</span>      <span class="attr">containers:</span>        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rand</span>          <span class="attr">image:</span> <span class="string">wangyanglinux/tools:randexitv1</span>          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>      <span class="attr">restartPolicy:</span> <span class="string">Never</span></code></pre><p><strong>运行Pod，查看结果</strong></p><pre><code class="highlight bash"><span class="comment"># 运行Pod</span>$ kubectl apply -f 011-job-rand-demo.yaml</code></pre><p><strong>查看Pod运行列表</strong></p><pre><code class="highlight bash">$ kubectl get podsNAME         READY   STATUS    RESTARTS   AGErand-4jcmh   1/1     Running   0          5srand-dfnf9   1/1     Running   0          5srand-sh9vp   1/1     Running   0          5s</code></pre><p>有3个Pod 并行运行，符合资源清单设置内容 <code>spec.parallelism: 5</code></p><p><strong>等待Job运行结束后，再次查看Pod列表</strong></p><pre><code class="highlight bash">$ kubectl get pod -o wideNAME         READY   STATUS      RESTARTS   AGE     IP              NODE         NOMINATED NODE   READINESS GATESrand-4jcmh   0/1     Error       0          4m43s   172.16.58.238   k8s-node02   &lt;none&gt;           &lt;none&gt;rand-8kwhc   0/1     Completed   0          4m25s   172.16.58.242   k8s-node02   &lt;none&gt;           &lt;none&gt;rand-dfnf9   0/1     Completed   0          4m43s   172.16.58.229   k8s-node02   &lt;none&gt;           &lt;none&gt;rand-hk9lw   0/1     Completed   0          4m25s   172.16.58.239   k8s-node02   &lt;none&gt;           &lt;none&gt;rand-sh9vp   0/1     Error       0          4m43s   172.16.85.215   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>一共运行了5个Pod，其中3个运行完成，2个返回失败</p><p><strong>查看Job</strong></p><pre><code class="highlight bash">$ kubectl get job -o wideNAME   COMPLETIONS   DURATION   AGE   CONTAINERS   IMAGES                           SELECTORrand   3/3           26s        48s   rand         wangyanglinux/tools:randexitv1   batch.kubernetes.io/controller-uid=76957688-7f47-4694-a451-9adfb4f9c9cd</code></pre><p>Job 有3个Pod 运行完成，成功退出，满足资源清单设置要求：<code>spec.completions: 3</code></p><h1 id="六、CronJob-控制器"><a href="#六、CronJob-控制器" class="headerlink" title="六、CronJob 控制器"></a>六、CronJob 控制器</h1><h2 id="1-CronJob-控制器特性"><a href="#1-CronJob-控制器特性" class="headerlink" title="1. CronJob 控制器特性"></a>1. CronJob 控制器特性</h2><p>Cron Job  管理基于时间的 Job，即： </p><ul><li><p>在给定时间点只运行一次</p></li><li><p>周期性地在给定时间点运行</p></li></ul><p><strong>使用条件：当前使用的 Kubernetes 集群，版本 &gt;&#x3D; 1.8（对 CronJob）</strong></p><p>典型的用法如下所示：</p><ul><li>在给定的时间点调度 Job 运行</li><li>创建周期性运行的 Job，例如：数据库备份、发送邮件</li></ul><h2 id="2-CroneJob-资源清单"><a href="#2-CroneJob-资源清单" class="headerlink" title="2. CroneJob 资源清单"></a>2. CroneJob 资源清单</h2><ul><li><p><code>.spec.schedule</code>：调度，必需字段，指定任务运行周期，格式同 Cron</p></li><li><p><code>.spec.jobTemplate</code>：Job 模板，必需字段，指定需要运行的任务，格式同 Job</p></li><li><p><code>.spec.startingDeadlineSeconds</code> ：启动 Job 的期限（秒级别），该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的 Job 将被认为是失败的。如果没有指定，则没有期限</p></li><li><p><code>.spec.concurrencyPolicy</code>：并发策略，该字段也是可选的。它指定了如何处理被 Cron Job 创建的 Job 的并发执行。只允许指定下面策略中的一种：</p><ul><li><code>Allow</code>（默认）：允许并发运行 Job</li><li><code>Forbid</code>：禁止并发运行，如果前一个还没有完成，则直接跳过下一个</li><li><code>Replace</code>：取消当前正在运行的 Job，用一个新的来替换</li><li>注意，当前策略只能应用于同一个 Cron Job 创建的 Job。如果存在多个 Cron Job，     它们创建的 Job 之间总是允许并发运行。</li></ul></li><li><p><code>.spec.suspend</code> ：挂起，该字段也是可选的。如果设置为 <code>true</code>，后续所有执行都会被挂起。它对已经开始执行的 Job 不起作用。默认值为 <code>false</code></p></li><li><p><code>.spec.successfulJobsHistoryLimit</code> 和 <code>.spec.failedJobsHistoryLimit</code> ：历史限制，是可选的字段。它们指定了可以保留多少完成和失败的 Job。默认情况下，它们分别设置为 <code>3</code> 和 <code>1</code>。设置限制的值为 <code>0</code>，相关类型的 Job 完成后将不会被保留</p></li></ul><h2 id="3-案例演示-1"><a href="#3-案例演示-1" class="headerlink" title="3. 案例演示"></a>3. 案例演示</h2><h3 id="3-1-资源清单-1"><a href="#3-1-资源清单-1" class="headerlink" title="3.1 资源清单"></a>3.1 资源清单</h3><p><code>012-cronjob-demo.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span><span class="attr">kind:</span> <span class="string">CronJob</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">cronjob-demo</span>  <span class="attr">namespace:</span> <span class="string">default</span><span class="attr">spec:</span>  <span class="comment"># 调度，必需字段，指定任务运行周期，格式同 Cron</span>  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span> <span class="comment"># 每分钟执行一次</span>  <span class="attr">startingDeadlineSeconds:</span> <span class="number">30</span> <span class="comment"># 启动 Job 的期限（秒级别），该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的 Job 将被认为是失败的。如果没有指定，则没有期限</span>  <span class="attr">concurrencyPolicy:</span> <span class="string">Allow</span> <span class="comment"># 并发策略，该字段也是可选的。（默认）允许并发运行 Job</span>  <span class="attr">successfulJobsHistoryLimit:</span> <span class="number">10</span> <span class="comment"># 保留运行成功的job数，默认：3</span>  <span class="attr">failedJobsHistoryLimit:</span> <span class="number">3</span> <span class="comment">#保留云心告失败的Job数，默认：1</span>  <span class="comment"># Job 模板，必需字段，指定需要运行的任务，格式同 Job</span>  <span class="attr">jobTemplate:</span>    <span class="attr">spec:</span>      <span class="attr">completions:</span> <span class="number">3</span> <span class="comment"># 标志Job结束需要成功运行的 Pod 个数，默认为1</span>      <span class="attr">parallelism:</span> <span class="number">3</span> <span class="comment"># 标志并行运行的Pod的个数，默认为1</span>      <span class="attr">template:</span>        <span class="attr">spec:</span>          <span class="attr">containers:</span>            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cronjob-demo-container</span>              <span class="attr">image:</span> <span class="string">busybox</span>              <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>              <span class="attr">args:</span>                <span class="bullet">-</span> <span class="string">/bin/sh</span>                <span class="bullet">-</span> <span class="string">-c</span>                <span class="bullet">-</span> <span class="string">date;</span> <span class="string">echo</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">the</span> <span class="string">Kubernetes</span> <span class="string">cluster</span>          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span> <span class="comment">#  重启策略：失败重启</span></code></pre><h3 id="启动-CronJob"><a href="#启动-CronJob" class="headerlink" title="启动 CronJob"></a>启动 CronJob</h3><pre><code class="highlight bash">$ kubectl apply -f 012-cronjob-demo.yaml</code></pre><p><strong>查看结果</strong></p><pre><code class="highlight bash"><span class="comment"># 查看Pod运行列表，完成了3个Pod</span>$ kubectl get pods -o wideNAME                          READY   STATUS      RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATEScronjob-demo-29082370-8zl5f   0/1     Completed   0          15s   172.16.58.244   k8s-node02   &lt;none&gt;           &lt;none&gt;cronjob-demo-29082370-ht2mk   0/1     Completed   0          15s   172.16.85.217   k8s-node01   &lt;none&gt;           &lt;none&gt;cronjob-demo-29082370-mm7kc   0/1     Completed   0          15s   172.16.58.247   k8s-node02   &lt;none&gt;           &lt;none&gt;<span class="comment"># 查看 cronjob 控制器（cronjob 每分钟都会执行一次）</span>$ kubectl get cronjob -o wideNAME           SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE     CONTAINERS               IMAGES    SELECTORcronjob-demo   */1 * * * *   False     0        52s             2m14s   cronjob-demo-container   busybox   &lt;none&gt;<span class="comment"># 过一会再次查看Pod列表，又多了三个Pod，因为 cronjob 设置每次完成需要 3个pod，spec.completions: 3</span>$ kubectl get pods -o wideNAME                          READY   STATUS      RESTARTS   AGE    IP              NODE         NOMINATED NODE   READINESS GATEScronjob-demo-29082370-8zl5f   0/1     Completed   0          114s   172.16.58.244   k8s-node02   &lt;none&gt;           &lt;none&gt;cronjob-demo-29082370-ht2mk   0/1     Completed   0          114s   172.16.85.217   k8s-node01   &lt;none&gt;           &lt;none&gt;cronjob-demo-29082370-mm7kc   0/1     Completed   0          114s   172.16.58.247   k8s-node02   &lt;none&gt;           &lt;none&gt;cronjob-demo-29082371-68kdz   0/1     Completed   0          54s    172.16.58.243   k8s-node02   &lt;none&gt;           &lt;none&gt;cronjob-demo-29082371-9b5j6   0/1     Completed   0          54s    172.16.58.251   k8s-node02   &lt;none&gt;           &lt;none&gt;cronjob-demo-29082371-cf2dg   0/1     Completed   0          54s    172.16.85.216   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><h2 id="4-CronJob-限制"><a href="#4-CronJob-限制" class="headerlink" title="4. CronJob - 限制"></a>4. CronJob - 限制</h2><p><strong>创建 Job 操作应该是幂等的</strong></p><h1 id="七、StatefulSet-控制器"><a href="#七、StatefulSet-控制器" class="headerlink" title="七、StatefulSet 控制器"></a>七、StatefulSet 控制器</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、控制器概述&quot;&gt;&lt;a href=&quot;#一、控制器概述&quot; class=&quot;headerlink&quot; title=&quot;一、控制器概述&quot;&gt;&lt;/a&gt;一、控制器概述&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="k8s" scheme="https://georgechan95.github.io/categories/k8s/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="Docker" scheme="https://georgechan95.github.io/tags/Docker/"/>
    
    <category term="Rocky" scheme="https://georgechan95.github.io/tags/Rocky/"/>
    
  </entry>
  
  <entry>
    <title>004-Pod的生命周期</title>
    <link href="https://georgechan95.github.io/blog/79e06aab.html"/>
    <id>https://georgechan95.github.io/blog/79e06aab.html</id>
    <published>2025-03-22T01:05:00.000Z</published>
    <updated>2025-04-02T03:28:05.700Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>RockyLinux：9.3</p><p>K8s版本：1.29</p><p>Docker版本：27.4.1</p></blockquote><h1 id="1、Pod生命周期概述"><a href="#1、Pod生命周期概述" class="headerlink" title="1、Pod生命周期概述"></a>1、Pod生命周期概述</h1><p>Pod 的生命周期如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/03/22/20250322-103306.png" alt="Pod 的生命周期"></p><h1 id="2、initC"><a href="#2、initC" class="headerlink" title="2、initC"></a>2、initC</h1><h2 id="2-1-initC概述"><a href="#2-1-initC概述" class="headerlink" title="2.1 initC概述"></a>2.1 initC概述</h2><p>init 容器与普通的容器非常像，除了如下三点：</p><ul><li>init 容器总是运行到成功完成为止</li><li>每个 init 容器都必须在下一个 init 容器启动之前成功完成</li><li>initC 无法定义 readinessProbe，其它以外同应用容器定义无异</li></ul><p>如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的 restartPolicy 为 Never，它不会重新启动</p><p>在主容器 [mainC] 启动前,可以定义 initC 作为前置容器，用于检测主容器所需要的环境是否已准备完成(当然initC的定义不是必须的)。当在配置中定义了 initC ，则必须所有的initC都启动完成后，mainC 才能启动，否则 mainC 会一直处于阻塞中。</p><p>另外 initC 会按照 yaml文件中定义的顺序启动，只有当第一个 initC 容器启动完成后，第二个 initC 才能启动，否则第二个 initC 也会处于阻塞中。</p><p>下面是 initC 阻塞性检测的示例：</p><h2 id="2-2-pod-yaml文件"><a href="#2-2-pod-yaml文件" class="headerlink" title="2.2 pod yaml文件"></a>2.2 pod yaml文件</h2><h3 id="2-2-1-yaml文件内容"><a href="#2-2-1-yaml文件内容" class="headerlink" title="2.2.1 yaml文件内容"></a>2.2.1 yaml文件内容</h3><p><code>001-initC.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment"># API版本</span><span class="attr">kind:</span> <span class="string">Pod</span> <span class="comment"># 资源类型</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">init-1</span> <span class="comment"># Pod名称</span>  <span class="attr">labels:</span> <span class="comment"># 标签</span>    <span class="attr">app:</span> <span class="string">initc</span><span class="attr">spec:</span> <span class="comment"># Pod 期望</span>  <span class="attr">containers:</span> <span class="comment"># 容器定义</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span> <span class="comment"># 容器名</span>      <span class="attr">image:</span> <span class="string">gcr.io/google-containers/busybox:1.27</span> <span class="comment"># 该容器使用的镜像</span>      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo The app is running! &amp;&amp; sleep 3600&#x27;</span>]  <span class="attr">initContainers:</span> <span class="comment"># 初始化容器全部成功后，myapp-container容器才能启动成功</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span> <span class="comment"># 第一个初始化容器，等待 myservice 的 DNS 解析成功。</span>      <span class="attr">image:</span> <span class="string">gcr.io/google-containers/busybox:1.27</span>      <span class="attr">command:</span>        <span class="bullet">-</span> <span class="string">&#x27;sh&#x27;</span>        <span class="bullet">-</span> <span class="string">&#x27;-c&#x27;</span>        <span class="bullet">-</span> <span class="string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-mydb</span> <span class="comment"># 第二个初始化容器，等待 mydb 的 DNS 解析成功。 然后才会启动主容器 myapp-container。</span>      <span class="attr">image:</span> <span class="string">gcr.io/google-containers/busybox:1.27</span>      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;</span>]</code></pre><h3 id="2-2-2-pod-yaml文件解析"><a href="#2-2-2-pod-yaml文件解析" class="headerlink" title="2.2.2 pod yaml文件解析"></a>2.2.2 pod yaml文件解析</h3><pre><code class="highlight yaml"><span class="attr">containers:</span> <span class="comment"># 容器定义</span>  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span> <span class="comment"># 容器名</span>    <span class="attr">image:</span> <span class="string">gcr.io/google-containers/busybox:1.27</span> <span class="comment"># 该容器使用的镜像</span>    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo The app is running! &amp;&amp; sleep 3600&#x27;</span>]</code></pre><p>主容器 <code>myapp-container</code> 启动成功后会打印内容：<code>The app is running!</code> ，并且 sleep 3600 秒</p><pre><code class="highlight yaml"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span> <span class="comment"># 第一个初始化容器，等待 myservice 的 DNS 解析成功。</span>  <span class="attr">image:</span> <span class="string">gcr.io/google-containers/busybox:1.27</span>  <span class="attr">command:</span>    <span class="bullet">-</span> <span class="string">&#x27;sh&#x27;</span>    <span class="bullet">-</span> <span class="string">&#x27;-c&#x27;</span>    <span class="bullet">-</span> <span class="string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span></code></pre><p>第一个初始化容器：<code>init-myservice</code> 启动时会解析 DNS 域名：<code>myservice</code>， 解析成功则该初始化容器成功启动，解析失败则打印日志：<code>waiting for myservice</code>， 然后 sleep 2秒后，继续解析，直到成功为止。</p><pre><code class="highlight yaml"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-mydb</span> <span class="comment"># 第二个初始化容器，等待 mydb 的 DNS 解析成功。 然后才会启动主容器 myapp-container。</span>  <span class="attr">image:</span> <span class="string">gcr.io/google-containers/busybox:1.27</span>  <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;</span>]</code></pre><p>第一个初始化容器：<code>init-mydb</code> 启动时会解析 DNS 域名：<code>mydb</code>， 解析成功则该初始化容器成功启动，解析失败则打印日志：<code>waiting for mydb</code>， 然后 sleep 2秒后，继续解析，直到成功为止。</p><h2 id="2-3-启动Pod测试"><a href="#2-3-启动Pod测试" class="headerlink" title="2.3 启动Pod测试"></a>2.3 启动Pod测试</h2><h3 id="2-3-1-启动pod"><a href="#2-3-1-启动pod" class="headerlink" title="2.3.1 启动pod"></a>2.3.1 启动pod</h3><pre><code class="highlight shell">kubectl apply -f /opt/k8s/04/001-initC.yaml</code></pre><p>此时观察Pod 启动情况</p><pre><code class="highlight shell">[root@k8s-master01 ~]$ kubectl get podsNAME     READY   STATUS     RESTARTS   AGEinit-1   0/1     Init:0/2   0          2m42s<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">或者动态监控</span>[root@k8s-master01 ~]$ kubectl get pods -o wide -wNAME     READY   STATUS     RESTARTS   AGE    IP               NODE         NOMINATED NODE   READINESS GATESinit-1   0/1     Init:0/2   0          3m6s   192.168.85.193   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>此时可以看到 主容器未启动，且初始化容器未启动。</p><h3 id="2-3-2-查看初始化容器日志"><a href="#2-3-2-查看初始化容器日志" class="headerlink" title="2.3.2 查看初始化容器日志"></a>2.3.2 查看初始化容器日志</h3><pre><code class="highlight shell">[root@k8s-master01 ~]$ kubectl logs -f --tail=100 init-1 -c init-myservicenslookup: can&#x27;t resolve &#x27;myservice&#x27;Server:    10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localwaiting for myservicenslookup: can&#x27;t resolve &#x27;myservice&#x27;Server:    10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</code></pre><p><code>init-myservice</code> DNS未能解析名为 <code>myservice</code> 的服务，而此时初始化容器 <code>init-mydb</code> 还未启动。</p><pre><code class="highlight shell">[root@k8s-master01 ~]$ kubectl logs -f --tail=100 init-1 -c init-mydbError from server (BadRequest): container &quot;init-mydb&quot; in pod &quot;init-1&quot; is waiting to start: PodInitializing</code></pre><h3 id="2-3-3-创建Service：myservice"><a href="#2-3-3-创建Service：myservice" class="headerlink" title="2.3.3 创建Service：myservice"></a>2.3.3 创建Service：myservice</h3><pre><code class="highlight shell">kubectl create svc clusterip myservice --tcp=80:80</code></pre><p>创建Service，名为 <code>myservice</code>，在k8s中默认名称即为域名，这样在集群中就有了一个域名为：myservice 的服务了。</p><p>此时再观察 Pod 的启动情况：</p><pre><code class="highlight shell">[root@k8s-master01 ~]$ kubectl get podsNAME     READY   STATUS     RESTARTS   AGEinit-1   0/1     Init:1/2   0          13m</code></pre><p>初始化容器1已启动。</p><h3 id="2-3-4-观察初始化容器2：init-mydb"><a href="#2-3-4-观察初始化容器2：init-mydb" class="headerlink" title="2.3.4 观察初始化容器2：init-mydb"></a>2.3.4 观察初始化容器2：<code>init-mydb</code></h3><pre><code class="highlight shell">[root@k8s-master01 ~]$ kubectl logs -f --tail=100 init-1 -c init-mydbServer:    10.96.0.10nslookup: can&#x27;t resolve &#x27;mydb&#x27;Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localwaiting for mydbServer:    10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</code></pre><p><code>init-mydb</code> 容器未启动，因为无法解析域名：<code>mydb</code>，此时主容器 <code>myapp-container</code> 未启动，需要等待初始化容器都启动成功后才能启动主容器。</p><h3 id="2-3-5-创建Service：mydb"><a href="#2-3-5-创建Service：mydb" class="headerlink" title="2.3.5 创建Service：mydb"></a>2.3.5 创建Service：mydb</h3><pre><code class="highlight shell">kubectl create svc clusterip mydb --tcp=80:80</code></pre><p>此时再观察Pod启动情况</p><pre><code class="highlight shell">[root@k8s-master01 ~]$ kubectl get pods -o wide -wNAME     READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATESinit-1   1/1     Running   0          18m   192.168.85.193   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>初始化容器启动完成，主容器启动完成。</p><h3 id="2-3-6-查看容器启动日志"><a href="#2-3-6-查看容器启动日志" class="headerlink" title="2.3.6 查看容器启动日志"></a>2.3.6 查看容器启动日志</h3><pre><code class="highlight shell">[root@k8s-master01 ~]$ kubectl logs -f --tail=100 init-1 -c myapp-containerThe app is running!</code></pre><p><strong>结论：</strong></p><ul><li>初始化容器必须全部启动完成后，主容器才能启动</li><li>初始化容器启动是有顺序的</li></ul><h1 id="3、探针"><a href="#3、探针" class="headerlink" title="3、探针"></a>3、探针</h1><h2 id="3-1-探针概述"><a href="#3-1-探针概述" class="headerlink" title="3.1 探针概述"></a>3.1 探针概述</h2><p>探针是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的 Handler。有三种类型的处理程序：</p><ul><li><code>ExecAction</code>：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功</li><li><code>TCPSocketAction</code>：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的</li><li><code>HTTPGetAction</code>：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的</li></ul><p>每次探测都将获得以下三种结果之一：</p><ul><li>成功：容器通过了诊断。</li><li>失败：容器未通过诊断。</li><li>未知：诊断失败，因此不会采取任何行动</li></ul><h2 id="3-2-探针分类"><a href="#3-2-探针分类" class="headerlink" title="3.2 探针分类"></a>3.2 探针分类</h2><ul><li><code>startupProbe</code>：启动探测，用于检测容器是否已启动</li><li><code>livenessProbe</code>：存活探测，用于检测容器是否还存活</li><li><code>readinessProbe</code>：就绪探测，检查容器是否已就绪，可以对外提供服务了。</li></ul><h1 id="4、readinessProbe-就绪探针"><a href="#4、readinessProbe-就绪探针" class="headerlink" title="4、readinessProbe 就绪探针"></a>4、readinessProbe 就绪探针</h1><p>介绍：k8s 通过添加就绪探针，解决尤其是在扩容时保证提供给用户的服务都是可用的。</p><h2 id="4-1-选项说明"><a href="#4-1-选项说明" class="headerlink" title="4.1 选项说明"></a>4.1 选项说明</h2><ul><li><code>initialDelaySeconds</code>：容器启动后要等待多少秒后就探针开始工作，单位“秒”，默认是 0 秒，最小值是 0</li><li><code>periodSeconds</code>：执行探测的时间间隔（单位是秒），默认为 10s，单位“秒”，最小值是 1</li><li><code>timeoutSeconds</code>：探针执行检测请求后，等待响应的超时时间，默认为 1s，单位“秒”，最小值是 1</li><li><code>successThreshold</code>：探针检测失败后认为成功的最小连接成功次数，默认值为 1。必须为 1 才能激活和启动。最小值为1</li><li><code>failureThreshold</code>：探测失败的重试次数，重试一定次数后将认为失败，默认值为 3 ，最小值为 1。</li></ul><h2 id="4-2-案例：基于HTTP-Get-方式"><a href="#4-2-案例：基于HTTP-Get-方式" class="headerlink" title="4.2 案例：基于HTTP Get 方式"></a>4.2 案例：基于HTTP Get 方式</h2><p><code>002-readiness-http.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">readiness-httpget-pod</span> <span class="comment"># pod 名</span>  <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># 名称空间</span>  <span class="attr">labels:</span> <span class="comment"># 定义多个标签</span>    <span class="attr">app:</span> <span class="string">myapp</span>    <span class="attr">env:</span> <span class="string">test</span><span class="attr">spec:</span>  <span class="attr">containers:</span> <span class="comment"># 定义主容器</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">readiness-httpget-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 镜像拉取策略，如果存在则不拉取</span>      <span class="attr">readinessProbe:</span> <span class="comment"># 定义就绪探测</span>        <span class="attr">httpGet:</span> <span class="comment"># http请求</span>          <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 请求端口</span>          <span class="attr">path:</span> <span class="string">/index1.html</span> <span class="comment"># 访问资源地址</span>        <span class="attr">initialDelaySeconds:</span> <span class="number">1</span> <span class="comment"># 容器启动后要等待多少秒后就探针开始工作，单位“秒”，默认是 0 秒，最小值是 0</span>        <span class="attr">periodSeconds:</span> <span class="number">30</span> <span class="comment"># 执行探测的时间间隔（单位是秒），默认为 10s，单位“秒”，最小值是 1</span>        <span class="attr">timeoutSeconds:</span> <span class="number">1</span> <span class="comment"># 探针执行检测请求后，等待响应的超时时间，默认为 1s，单位“秒”，最小值是 1</span>        <span class="attr">successThreshold:</span> <span class="number">1</span> <span class="comment"># 探针检测失败后认为成功的最小连接成功次数，默认值为 1。必须为 1 才能激活和启动。最小值为1</span>        <span class="attr">failureThreshold:</span> <span class="number">10</span> <span class="comment"># 探测失败的重试次数，重试一定次数后将认为失败，默认值为 3 ，最小值为 1</span></code></pre><p><strong>创建Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span>kubectl apply -f /opt/k8s/04/002-readiness-http.yaml<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看Pod运行情况</span>[root@k8s-master01 /opt/k8s/04]$ kubectl get podsNAME                    READY   STATUS    RESTARTS   AGEreadiness-httpget-pod   0/1     Running   0          8s</code></pre><p>Pod已启动，但是未就绪，下面查看日志，直到Pod未就绪的原因</p><p><strong>查看Pod日志</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">查看Pod日志</span>kubectl logs -f readiness-httpget-pod<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">日志内容如下</span>192.168.142.202 - - [22/Mar/2025:23:59:58 +0800] &quot;GET /index1.html HTTP/1.1&quot; 404 153 &quot;-&quot; &quot;kube-probe/1.29&quot;2025/03/22 23:59:58 [error] 7#7: *1 open() &quot;/usr/local/nginx/html/index1.html&quot; failed (2: No such file or directory), client: 192.168.142.202, server: localhost, request: &quot;GET /index1.html HTTP/1.1&quot;, host: &quot;192.168.58.196:80&quot;</code></pre><p>可以发现Pod在做就绪检测，访问 <a href="http://192.168.58.196/index1.html">http://192.168.58.196:80/index1.html</a> 结果404，就绪检测未通过，因此Pod处于未就绪状态。</p><p><strong>进入Pod内容，创建资源文件，让Pod就绪检测通过</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">进入Pod容器内部</span>[root@k8s-master01 /opt/k8s/04]$ kubectl exec -it readiness-httpget-pod /bin/bash<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">创建资源文件</span>readiness-httpget-pod:/# cd /usr/local/nginx/html/readiness-httpget-pod:/usr/local/nginx/html# ls50x.html       hostname.html  index.htmlreadiness-httpget-pod:/usr/local/nginx/html# cp index.html index1.html readiness-httpget-pod:/usr/local/nginx/html# exitexit<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">再次查看Pod运行状态，Pod已处于就绪状态</span>[root@k8s-master01 /opt/k8s/04]$ kubectl get podsNAME                    READY   STATUS    RESTARTS   AGEreadiness-httpget-pod   1/1     Running   0          95s</code></pre><h2 id="4-3-案例：基于EXEC方式"><a href="#4-3-案例：基于EXEC方式" class="headerlink" title="4.3 案例：基于EXEC方式"></a>4.3 案例：基于EXEC方式</h2><p>就绪检测在容器从启动到关闭的整个周期内都是有效的，例如容器刚启动时，就绪检测通过了，</p><p><code>003-readiness-exec.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">readiness-exec-pod</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">myapp</span>    <span class="attr">env:</span> <span class="string">test</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">readiness-exec-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 镜像拉取策略，如果存在则不拉取</span>      <span class="comment"># 主容器启动成功后自动创建目录 /tmp/live, 60秒后删除该目录，</span>      <span class="attr">command:</span> [<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;touch /tmp/live; sleep 60; rm -rf /tmp/live; sleep 3600&#x27;</span>]      <span class="attr">readinessProbe:</span>        <span class="attr">exec:</span>          <span class="attr">command:</span>            <span class="bullet">-</span> <span class="string">&#x27;test&#x27;</span>            <span class="bullet">-</span> <span class="string">&#x27;-e&#x27;</span>            <span class="bullet">-</span> <span class="string">&#x27;/tmp/live&#x27;</span>        <span class="attr">initialDelaySeconds:</span> <span class="number">2</span> <span class="comment"># 容器启动后要等待多少秒后就探针开始工作，单位“秒”，默认是 0 秒，最小值是 0</span>        <span class="attr">periodSeconds:</span> <span class="number">3</span> <span class="comment"># 执行探测的时间间隔（单位是秒），默认为 10s，单位“秒”，最小值是 1</span></code></pre><p><strong>启动Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动Pod</span>kubectl apply -f 003-readiness-exec.yaml <span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看Pod运行状态</span>[root@k8s-master01 /opt/k8s/04]$ kubectl get podsNAME                 READY   STATUS    RESTARTS   AGEreadiness-exec-pod   1/1     Running   0          5s</code></pre><p>由于主容器 <code>readiness-exec-container</code> 在启动成功后创建目录 <code>/tmp/live</code> ，因此 exec 就绪检测在容器刚启动时会通过。但在容器启动60秒后会删除目录 <code>/tmp/live</code>，由于就绪检测会持续不断的进行，因此此时就绪检测会失败。</p><p><strong>再次查看Pod运行状态</strong></p><pre><code class="highlight shell">[root@k8s-master01 /opt/k8s/04]$ kubectl get podsNAME                 READY   STATUS    RESTARTS   AGEreadiness-exec-pod   0/1     Running   0          15m</code></pre><p>Pod此时处于未就绪状态</p><h2 id="4-4-案例：基于-TCP-Check-方式"><a href="#4-4-案例：基于-TCP-Check-方式" class="headerlink" title="4.4 案例：基于 TCP Check 方式"></a>4.4 案例：基于 TCP Check 方式</h2><p><code>004-readiness-tcp.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">name:</span> <span class="string">readiness-tcp-pod</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">readiness-exec-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>      <span class="attr">readinessProbe:</span> <span class="comment"># 定义就绪检测</span>        <span class="attr">initialDelaySeconds:</span> <span class="number">3</span>        <span class="attr">timeoutSeconds:</span> <span class="number">1</span>        <span class="attr">tcpSocket:</span> <span class="comment"># 探测 tcp 端口</span>          <span class="attr">port:</span> <span class="number">80</span></code></pre><p><strong>启动Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动Pod</span>kubectl apply -f 004-readiness-tcp.yaml <span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看Pod运行状态</span>[root@k8s-master01 /opt/k8s/04]$ kubectl get podsNAME                READY   STATUS    RESTARTS   AGEreadiness-tcp-pod   1/1     Running   0          10s</code></pre><h1 id="5、livenessProbe-存活探针"><a href="#5、livenessProbe-存活探针" class="headerlink" title="5、livenessProbe 存活探针"></a>5、livenessProbe 存活探针</h1><p>介绍：k8s 通过添加存活探针，解决虽然活着但是已经死了的问题。</p><h2 id="5-1-选项说明："><a href="#5-1-选项说明：" class="headerlink" title="5.1 选项说明："></a>5.1 选项说明：</h2><ul><li><code>initialDelaySeconds</code>：容器启动后要等待多少秒后就探针开始工作，单位“秒”，默认是 0 秒，最小值是 0</li><li><code>periodSeconds</code>：执行探测的时间间隔（单位是秒），默认为 10s，单位“秒”，最小值是 1</li><li><code>timeoutSeconds</code>：探针执行检测请求后，等待响应的超时时间，默认为 1s，单位“秒”，最小值是 1</li><li><code>successThreshold</code>：探针检测失败后认为成功的最小连接成功次数，默认值为 1。必须为 1 才能激活和启动。最小值为1</li><li><code>failureThreshold</code>：探测失败的重试次数，重试一定次数后将认为失败，默认值为 3 ，最小值为 1。</li></ul><h2 id="5-2-案例：基于-HTTP-Get-方式"><a href="#5-2-案例：基于-HTTP-Get-方式" class="headerlink" title="5.2 案例：基于 HTTP Get 方式"></a>5.2 案例：基于 HTTP Get 方式</h2><p><code>005-liveness-httpget.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">liveness-httpget-pod</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">myapp</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-httpget-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>      <span class="attr">ports:</span>        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 指定容器暴露的端口，这里是 80 端口（通常用于 HTTP 服务）</span>          <span class="attr">name:</span> <span class="string">http</span> <span class="comment"># 为这个端口命名，方便引用（例如在 Service 中）。</span>      <span class="attr">livenessProbe:</span> <span class="comment"># 定义存活探针（Liveness Probe），用于检查容器是否健康。如果探针失败，Kubernetes 会重启容器。</span>        <span class="attr">initialDelaySeconds:</span> <span class="number">2</span> <span class="comment"># 容器启动后，探针延迟 2 秒开始首次检查。这给应用留出启动时间。</span>        <span class="attr">periodSeconds:</span> <span class="number">3</span> <span class="comment"># 探针检查的频率，每 3 秒执行一次。</span>        <span class="attr">successThreshold:</span> <span class="number">1</span> <span class="comment"># 探针成功的次数阈值，设置为 1 表示一次成功即认为容器健康。</span>        <span class="attr">failureThreshold:</span> <span class="number">3</span> <span class="comment"># 探针失败的次数阈值，设置为 3 表示连续 3 次失败后，Kubernetes 会重启容器。</span>        <span class="attr">httpGet:</span> <span class="comment"># 定义探针类型为 HTTP GET 请求。</span>          <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 请求的目标端口，这里是容器的 80 端口。</span>          <span class="attr">path:</span> <span class="string">/index1.html</span> <span class="comment"># 请求的路径，探针会访问 http://&lt;容器IP&gt;:80/index1.html。如果返回状态码 200-399，则认为容器健康。</span></code></pre><p><strong>启动Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动Pod</span>kubectl apply -f 005-liveness-httpget.yaml<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看Pod运行状态</span>[root@k8s-master01 /opt/k8s/04]$ kubectl get pods -o wide -wNAME                   READY   STATUS    RESTARTS      AGE    IP               NODE         NOMINATED NODE   READINESS GATESliveness-httpget-pod   1/1     Running   5 (65s ago)   100s   192.168.85.198   k8s-node01   &lt;none&gt;           &lt;none&gt;liveness-httpget-pod   0/1     CrashLoopBackOff   5 (23s ago)   109s   192.168.85.198   k8s-node01   &lt;none&gt;           &lt;none&gt;liveness-httpget-pod   1/1     Running            6 (113s ago)   3m19s   192.168.85.198   k8s-node01   &lt;none&gt;           &lt;none&gt;liveness-httpget-pod   0/1     CrashLoopBackOff   6 (23s ago)    3m28s   192.168.85.198   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>Pod由最开始的 Running 状态，然后容器启动2秒后存活探针开始工作，检测 http:&#x2F;&#x2F;&lt;容器IP&gt;:80&#x2F;index1.html 资源不存在，于是间隔 periodSeconds 时长再次检测，连续失败 failureThreshold 次，容器重启。循环这个操作。</p><h2 id="5-3-案例：基于-Exec-方式"><a href="#5-3-案例：基于-Exec-方式" class="headerlink" title="5.3 案例：基于 Exec 方式"></a>5.3 案例：基于 Exec 方式</h2><p><code>006-liveness-exec.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">readiness-exec-pod</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">myapp</span>    <span class="attr">env:</span> <span class="string">test</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">readiness-exec-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 镜像拉取策略，如果存在则不拉取</span>      <span class="comment"># 主容器启动成功后自动创建目录 /tmp/live, 60秒后删除该目录，</span>      <span class="attr">command:</span> [<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;touch /tmp/live; sleep 30; rm -rf /tmp/live; sleep 3600&#x27;</span>]      <span class="attr">livenessProbe:</span>        <span class="attr">exec:</span>          <span class="attr">command:</span>            <span class="bullet">-</span> <span class="string">&#x27;test&#x27;</span>            <span class="bullet">-</span> <span class="string">&#x27;-e&#x27;</span>            <span class="bullet">-</span> <span class="string">&#x27;/tmp/live&#x27;</span>        <span class="attr">initialDelaySeconds:</span> <span class="number">2</span>        <span class="attr">periodSeconds:</span> <span class="number">3</span></code></pre><p><strong>启动Pod，查看运行状态</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动Pod</span>kubectl apply -f 006-liveness-exec.yaml<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">监控Pod运行状态</span>[root@k8s-master01 /opt/k8s/04]$ kubectl get pods -o wide -wNAME                 READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATESreadiness-exec-pod   1/1     Running   0          12s   192.168.85.199   k8s-node01   &lt;none&gt;           &lt;none&gt;readiness-exec-pod   1/1     Running   1 (23s ago)   71s   192.168.85.199   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>Pod刚启动时，会自动创建目录 <code>/tmp/live</code>, <code>initialDelaySeconds</code> 秒后开始存活探测，此时Pod的存活探测是通过的。30秒后容器把目录  <code>/tmp/live</code> 删掉了，由于存活探测是持续轮询执行的，这时的存活探测就是失败的，当连续3次（默认failureThreshold是3）的探测失败后，容器会重启。</p><h2 id="5-4-案例：基于-TCP-Check-方式"><a href="#5-4-案例：基于-TCP-Check-方式" class="headerlink" title="5.4 案例：基于 TCP Check 方式"></a>5.4 案例：基于 TCP Check 方式</h2><p><code>007-liveness-tcp.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">name:</span> <span class="string">readiness-tcp-pod</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">readiness-exec-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>      <span class="attr">ports:</span>        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>          <span class="attr">name:</span> <span class="string">http</span>      <span class="attr">livenessProbe:</span>        <span class="attr">initialDelaySeconds:</span> <span class="number">2</span>        <span class="attr">timeoutSeconds:</span> <span class="number">1</span>        <span class="attr">tcpSocket:</span>          <span class="attr">port:</span> <span class="number">80</span></code></pre><p><strong>启动Pod，查看状态</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动Pod</span>kubectl apply -f 007-liveness-tcp.yaml <span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看Pod的运行状态</span>[root@k8s-master01 /opt/k8s/04]$ kubectl get pods -o wide -wNAME                READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATESreadiness-tcp-pod   1/1     Running   0          14s   192.168.85.200   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><h1 id="6、startupProbe-启动探针"><a href="#6、startupProbe-启动探针" class="headerlink" title="6、startupProbe 启动探针"></a>6、startupProbe 启动探针</h1><p>介绍：k8s 在 1.16 版本后增加 startupProbe 探针，主要解决在复杂的程序中 readinessProbe、livenessProbe 探针无法更好的判断程序是否启动、是否存活。</p><h2 id="6-1-选项说明"><a href="#6-1-选项说明" class="headerlink" title="6.1 选项说明"></a>6.1 选项说明</h2><ul><li>initialDelaySeconds：容器启动后要等待多少秒后就探针开始工作，单位“秒”，默认是 0 秒，最小值是 0</li><li>periodSeconds：执行探测的时间间隔（单位是秒），默认为 10s，单位“秒”，最小值是 1</li><li>timeoutSeconds：探针执行检测请求后，等待响应的超时时间，默认为 1s，单位“秒”，最小值是 1</li><li>successThreshold：探针检测失败后认为成功的最小连接成功次数，默认值为 1。必须为 1 才能激活和启动。最小值为1</li><li>failureThreshold：探测失败的重试次数，重试一定次数后将认为失败，默认值为 3 ，最小值为 1。</li></ul><h2 id="6-2-案例：基于-HTTP-Get-方式"><a href="#6-2-案例：基于-HTTP-Get-方式" class="headerlink" title="6.2 案例：基于 HTTP Get 方式"></a>6.2 案例：基于 HTTP Get 方式</h2><p><code>008-startup-probe.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">startup-probe-pod</span>  <span class="attr">namespace:</span> <span class="string">default</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">startup-probe-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>      <span class="attr">ports:</span>        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>          <span class="attr">name:</span> <span class="string">http</span>      <span class="attr">startupProbe:</span> <span class="comment"># 定义启动探针</span>        <span class="attr">initialDelaySeconds:</span> <span class="number">0</span>        <span class="attr">successThreshold:</span> <span class="number">1</span>        <span class="attr">failureThreshold:</span> <span class="number">30</span>        <span class="attr">periodSeconds:</span> <span class="number">10</span>        <span class="attr">httpGet:</span>          <span class="attr">port:</span> <span class="number">80</span>          <span class="attr">path:</span> <span class="string">/index1.html</span></code></pre><p><strong>启动Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动Pod</span>kubectl apply -f 008-startup-probe.yaml<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">监控Pod运行状态</span>[root@k8s-master01 ~]$ kubectl get pods -o wide -wNAME                READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATESstartup-probe-pod   0/1     Running   0          97s   192.168.85.201   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>由于容器内没有 index1.html 资源，启动探测失败，因此Pod处于未就绪状态。</p><p><strong>进入容器，创建 index1.html</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span>[root@k8s-master01 /opt/k8s/04]$ kubectl exec -it startup-probe-pod /bin/bashstartup-probe-pod:/# cd /usr/local/nginx/html/startup-probe-pod:/usr/local/nginx/html# ls50x.html       hostname.html  index.html<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">创建 index1.html</span>startup-probe-pod:/usr/local/nginx/html# cp index.html index1.html</code></pre><p><strong>再次查看Pod运行状态</strong></p><pre><code class="highlight shell">[root@k8s-master01 ~]$ kubectl get pods -o wide -wNAME                READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATESstartup-probe-pod   0/1     Running   0          97s   192.168.85.201   k8s-node01   &lt;none&gt;           &lt;none&gt;startup-probe-pod   1/1     Running   0          111s   192.168.85.201   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>此时Pod变成已就绪状态。由于 <code>008-startup-probe.yaml</code> 文件中没有定义就绪检测，因此启动探测成功后，默认就绪检测成功。</p><p><strong>注意：应用程序将会有最多 5 分钟 failureThreshold * periodSeconds（30 * 10 &#x3D; 300s）的时间来完成其启动过程。</strong></p><h2 id="6-3-案例：基于EXEC方式"><a href="#6-3-案例：基于EXEC方式" class="headerlink" title="6.3 案例：基于EXEC方式"></a>6.3 案例：基于EXEC方式</h2><p><code>009-startup-exec.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">startup-exec-pod</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">myapp</span>    <span class="attr">env:</span> <span class="string">test</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">startup-exec-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 镜像拉取策略，如果存在则不拉取</span>      <span class="comment"># 主容器启动成功后自动创建目录 /tmp/live, 3秒后删除该目录，</span>      <span class="attr">command:</span> [<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;touch /tmp/live; sleep 3; rm -rf /tmp/live; sleep 3600&#x27;</span>]      <span class="attr">startupProbe:</span>        <span class="attr">exec:</span>          <span class="attr">command:</span>            <span class="bullet">-</span> <span class="string">&#x27;test&#x27;</span>            <span class="bullet">-</span> <span class="string">&#x27;-e&#x27;</span>            <span class="bullet">-</span> <span class="string">&#x27;/tmp/live&#x27;</span>        <span class="attr">initialDelaySeconds:</span> <span class="number">4</span> <span class="comment"># 延迟4秒后启动探测，此时 /tmp/live 文件夹已被删除</span>        <span class="attr">periodSeconds:</span> <span class="number">3</span></code></pre><p><strong>启动Pod，查看状态</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动Pod</span>kubectl apply -f 009-startup-exec.yaml<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看Pod运行状态</span>[root@k8s-master01 ~]$ kubectl get pods -o wide -wNAME               READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATESstartup-exec-pod   0/1     Running   0          6s    192.168.85.203   k8s-node01   &lt;none&gt;           &lt;none&gt;startup-exec-pod   0/1     Running   1 (22s ago)   43s   192.168.85.203   k8s-node01   &lt;none&gt;           &lt;none&gt;</code></pre><p>启动探测失败，Pod未就绪。</p><h1 id="7、钩子"><a href="#7、钩子" class="headerlink" title="7、钩子"></a>7、钩子</h1><h2 id="7-1-钩子概述"><a href="#7-1-钩子概述" class="headerlink" title="7.1 钩子概述"></a>7.1 钩子概述</h2><p>Pod hook（钩子）是由 Kubernetes 管理的 kubelet 发起的，当容器中的**进程启动前(其实是启动后，对应：postStart)<strong>或者容器中的</strong>进程终止之前(对应：preStop)*<em>运行，这是包含在容器的生命周期之中。</em>可以同时为 Pod 中的所有容器都配置 hook*</p><p>Hook 的类型包括两种：</p><ul><li><code>exec</code>：执行一段命令</li><li><code>HTTP</code>：发送 HTTP 请求</li></ul><h2 id="7-2-案例：基于-Exec-方式"><a href="#7-2-案例：基于-Exec-方式" class="headerlink" title="7.2 案例：基于 Exec 方式"></a>7.2 案例：基于 Exec 方式</h2><p><code>010-hook-exec.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">lifecycle-exec-pod</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">myapp</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-exec-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1</span>      <span class="attr">lifecycle:</span>        <span class="attr">postStart:</span> <span class="comment"># 启动后钩子</span>          <span class="attr">exec:</span>            <span class="attr">command:</span>              <span class="bullet">-</span> <span class="string">&#x27;/bin/sh&#x27;</span>              <span class="bullet">-</span> <span class="string">&#x27;-c&#x27;</span>              <span class="bullet">-</span> <span class="string">&#x27;echo postStart &gt; /usr/share/message&#x27;</span>        <span class="attr">preStop:</span> <span class="comment"># 关闭前钩子</span>          <span class="attr">exec:</span>            <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo preStop &gt; /usr/share/message&quot;</span>]</code></pre><p><strong>启动Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动Pod</span>kubectl apply -f 010-hook-exec.yaml<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看Pod运行情况</span>[root@k8s-master01 /opt/k8s/04]$ kubectl get pods -o wide -wNAME                 READY   STATUS              RESTARTS   AGE   IP       NODE         NOMINATED NODE   READINESS GATESlifecycle-exec-pod   0/1     ContainerCreating   0          4s    &lt;none&gt;   k8s-node02   &lt;none&gt;           &lt;none&gt;lifecycle-exec-pod   0/1     ContainerCreating   0          9s    &lt;none&gt;   k8s-node02   &lt;none&gt;           &lt;none&gt;lifecycle-exec-pod   1/1     Running             0          16s   172.16.58.195   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre><p>Pod已成功启动，并就绪</p><p><strong>测试启动后钩子是否生效</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">进入Pod</span>kubectl exec -it lifecycle-exec-pod /bin/bash<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">在容器内查看启动后钩子执行的脚本是否生效</span>lifecycle-exec-pod:/# cat /usr/share/messagepostStart</code></pre><p>可以发现 “postStart” 已被写入文件中</p><p><strong>测试关闭前钩子是否生效</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">1.进入Pod容器中</span>kubectl exec -it lifecycle-exec-pod /bin/bash<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">2.在容器内写一段脚本持续读取输出 /usr/share/message</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">脚本内容如下：</span><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">无限循环执行 <span class="built_in">cat</span> /usr/share/message</span>while true; do    cat /usr/share/messagedone<span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">3.给脚本授权（容器内操作）</span>chmod +x 123.sh<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">4.执行脚本（容器内操作）</span>sh 123.sh<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">5.新起一个shell终端，执行关闭Pod操作</span>kubectl delete -f 010-hook-exec.yaml<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">6.查看脚本打印内容</span>......preStoppreStoppreStop......</code></pre><p>可以看到关闭前钩子在容器被杀死前，执行了 <code>echo preStop &gt; /usr/share/message</code> </p><h2 id="7-3-案例：基于HTTP-Get请求"><a href="#7-3-案例：基于HTTP-Get请求" class="headerlink" title="7.3 案例：基于HTTP Get请求"></a>7.3 案例：基于HTTP Get请求</h2><p><strong>测试容器</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">开启一个测试 webServer</span><span class="meta prompt_">$ </span><span class="language-bash">docker run -itd --<span class="built_in">rm</span> -p 1234:80 --name=<span class="built_in">test</span> wangyanglinux/myapp:v1.0</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">监控测试容器的日志打印情况</span><span class="meta prompt_">$ </span><span class="language-bash">docker logs -f --<span class="built_in">tail</span> 1000 <span class="built_in">test</span></span></code></pre><p><code>011-hook-http.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">name:</span> <span class="string">lifecycle-http-pod</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">myApp</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-httpget-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>      <span class="attr">ports:</span>        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>      <span class="attr">lifecycle:</span>        <span class="attr">postStart:</span> <span class="comment"># 启动后钩子</span>          <span class="attr">httpGet:</span> <span class="comment"># 基于Http Get 请求方式</span>            <span class="attr">port:</span> <span class="number">1234</span> <span class="comment"># http 访问端口</span>            <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.139</span> <span class="comment"># http访问Host地址</span>            <span class="attr">path:</span> <span class="string">index.html</span> <span class="comment"># http访问资源路径</span>        <span class="attr">preStop:</span>          <span class="attr">httpGet:</span>            <span class="attr">port:</span> <span class="number">1234</span>            <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.139</span>            <span class="attr">path:</span> <span class="string">hostname.html</span></code></pre><p><strong>启动Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动Pod</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f 011-hook-http.yaml</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看测试容器的日志</span>[root@k8s-master01 /opt/k8s/04]$ docker logs -f --tail 1000 test192.168.6.141 - - [02/Apr/2025:10:26:16 +0800] &quot;GET /index.html HTTP/1.1&quot; 200 48 &quot;-&quot; &quot;kube-lifecycle/1.29&quot;</code></pre><p>pod启动成功，并执行了 postStart 定义的Http Get请求，访问了 <a href="http://192.168.6.139:1234/index.html">http://192.168.6.139:1234/index.html</a> </p><p><strong>停止Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">删除Pod</span><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete -f 011-hook-http.yaml</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看测试容器的日志</span>[root@k8s-master01 /opt/k8s/04]$ docker logs -f --tail 1000 test192.168.6.141 - - [02/Apr/2025:10:26:16 +0800] &quot;GET /index.html HTTP/1.1&quot; 200 48 &quot;-&quot; &quot;kube-lifecycle/1.29&quot;192.168.6.141 - - [02/Apr/2025:10:28:44 +0800] &quot;GET /hostname.html HTTP/1.1&quot; 200 13 &quot;-&quot; &quot;kube-lifecycle/1.29&quot;</code></pre><p>Pod在关闭前，执行了 preStop 定义的Http Get 请求，访问了 <a href="http://192.168.6.139:1234/hostname.html">http://192.168.6.139:1234/hostname.html</a> </p><h2 id="7-4-关于-preStop-的延伸"><a href="#7-4-关于-preStop-的延伸" class="headerlink" title="7.4 关于 preStop 的延伸"></a>7.4 关于 preStop 的延伸</h2><p>在 k8s 中，理想的状态是 pod 优雅释放，但是并不是每一个 Pod 都会这么顺利</p><ul><li>Pod 卡死，处理不了优雅退出的命令或者操作</li><li>优雅退出的逻辑有 BUG，陷入死循环</li><li>代码问题，导致执行的命令没有效果</li></ul><p>对于以上问题，k8s 的 Pod 终止流程中还有一个 “最多可以容忍的时间”，即 grace period ( 在 <code>pod.spec.terminationGracePeriodSeconds</code> 字段定义)，这个值默认是 30 秒，当我们执行 <code>kubectl delete</code>  的时候也可以通过 <code>--grace-period</code> 参数显示指定一个优雅退出时间来覆盖 Pod 中的配置，如果我们配置的 grace period 超过时间之后，k8s 就只能选择强制 kill Pod。值得注意的是，这与preStop Hook和 SIGTERM 信号并行发生。k8s 不会等待 preStop Hook 完成。如果你的应用程序完成关闭并在terminationGracePeriod 完成之前退出，k8s  会立即进入下一步</p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">name:</span> <span class="string">lifecycle-http-pod</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">myApp</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-httpget-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>      <span class="attr">ports:</span>        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>      <span class="attr">lifecycle:</span>        <span class="attr">postStart:</span> <span class="comment"># 启动后钩子</span>          <span class="attr">httpGet:</span> <span class="comment"># 基于Http Get 请求方式</span>            <span class="attr">port:</span> <span class="number">1234</span> <span class="comment"># http 访问端口</span>            <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.139</span> <span class="comment"># http访问Host地址</span>            <span class="attr">path:</span> <span class="string">index.html</span> <span class="comment"># http访问资源路径</span>        <span class="attr">preStop:</span>          <span class="attr">httpGet:</span>            <span class="attr">port:</span> <span class="number">1234</span>            <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.139</span>            <span class="attr">path:</span> <span class="string">hostname.html</span>  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span> <span class="comment"># 如果执行 kubectl delete 不能顺利将pod关闭，最长30秒强制杀死pod</span></code></pre><h1 id="8、Pod生命周期完整演示"><a href="#8、Pod生命周期完整演示" class="headerlink" title="8、Pod生命周期完整演示"></a>8、Pod生命周期完整演示</h1><p><code>012-lifecycle-all.yaml</code></p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span><span class="attr">kind:</span> <span class="string">Pod</span><span class="attr">metadata:</span>  <span class="attr">name:</span> <span class="string">lifecycle-pod</span>  <span class="attr">namespace:</span> <span class="string">default</span>  <span class="attr">labels:</span>    <span class="attr">app:</span> <span class="string">myapp</span><span class="attr">spec:</span>  <span class="attr">containers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span> <span class="comment"># 主容器1</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/tools:busybox</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tmp/live ; sleep 600; rm -rf /tmp/live; sleep 3600&quot;</span>]      <span class="attr">livenessProbe:</span> <span class="comment"># 主容器1存活探针</span>        <span class="attr">exec:</span> <span class="comment"># 基于 exec执行命令，探测主容器内文件是否存在</span>          <span class="attr">command:</span> [<span class="string">&quot;test&quot;</span>,<span class="string">&quot;-e&quot;</span>,<span class="string">&quot;/tmp/live&quot;</span>]        <span class="attr">initialDelaySeconds:</span> <span class="number">1</span> <span class="comment"># 容器启动1秒后探测</span>        <span class="attr">periodSeconds:</span> <span class="number">3</span> <span class="comment"># 循环3秒</span>      <span class="attr">lifecycle:</span>        <span class="attr">postStart:</span>          <span class="attr">httpGet:</span>            <span class="attr">port:</span> <span class="number">1234</span>            <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.139</span>            <span class="attr">path:</span> <span class="string">index.html</span>        <span class="attr">preStop:</span>          <span class="attr">httpGet:</span>            <span class="attr">port:</span> <span class="number">1234</span>            <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.139</span>            <span class="attr">path:</span> <span class="string">hostname.html</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>      <span class="attr">livenessProbe:</span>        <span class="attr">httpGet:</span>          <span class="attr">port:</span> <span class="number">80</span>          <span class="attr">path:</span> <span class="string">/index.html</span>        <span class="attr">initialDelaySeconds:</span> <span class="number">1</span>        <span class="attr">periodSeconds:</span> <span class="number">3</span>        <span class="attr">timeoutSeconds:</span> <span class="number">3</span> <span class="comment"># http Get 请求超时时间(秒)</span>      <span class="attr">readinessProbe:</span>        <span class="attr">httpGet:</span>          <span class="attr">port:</span> <span class="number">80</span>          <span class="attr">path:</span> <span class="string">/index1.html</span>        <span class="attr">initialDelaySeconds:</span> <span class="number">1</span>        <span class="attr">periodSeconds:</span> <span class="number">3</span>        <span class="attr">timeoutSeconds:</span> <span class="number">3</span>  <span class="attr">initContainers:</span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/tools:busybox</span>      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-mydb</span>      <span class="attr">image:</span> <span class="string">wangyanglinux/tools:busybox</span>      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;</span>]</code></pre><p><strong>启动Pod</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动Pod</span>kubectl apply -f 012-lifecycle-all.yaml <span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看Pod日志</span>kubectl logs -f --tail=100 lifecycle-pod<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看initC日志</span>kubectl logs -f --tail=100 lifecycle-pod -c init-myservicekubectl logs -f --tail=100 lifecycle-pod -c init-mydb<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">创建initC需要的service</span>kubectl create svc clusterip myservice --tcp=80:80kubectl logs -f --tail=100 lifecycle-pod -c init-myservicekubectl logs -f --tail=100 lifecycle-pod -c init-mydbkubectl create svc clusterip mydb --tcp=80:80<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">进入主容器</span>kubectl exec -it lifecycle-pod -c myapp-container /bin/bash<span class="meta prompt_"># </span><span class="language-bash">创建主容器就绪检测所需资源</span>cd /usr/local/nginx/html/cp index.html index1.html</code></pre><p>完成以上操作后，此Pod才能真正完整运行起来。</p><p><strong>Pod运行监控</strong></p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -o wide -w</span>NAME            READY   STATUS     RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATESlifecycle-pod   0/2     Init:0/2   0          43s   172.16.58.197   k8s-node02   &lt;none&gt;           &lt;none&gt;lifecycle-pod   0/2     Init:1/2   0          3m21s   172.16.58.197   k8s-node02   &lt;none&gt;           &lt;none&gt;lifecycle-pod   0/2     Init:1/2   0          3m26s   172.16.58.197   k8s-node02   &lt;none&gt;           &lt;none&gt;lifecycle-pod   0/2     PodInitializing   0          4m7s    172.16.58.197   k8s-node02   &lt;none&gt;           &lt;none&gt;lifecycle-pod   1/2     Running           0          4m17s   172.16.58.197   k8s-node02   &lt;none&gt;           &lt;none&gt;lifecycle-pod   2/2     Running           0          5m45s   172.16.58.197   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RockyLinux：9.3&lt;/p&gt;
&lt;p&gt;K8s版本：1.29&lt;/p&gt;
&lt;p&gt;Docker版本：27.4.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1、Pod生命周期概述&quot;&gt;</summary>
      
    
    
    
    <category term="k8s" scheme="https://georgechan95.github.io/categories/k8s/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="Docker" scheme="https://georgechan95.github.io/tags/Docker/"/>
    
    <category term="Rocky" scheme="https://georgechan95.github.io/tags/Rocky/"/>
    
  </entry>
  
  <entry>
    <title>Docker配置网络代理实现外网镜像下载</title>
    <link href="https://georgechan95.github.io/blog/b01d5c62.html"/>
    <id>https://georgechan95.github.io/blog/b01d5c62.html</id>
    <published>2025-01-08T15:00:00.000Z</published>
    <updated>2025-01-08T05:48:23.767Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>系统：Rocky Linux 9.3</p><p>Docker：27.4.1</p><p>服务器已配置代理，并且可访问外网，具体操作见：<a href="https://georgechan95.github.io/blog/7f174b3e.html">Rocky9安装Shadowsocks实现科学上网</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h1><ul><li>部分镜像在国外，国内无法下载</li><li>容器在运行时需要从国外网站下载依赖</li><li>构建自定义镜像时需要访问国外网络</li></ul><h1 id="配置-Dockerd-代理"><a href="#配置-Dockerd-代理" class="headerlink" title="配置 Dockerd 代理"></a>配置 Dockerd 代理</h1><h2 id="新建-docker-代理配置文件"><a href="#新建-docker-代理配置文件" class="headerlink" title="新建 docker 代理配置文件"></a>新建 docker 代理配置文件</h2><p>在执行 docker pull 时，是由守护进程 dockerd 来执行。因此，代理需要配在 dockerd 的环境中。而这个环境，则是受 systemd 所管控，因此实际是 systemd 的配置。</p><pre><code class="highlight shell">sudo mkdir -p /etc/systemd/system/docker.service.dsudo touch /etc/systemd/system/docker.service.d/proxy.conf</code></pre><p>在这个 proxy.conf 文件（可以是任意 *.conf 的形式）中，添加以下内容：</p><pre><code class="highlight shell">[Service]Environment=&quot;HTTP_PROXY=http://127.0.0.1:8118/&quot;Environment=&quot;HTTPS_PROXY=http://127.0.0.1:8118/&quot;Environment=&quot;NO_PROXY=localhost,127.0.0.1&quot;</code></pre><ul><li><p>配置解析</p><p>由于Docker所在服务器已配置代理，可以科学上网，所以代理服务器IP为：127.0.0.1，指代本机。</p><p>服务器配置代理使用的是 Privoxy，默认代理端口：8118</p></li></ul><h2 id="配置生效"><a href="#配置生效" class="headerlink" title="配置生效"></a>配置生效</h2><p>重启docker以及守护进程</p><pre><code class="highlight sheLl">sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h2 id="测试镜像拉取"><a href="#测试镜像拉取" class="headerlink" title="测试镜像拉取"></a>测试镜像拉取</h2><p>下载一个国内无法拉取的谷歌镜像，如果成功则表明代理生效。</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">拉取谷歌镜像</span>root@shadowsockts:~# docker pull k8s.gcr.io/kube-proxy:v1.17.17<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看镜像</span>root@shadowsockts:~# docker imagesREPOSITORY              TAG        IMAGE ID       CREATED         SIZEcalico/typha            v3.26.3    5993c7d25ac5   15 months ago   67.4MBk8s.gcr.io/kube-proxy   v1.17.17   3ef67d180564   3 years ago     117MB</code></pre><h1 id="Container-代理"><a href="#Container-代理" class="headerlink" title="Container 代理"></a>Container 代理</h1><p>在容器运行阶段，如果需要代理上网，则需要配置 ~&#x2F;.docker&#x2F;config.json 。以下配置，只在Docker 17.07及以上版本生效。</p><h2 id="修改防火墙配置"><a href="#修改防火墙配置" class="headerlink" title="修改防火墙配置"></a>修改防火墙配置</h2><blockquote><p>方式一：临时关闭防火墙</p><p>禁用 firewalld 和临时关闭 iptables，否则容器无法进行网络代理，防火墙会拦截代理请求</p><pre><code class="highlight shell">systemctl stop firewalld &amp; systemctl disable firewalldsystemctl stop iptables</code></pre></blockquote><blockquote><p>方式二：添加 iptables 规则，允许代理端口通过</p><pre><code class="highlight shell">iptables -I INPUT -p tcp --dport 8118 -j ACCEPTiptables -I FORWARD -p tcp --dport 8118 -j ACCEPTiptables -I OUTPUT -p tcp --dport 8118 -j ACCEPT<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># 如果使用 iptables-services：</span></span>service iptables save<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">如果使用 firewalld：</span>firewall-cmd --runtime-to-permanentfirewall-cmd --reload</code></pre><p>我这里防火墙使用的是 iptables， 如果使用 firewalld 规则配置则不同。</p></blockquote><h2 id="修改-Privoxy-配置文件"><a href="#修改-Privoxy-配置文件" class="headerlink" title="修改 Privoxy 配置文件"></a>修改 Privoxy 配置文件</h2><pre><code class="highlight shell">vim /etc/privoxy/config<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">添加监听IP，192.168.6.221 为Privoxy所在服务器真实IP</span>listen-address  192.168.6.221:8118</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/08/20250108-114726.png" alt="Privoxy 配置文件"></p><h2 id="重启-Privoxy"><a href="#重启-Privoxy" class="headerlink" title="重启 Privoxy"></a>重启 Privoxy</h2><pre><code class="highlight shell">systemctl restart privoxy</code></pre><h2 id="创建-Docker-配置文件"><a href="#创建-Docker-配置文件" class="headerlink" title="创建 Docker 配置文件"></a>创建 Docker 配置文件</h2><p>在 Docker 客户端上，在启动容器的用户的主目录中创建或编辑 ~&#x2F;.docker&#x2F;config.json 文件</p><pre><code class="highlight shell">mkdir ~/.dockervim ~/.docker/config.json<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">编辑内容如下：</span>&#123;    &quot;proxies&quot;:&#123;        &quot;default&quot;:&#123;            &quot;httpProxy&quot;:&quot;http://192.168.6.221:8118&quot;,            &quot;httpsProxy&quot;:&quot;https://192.168.6.221:8118&quot;,            &quot;noProxy&quot;:&quot;localhost&quot;        &#125;    &#125;&#125;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重启docker</span>sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><blockquote><p><strong>将上面 prioxy 服务所在IP 替换成代理服务器真实IP和端口</strong></p></blockquote><ul><li><p>配置解析</p><pre><code class="highlight plaintext">192.168.6.221 为网络代理服务器IP8118 是服务器代理端口。这个是用户级的配置，除了 proxies，docker login 等相关信息也会在其中。而且还可以配置信息展示的格式、插件参数等。此外，容器的网络代理，也可以直接在其运行时通过 -e 注入 http_proxy 等环境变量。这两种方法分别适合不同场景。config.json 非常方便，默认在所有配置修改后启动的容器生效，适合个人开发环境。在CI/CD的自动构建环境、或者实际上线运行的环境中，这种方法就不太合适，用 -e 注入这种显式配置会更好，减轻对构建、部署环境的依赖。当然，在这些环境中，最好用良好的设计避免配置代理上网。</code></pre></li></ul><h2 id="测试-Docker-Container-代理"><a href="#测试-Docker-Container-代理" class="headerlink" title="测试 Docker Container 代理"></a>测试 Docker Container 代理</h2><blockquote><p>创建一个容器，进入容器测试是否可以访问外网</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建容器</span>docker run -itd --name centos --restart always centos:7<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">进入容器</span>docker exec -it centos /bin/bash<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看容器内代理配置</span>[root@9d38f88f2411 /]# echo $http_proxyhttp://192.168.204.151:8118[root@9d38f88f2411 /]# echo $https_proxyhttp://192.168.204.151:8118<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">在容器内访问谷歌</span>curl https://www.google.com<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">容器内查看ip</span>[root@shadowsockts /]# curl cip.ccIP: 112.169.175.22地址: 韩国  韩国数据二: 韩国 | KT电信数据三: 韩国 | 韩国电信URL: http://www.cip.cc/112.169.175.22</code></pre></blockquote><h2 id="配置Container代理方式二"><a href="#配置Container代理方式二" class="headerlink" title="配置Container代理方式二"></a>配置Container代理方式二</h2><p>启动容器时，作为环境变量添加进去, 仅对当前启动容器有效。 <strong>这种方式比较常用</strong></p><pre><code class="highlight shell">docker run -itd \    --name centos \    --restart always \    --env &quot;httpProxy:http://192.168.204.151:8118&quot; \    --env &quot;httpsProxy:https://192.168.204.151:8118&quot; \    --env &quot;noProxy:localhost&quot; \    centos:7</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><p><a href="https://kebingzao.com/2019/02/22/docker-container-proxy/">https://kebingzao.com/2019/02/22/docker-container-proxy/</a></p><p><a href="https://neucrack.com/p/286">https://neucrack.com/p/286</a></p><p><a href="https://hksanduo.github.io/2020/03/07/2020-03-07-docker-container-use-socks5-proxy/">https://hksanduo.github.io/2020/03/07/2020-03-07-docker-container-use-socks5-proxy/</a></p><h1 id="Docker-Build-代理"><a href="#Docker-Build-代理" class="headerlink" title="Docker Build 代理"></a>Docker Build 代理</h1><pre><code class="highlight shell">docker build . \    --build-arg &quot;HTTP_PROXY=http://192.168.204.151:8118&quot; \    --build-arg &quot;HTTPS_PROXY=https://192.168.204.151:8118&quot; \    --build-arg &quot;NO_PROXY=localhost,127.0.0.1,.example.com&quot; \    -t your/image:tag</code></pre><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a><strong>参考</strong></h2><p><a href="https://cloud.tencent.com/developer/article/1806455">https://cloud.tencent.com/developer/article/1806455</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统：Rocky Linux 9.3&lt;/p&gt;
&lt;p&gt;Docker：27.4.1&lt;/p&gt;
&lt;p&gt;服务器已配置代理，并且可访问外网，具体操作见：&lt;a href=&quot;https://georgech</summary>
      
    
    
    
    <category term="Docker" scheme="https://georgechan95.github.io/categories/Docker/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="Docker" scheme="https://georgechan95.github.io/tags/Docker/"/>
    
    <category term="科学上网" scheme="https://georgechan95.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Rocky9安装Shadowsocks实现科学上网</title>
    <link href="https://georgechan95.github.io/blog/7f174b3e.html"/>
    <id>https://georgechan95.github.io/blog/7f174b3e.html</id>
    <published>2025-01-08T13:09:00.000Z</published>
    <updated>2025-01-08T05:20:34.474Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>系统：Rocky Linux 9.3</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在一些软件的安装过程中，存在部分安装包和依赖在国外，又由于长城防火墙的拦截，导致下载非常缓慢，经常出现由于网络的原因导致安装失败的情况。为此可以借助一些科学上网的工具，使得服务器可以突破网络限制，实现流畅的访问外网，让服务器软件安装过程更加顺利。</p><p>我这里是通过安装 <code>Shadowsocks</code>，并设置可访问外网的服务器配置（需提前购买外网云服务，即：梯子，<a href="https://azabudai.org/auth/register?code=tGfK">注册链接:</a> <a href="https://azabudai.org/auth/register?code=tGfK">https://azabudai.org/auth/register?code=tGfK</a> 邀请码：<code>tGfK</code> ），再安装Privoxy，设置系统代理实现外网访问。</p><h1 id="安装-PIP"><a href="#安装-PIP" class="headerlink" title="安装 PIP"></a>安装 PIP</h1><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">更新系统软件包</span>dnf update -y<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装python</span>dnf install python39 -y<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看python安装版本</span>python3.9 --version<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装pip</span>dnf install python3.9-pip<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看pip3版本</span>pip3 --version<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">更新pip3安装版本</span>pip3 install --upgrade pip<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看pip3版本</span>pip3 --version<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看pip3帮助信息</span>pip3 --help</code></pre><h1 id="安装和配置-Shadowsocks"><a href="#安装和配置-Shadowsocks" class="headerlink" title="安装和配置 Shadowsocks"></a>安装和配置 Shadowsocks</h1><h2 id="使用-pip3-安装-Shadowsocks"><a href="#使用-pip3-安装-Shadowsocks" class="headerlink" title="使用 pip3 安装 Shadowsocks"></a>使用 pip3 安装 Shadowsocks</h2><pre><code class="highlight shell">sudo pip3 install -y shadowsocks</code></pre><h2 id="配置-shadowsocks"><a href="#配置-shadowsocks" class="headerlink" title="配置 shadowsocks"></a>配置 shadowsocks</h2><blockquote><p>新建配置文件夹和文件</p><pre><code class="highlight shell">sudo mkdir /etc/shadowsockssudo vim /etc/shadowsocks/shadowsocks.json</code></pre><ul><li><p>配置内容如下：</p><pre><code class="highlight json"><span class="punctuation">&#123;</span>    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;替换成自己的服务器ip或域名&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;local_address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span> <span class="number">1080</span><span class="punctuation">,</span>    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">300</span><span class="punctuation">,</span>    <span class="attr">&quot;workers&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span>    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span> <span class="number">31558</span><span class="punctuation">,</span>    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;替换成自己的服务器密码&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rc4-md5&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">&#125;</span></code></pre></li><li><p>配置解析</p><pre><code class="highlight shell">server：Shadowsocks 服务器地址server_port：Shadowsocks 服务器端口local_address：本地 Sock5 代理地址local_port：本地 Sock5 代理端口password：Shadowsocks 连接密码timeout：超时等待时间（秒）method：加密方式workers：工作线程数</code></pre></li></ul></blockquote><h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><p>创建启动脚本 <code>/etc/systemd/system/shadowsocks.service</code></p><p>这里请确认你的 sslocal 的所在位置，自行修改脚本文件中的 <code>/usr/local/bin/sslocal</code>，<strong>位置不对启动服务时会报 203 错误</strong></p><blockquote><p>确认 sslocal 所在路径</p><pre><code class="highlight shell">[root@localhost ~]# ls /usr/local/bin/sslocal/usr/local/bin/sslocal</code></pre></blockquote><blockquote><p>创建Shadowsocks启动脚本</p><pre><code class="highlight shell">sudo vim /etc/systemd/system/shadowsocks.service</code></pre><ul><li><p>内容如下：</p><pre><code class="highlight shell">[Unit]Description=Shadowsocks  [Service]TimeoutStartSec=0ExecStart=/usr/local/bin/sslocal -c /etc/shadowsocks/shadowsocks.json  [Install]WantedBy=multi-user.target</code></pre></li></ul></blockquote><blockquote><p>启动脚本授权</p><pre><code class="highlight shell">chmod 755 /usr/local/bin/sslocal</code></pre></blockquote><h2 id="shadowsocks-启动命令"><a href="#shadowsocks-启动命令" class="headerlink" title="shadowsocks 启动命令"></a>shadowsocks 启动命令</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">开机自启动</span>sudo systemctl enable shadowsocks.service<span class="meta prompt_"># </span><span class="language-bash">启动服务</span>sudo systemctl start shadowsocks.service<span class="meta prompt_"># </span><span class="language-bash">查看状态</span>sudo systemctl status shadowsocks.service<span class="meta prompt_"># </span><span class="language-bash">停止服务</span>sudo systemctl stop shadowsocks.service</code></pre><h2 id="启动-shadowsocks-发现错误"><a href="#启动-shadowsocks-发现错误" class="headerlink" title="启动 shadowsocks 发现错误"></a>启动 shadowsocks 发现错误</h2><p>执行 <code>sudo systemctl status shadowsocks.service</code> 出现报错：</p><pre><code class="highlight shell">× shadowsocks.service - Shadowsocks     Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; preset: disabled)     Active: failed (Result: exit-code) since Wed 2025-01-08 09:58:27 CST; 5s ago   Duration: 70ms    Process: 4756 ExecStart=/usr/local/bin/sslocal -c /etc/shadowsocks/shadowsocks.json (code=exited, status=1/FAILURE)   Main PID: 4756 (code=exited, status=1/FAILURE)        CPU: 66msJan 08 09:58:27 localhost.localdomain sslocal[4756]:     load_openssl()Jan 08 09:58:27 localhost.localdomain sslocal[4756]:   File &quot;/usr/local/lib/python3.9/site-packages/shadowsocks/crypto/openssl.py&quot;, line 52, in load_opensslJan 08 09:58:27 localhost.localdomain sslocal[4756]:     libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)Jan 08 09:58:27 localhost.localdomain sslocal[4756]:   File &quot;/usr/lib64/python3.9/ctypes/__init__.py&quot;, line 387, in __getattr__Jan 08 09:58:27 localhost.localdomain sslocal[4756]:     func = self.__getitem__(name)Jan 08 09:58:27 localhost.localdomain sslocal[4756]:   File &quot;/usr/lib64/python3.9/ctypes/__init__.py&quot;, line 392, in __getitem__Jan 08 09:58:27 localhost.localdomain sslocal[4756]:     func = self._FuncPtr((name_or_ordinal, self))Jan 08 09:58:27 localhost.localdomain sslocal[4756]: AttributeError: /lib64/libcrypto.so.3: undefined symbol: EVP_CIPHER_CTX_cleanupJan 08 09:58:27 localhost.localdomain systemd[1]: shadowsocks.service: Main process exited, code=exited, status=1/FAILUREJan 08 09:58:27 localhost.localdomain systemd[1]: shadowsocks.service: Failed with result &#x27;exit-code&#x27;.[root@localhost ~]# vim /usr/local/lib/python3.9/site-packages/shadowsocks/crypto/openssl.py</code></pre><blockquote><p><strong>解决方式：</strong> 把所有的 <code>EVP_CIPHER_CTX_cleanup</code> 都改成 <code>EVP_CIPHER_CTX_reset</code> 就行。</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">替换文本内容</span>sudo sed -i &#x27;s/EVP_CIPHER_CTX_cleanup/EVP_CIPHER_CTX_reset/g&#x27; /usr/local/lib/python3.9/site-packages/shadowsocks/crypto/openssl.py<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重启 shadowsockts</span>sudo systemctl restart shadowsocks.service</code></pre><p>参考：<a href="https://www.yangyang.cloud/blog/2020/09/23/solved-shadowsocks-undefined-symbol/">https://www.yangyang.cloud/blog/2020/09/23/solved-shadowsocks-undefined-symbol/</a></p><p>参考：<a href="http://qiushao.net/2019/11/14/Linux/ubuntu-shadowsocks/">http://qiushao.net/2019/11/14/Linux/ubuntu-shadowsocks/</a></p></blockquote><p>修改完之后，发现依然报错：</p><blockquote><p><strong>报错内容：</strong></p><pre><code class="highlight shell">INFO: loading config from /etc/shadowsocks/shadowsocks.json2025-01-08 10:18:44 INFO     loading libcrypto from libcrypto.so.3Traceback (most recent call last):  File &quot;/usr/local/bin/sslocal&quot;, line 8, in &lt;module&gt;    sys.exit(main())  File &quot;/usr/local/lib/python3.9/site-packages/shadowsocks/local.py&quot;, line 39, in main    config = shell.get_config(True)  File &quot;/usr/local/lib/python3.9/site-packages/shadowsocks/shell.py&quot;, line 262, in get_config    check_config(config, is_local)  File &quot;/usr/local/lib/python3.9/site-packages/shadowsocks/shell.py&quot;, line 124, in check_config    encrypt.try_cipher(config[&#x27;password&#x27;], config[&#x27;method&#x27;])  File &quot;/usr/local/lib/python3.9/site-packages/shadowsocks/encrypt.py&quot;, line 44, in try_cipher    Encryptor(key, method)  File &quot;/usr/local/lib/python3.9/site-packages/shadowsocks/encrypt.py&quot;, line 82, in __init__    self.cipher = self.get_cipher(key, method, 1,  File &quot;/usr/local/lib/python3.9/site-packages/shadowsocks/encrypt.py&quot;, line 109, in get_cipher    return m[2](method, key, iv, op)  File &quot;/usr/local/lib/python3.9/site-packages/shadowsocks/crypto/rc4_md5.py&quot;, line 33, in create_cipher    return openssl.OpenSSLCrypto(b&#x27;rc4&#x27;, rc4_key, b&#x27;&#x27;, op)  File &quot;/usr/local/lib/python3.9/site-packages/shadowsocks/crypto/openssl.py&quot;, line 92, in __init__    raise Exception(&#x27;can not initialize cipher context&#x27;)Exception: can not initialize cipher contextSegmentation fault (core dumped)</code></pre><ul><li><p>解决方式：开启 RC4-MD5 支持</p><p>参考链接：<a href="https://blog.vinsonws.cn/2023/05/25/openssl-openssl3-%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF-rc4-md5-%E6%94%AF%E6%8C%81/">https://blog.vinsonws.cn/2023/05/25/openssl-openssl3-%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF-rc4-md5-%E6%94%AF%E6%8C%81/</a></p><ul><li><p>编辑 openssl.cnf</p><pre><code class="highlight shell">vi /etc/ssl/openssl.cnf</code></pre><p>在 provider_sect 下添加 legacy &#x3D; legacy_sect</p><pre><code class="highlight shell">[provider_sect]legacy = legacy_sect</code></pre><p>然后，将</p><pre><code class="highlight shell">[default_sect]<span class="meta prompt_"># </span><span class="language-bash">activate = 1</span></code></pre><p>替换为</p><pre><code class="highlight shell">[default_sect]activate = 1[legacy_sect]activate = 1</code></pre><p>重新启动程序测试</p><pre><code class="highlight shell">[root@localhost ~]# /usr/local/bin/sslocal -c /etc/shadowsocks/shadowsocks.jsonINFO: loading config from /etc/shadowsocks/shadowsocks.json2025-01-08 10:26:30 INFO     loading libcrypto from libcrypto.so.32025-01-08 10:26:30 INFO     starting local at 127.0.0.1:1080</code></pre><p>启动 shadowsockts</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">重启 shadowsockts</span>sudo systemctl restart shadowsocks.service</code></pre></li></ul></li></ul></blockquote><h1 id="安装和配置-Privoxy"><a href="#安装和配置-Privoxy" class="headerlink" title="安装和配置 Privoxy"></a>安装和配置 Privoxy</h1><h2 id="安装-Privoxy"><a href="#安装-Privoxy" class="headerlink" title="安装 Privoxy"></a>安装 Privoxy</h2><pre><code class="highlight shell">dnf install -y privoxy</code></pre><h2 id="修改-privoxy-配置"><a href="#修改-privoxy-配置" class="headerlink" title="修改 privoxy 配置"></a>修改 privoxy 配置</h2><pre><code class="highlight shell">修改配置 vim /etc/privoxy/config<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">搜索 forward-socks5t，将 forward-socks5t / 127.0.0.1:9050 . 取消注释并修改为</span>forward-socks5t / 127.0.0.1:1080 .  # 注意最后有个点<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">然后取消以下几行代码注释，本地网络不翻墙</span>forward         192.168.*.*/     .forward            10.*.*.*/     .forward           127.*.*.*/     .forward           localhost/     .</code></pre><h2 id="启动-privoxy"><a href="#启动-privoxy" class="headerlink" title="启动 privoxy"></a>启动 privoxy</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">设置开机自启</span>systemctl enable privoxy<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启动privoxy(这一步需要在读取配置文件之前执行))</span>systemctl start privoxy<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看privoxy状态</span>systemctl status privoxy<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">停止</span>systemctl stop privoxy</code></pre><p>privoxy 读取配置</p><pre><code class="highlight shell">privoxy /etc/privoxy/config</code></pre><h1 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h1><h2 id="修改-etc-profile"><a href="#修改-etc-profile" class="headerlink" title="修改 &#x2F;etc&#x2F;profile"></a>修改 &#x2F;etc&#x2F;profile</h2><pre><code class="highlight shell">vim /etc/profile<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">添加如下内容:</span>export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118export all_proxy=http://127.0.0.1:8118</code></pre><h2 id="使配置生效"><a href="#使配置生效" class="headerlink" title="使配置生效"></a>使配置生效</h2><pre><code class="highlight shell">source /etc/profile</code></pre><h2 id="测试网络代理"><a href="#测试网络代理" class="headerlink" title="测试网络代理"></a>测试网络代理</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">测试wget下载谷歌首页</span>wget www.google.com<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">测试 curl</span>curl https://www.google.com</code></pre><h2 id="停止网络代理"><a href="#停止网络代理" class="headerlink" title="停止网络代理"></a>停止网络代理</h2><p>不需要使用代理时停止网络代理，节约流量。</p><p>注释掉网络代理设置，并使环境变量生效</p><pre><code class="highlight shell">vim /etc/profile<span class="meta prompt_"># </span><span class="language-bash">注释掉网络代理环境变量</span><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118</span><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> https_proxy=http://127.0.0.1:8118</span><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> all_proxy=http://127.0.0.1:8118</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">使配置生效</span>source /etc/profileunset http_proxyunset https_proxyunset all_proxy</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://ry.huaji.store/2020/08/Linux-magic-network/">https://ry.huaji.store/2020/08/Linux-magic-network/</a></li><li><a href="https://andblog.cn/2587">https://andblog.cn/2587</a></li><li><a href="https://witee.github.io/2019/02/19/centos7%E4%BD%BF%E7%94%A8privoxy%E9%85%8D%E5%90%88shadowsocks%E7%BF%BB%E5%A2%99/">https://witee.github.io/2019/02/19/centos7%E4%BD%BF%E7%94%A8privoxy%E9%85%8D%E5%90%88shadowsocks%E7%BF%BB%E5%A2%99/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统：Rocky Linux 9.3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="linux" scheme="https://georgechan95.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="科学上网" scheme="https://georgechan95.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    <category term="Rocky" scheme="https://georgechan95.github.io/tags/Rocky/"/>
    
  </entry>
  
  <entry>
    <title>003-基于Rocky9.3系统使用kubeadm安装k8s1.29集群</title>
    <link href="https://georgechan95.github.io/blog/b00f53e9.html"/>
    <id>https://georgechan95.github.io/blog/b00f53e9.html</id>
    <published>2025-01-03T14:05:00.000Z</published>
    <updated>2025-01-08T06:21:16.851Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>RockyLinux：9.3</p><p>K8s版本：1.29</p><p>Docker版本：27.4.1</p></blockquote><p><strong>软件包来源</strong></p><blockquote><p>系统镜像下载官网：<a href="https://rockylinux.org/zh-CN/download">https://rockylinux.org/zh-CN/download</a></p><p>镜像下载地址：<a href="https://dl.rockylinux.org/vault/rocky/9.3/isos/x86_64/">https://dl.rockylinux.org/vault/rocky/9.3/isos/x86_64/</a></p><p>安装镜像文件：Rocky-9.3-x86_64-minimal.iso</p></blockquote><h1 id="1、集群规划"><a href="#1、集群规划" class="headerlink" title="1、集群规划"></a>1、集群规划</h1><p>基于 Linux Rocky 9.3 系统使用 <code>kubeadm</code> 搭建一主两从的 k8s 集群。</p><table><thead><tr><th>IP地址</th><th>主机名</th><th>角色</th><th>系统版本</th><th>CPU&#x2F;内存&#x2F;磁盘</th></tr></thead><tbody><tr><td>192.168.6.223</td><td>k8s-master01</td><td>管理节点</td><td>Rocky Linux 9.3</td><td>2U&#x2F;4G&#x2F;100G</td></tr><tr><td>192.168.6.225</td><td>k8s-node01</td><td>部署节点</td><td>Rocky Linux 9.3</td><td>2U&#x2F;4G&#x2F;100G</td></tr><tr><td>192.168.6.226</td><td>k8s-node02</td><td>部署节点</td><td>Rocky Linux 9.3</td><td>2U&#x2F;4G&#x2F;100G</td></tr></tbody></table><h1 id="2、集群基础环境配置"><a href="#2、集群基础环境配置" class="headerlink" title="2、集群基础环境配置"></a>2、集群基础环境配置</h1><h2 id="2-1-主机名设置"><a href="#2-1-主机名设置" class="headerlink" title="2.1 主机名设置"></a>2.1 主机名设置</h2><p>设置集群中各个节点的主机名</p><blockquote><p>master01 节点执行</p><pre><code class="highlight shell">hostnamectl set-hostname k8s-master01</code></pre></blockquote><blockquote><p>node01 节点执行</p><pre><code class="highlight shell">hostnamectl set-hostname k8s-node01</code></pre></blockquote><blockquote><p>node02 节点执行</p><pre><code class="highlight shell">hostnamectl set-hostname k8s-node02</code></pre></blockquote><h2 id="2-2-修改hosts文件"><a href="#2-2-修改hosts文件" class="headerlink" title="2.2 修改hosts文件"></a>2.2 修改hosts文件</h2><p>配置集群各节点 hostname 和 ip 的映射</p><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">cat &gt;&gt; /etc/hosts &lt;&lt; &quot;EOF&quot;192.168.6.223 k8s-master01192.168.6.225 k8s-node01192.168.6.226 k8s-node02EOF</code></pre></blockquote><h2 id="2-3-修改终端颜色"><a href="#2-3-修改终端颜色" class="headerlink" title="2.3 修改终端颜色"></a>2.3 修改终端颜色</h2><p>这里只是修改shell终端显示文本的颜色，非必要步骤。</p><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">cat &lt;&lt; EOF &gt;&gt; ~/.bashrcPS1=&quot;\[\e[37;47m\][\[\e[32;47m\]\u\[\e[34;47m\]@\h \[\e[36;47m\]\w\[\e[0m\]]\\$ &quot;EOF<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">让修改立即见效</span>source ~/.bashrc</code></pre></blockquote><blockquote><p><strong>命令解析：</strong>这段命令用于修改当前用户的 <strong>Bash Shell 提示符</strong>（<code>PS1</code>），并将其设置写入到 <code>~/.bashrc</code> 文件中，以便在每次登录或启动 Shell 时自动加载该配置。</p><pre><code class="highlight plaintext">PS1=&quot;...&quot;定义 Shell 的主提示符格式（Prompt String 1），即你在终端中输入命令时显示的提示符。</code></pre><p>最终效果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/04/20250104-112243.png" alt="终端颜色修改"></p></blockquote><h2 id="2-4-更换系统软件源"><a href="#2-4-更换系统软件源" class="headerlink" title="2.4 更换系统软件源"></a>2.4 更换系统软件源</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">更新源</span>sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \    -e &#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27; \    -i.bak /etc/yum.repos.d/[Rr]ocky*.repo    <span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">刷新dnf缓存</span>dnf makecache<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">验证源更新</span>dnf repolist</code></pre></blockquote><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">使用 sed 命令修改 Rocky Linux 的 YUM/DNF 源配置文件，切换到阿里云的镜像源。</span>sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \    -e &#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27; \    -i.bak /etc/yum.repos.d/[Rr]ocky*.repo    <span class="meta prompt_"># </span><span class="language-bash">将以 mirrorlist= 开头的行注释掉（在前面加 <span class="comment">#）</span></span>-e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">将以 <span class="comment">#baseurl= 开头并指向默认 Rocky Linux 源的行取消注释，并替换为阿里云镜像源 URL。</span></span>&#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">-i.bak：直接修改文件，并为原文件创建备份（扩展名为 .bak）。</span><span class="meta prompt_"># </span><span class="language-bash">修改 /etc/yum.repos.d/ 目录下所有以 rocky 或 Rocky 开头的 .repo 文件。</span><span class="meta prompt_"># </span><span class="language-bash">修改完成后，原始文件会被备份为 .bak 文件。</span>-i.bak /etc/yum.repos.d/[Rr]ocky*.repo<span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">更新本地缓存，确保系统可以快速查询软件包信息。</span>dnf makecache</code></pre></li></ul><h2 id="2-5-修改防火墙"><a href="#2-5-修改防火墙" class="headerlink" title="2.5 修改防火墙"></a>2.5 修改防火墙</h2><p>防火墙修改 firewalld 为 iptables</p><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">systemctl stop firewalldsystemctl disable firewalldyum -y install iptables-servicessystemctl start iptablesiptables -Fsystemctl enable iptablesservice iptables save</code></pre></blockquote><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">停止运行 firewalld</span>systemctl stop firewalld<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">禁止 firewalld 开机自启</span>systemctl disable firewalld<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装 iptables 服务，用于管理 Linux 的防火墙规则</span>yum -y install iptables-services<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">使防火墙规则立即生效，并开始运行 iptables 防火墙服务。</span>systemctl start iptables<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">删除当前的防火墙规则，通常用于重置或清理防火墙规则。</span>iptables -F<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置 iptables 服务开机自启动，确保服务器重启后，iptables 服务会自动加载防火墙规则。</span>systemctl enable iptables<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">将当前 iptables 的规则配置保存到文件中（通常是 /etc/sysconfig/iptables），以便在系统重启或 iptables 服务重新启动后，能够自动加载保存的规则。</span>service iptables save</code></pre></li></ul><h2 id="2-6-禁用-Selinux"><a href="#2-6-禁用-Selinux" class="headerlink" title="2.6 禁用 Selinux"></a>2.6 禁用 Selinux</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">setenforce 0sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/configgrubby --update-kernel ALL --args selinux=0</code></pre></blockquote><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">将 SELinux 的模式设置为 Permissive（宽容模式）。</span><span class="meta prompt_"># </span><span class="language-bash">0：表示设置为 Permissive 模式，此模式下 SELinux 不会强制执行安全策略，而是记录违规日志。</span><span class="meta prompt_"># </span><span class="language-bash">1：表示 Enforcing 模式，此模式下 SELinux 会强制执行安全策略。</span>setenforce 0<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改 SELinux 配置文件 /etc/selinux/config，将 SELINUX 设置为 disabled。永久禁用 SELinux，即使系统重启也不会再启用。</span>sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">通过 grubby 工具将 selinux=0 参数添加到所有内核启动配置中。</span>grubby --update-kernel ALL --args selinux=0grubby --info DEFAULT<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看是否禁用，</span>grubby --info DEFAULT<span class="meta prompt_"># </span><span class="language-bash">回滚内核层禁用操作，、</span>grubby --update-kernel ALL --remove-args selinux</code></pre></li><li><p>修改完成后重启系统</p><pre><code class="highlight shell">reboot</code></pre></li></ul><h2 id="2-7-设置时区"><a href="#2-7-设置时区" class="headerlink" title="2.7 设置时区"></a>2.7 设置时区</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">timedatectl set-timezone Asia/Shanghai</code></pre></blockquote><h2 id="2-8-集群时间同步设置"><a href="#2-8-集群时间同步设置" class="headerlink" title="2.8 集群时间同步设置"></a>2.8 集群时间同步设置</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">timedatectldnf install -y chronysystemctl enable chronyd.servicesystemctl restart chronyd.servicesystemctl status chronyd.servicevim /etc/chrony.conf<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改完chrony配置后，重启chrony服务</span>systemctl enable chronyd  --now</code></pre><ul><li><p>chrony配置内容如下</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">添加阿里云NTP服务器</span>pool ntp1.aliyun.com iburstpool ntp2.aliyun.com iburstpool cn.pool.ntp.org iburst    <span class="meta prompt_"># </span><span class="language-bash">允许指定网段访问此时间服务器，不然只允许本地网络</span>allow 192.168.0.0/16</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-195813.png" alt="chrony配置内容"></p></li></ul></blockquote><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">检查时区和时间</span>timedatectl<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装chrony进行时间同步，ntpdate在Rocky 9中不再支持</span>dnf install -y chrony<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启用chronyd服务</span>systemctl enable chronyd.service<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重启chronyd服务</span>systemctl restart chronyd.service<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看chronyd服务状态</span>systemctl status chronyd.service</code></pre></li></ul><h2 id="2-9-修改系统最大打开文件数"><a href="#2-9-修改系统最大打开文件数" class="headerlink" title="2.9 修改系统最大打开文件数"></a>2.9 修改系统最大打开文件数</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><p>在 <code>/etc/security/limits.conf</code> 文件的末尾追加以下内容</p><pre><code class="highlight shell">*softnofile65535*hardnofile65535</code></pre><p>目的：修改最大打开文件数限制</p></blockquote><h2 id="2-10-安装必要的库和修改-sysctl-conf-内核参数配置"><a href="#2-10-安装必要的库和修改-sysctl-conf-内核参数配置" class="headerlink" title="2.10 安装必要的库和修改 sysctl.conf 内核参数配置"></a>2.10 安装必要的库和修改 <code>sysctl.conf</code> 内核参数配置</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">dnf install -y epel-releasednf install -y bridge-utilsmodprobe br_netfilterecho &#x27;br_netfilter&#x27; &gt;&gt; /etc/modules-load.d/bridge.confcat &gt;&gt; /etc/sysctl.conf &lt;&lt;EOFnet.bridge.bridge-nf-call-iptables=1net.bridge.bridge-nf-call-ip6tables=1net.ipv4.ip_forward=1net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_tw_buckets = 20480net.ipv4.tcp_max_syn_backlog = 20480net.core.netdev_max_backlog = 262144net.ipv4.tcp_fin_timeout = 20EOF<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重新加载 /etc/sysctl.conf 中的所有内核参数配置，并使其立即生效。</span>sysctl -p</code></pre></blockquote><ul><li><p>命令解释</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">安装 EPEL（Extra Packages <span class="keyword">for</span> Enterprise Linux） 仓库的 Release 包。</span><span class="meta prompt_"># </span><span class="language-bash">EPEL 是由 Fedora 社区维护的一个软件仓库，提供许多额外的软件包，这些包在默认的 RHEL（或其衍生版如 CentOS、Rocky Linux 等）中没有包含。</span>yum install -y epel-release<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装 bridge-utils 软件包。</span><span class="meta prompt_"># </span><span class="language-bash">bridge-utils 是一个 Linux 工具集，用于创建和管理网络桥接（bridging）。</span>yum install -y bridge-utils<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">加载 br_netfilter 内核模块。</span><span class="meta prompt_"># </span><span class="language-bash">该模块用于启用网络桥接（bridge）时的流量过滤功能。</span><span class="meta prompt_"># </span><span class="language-bash">允许通过桥接的网络流量被 iptables 规则管理。</span><span class="meta prompt_"># </span><span class="language-bash">在容器或虚拟化环境中，确保桥接网络的流量可以被正确处理。</span>modprobe br_netfilter<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">将 br_netfilter 模块名称添加到 /etc/modules-load.d/bridge.conf 文件中。</span><span class="meta prompt_"># </span><span class="language-bash">配置系统在启动时自动加载 br_netfilter 模块。</span>echo &#x27;br_netfilter&#x27; &gt;&gt; /etc/modules-load.d/bridge.conf<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">向 /etc/sysctl.conf 文件添加配置，使桥接流量可以通过 iptables 规则管理。</span><span class="meta prompt_"># </span><span class="language-bash">启用桥接网络上的 IPv4 流量通过 iptables 的规则处理。</span>net.bridge.bridge-nf-call-iptables=1<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">向 /etc/sysctl.conf 文件添加配置，使桥接流量中的 IPv6 流量可以通过 ip6tables 规则管理。</span>net.bridge.bridge-nf-call-ip6tables=1<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">向 /etc/sysctl.conf 文件添加配置，启用 IP 转发功能。</span><span class="meta prompt_"># </span><span class="language-bash">用途：在容器网络或 Kubernetes 集群中，允许跨子网通信。</span>net.ipv4.ip_forward=1<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启用 TCP SYN Cookie 技术，用于防范 SYN Flood 攻击。</span><span class="meta prompt_"># </span><span class="language-bash">在服务器收到大量的 TCP SYN 请求但无法分配足够资源时，启用 SYN Cookie 可通过一种临时编码方式验证连接合法性，避免资源耗尽。</span>net.ipv4.tcp_syncookies = 1<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置系统同时保持的 TCP TIME_WAIT 状态的连接数上限。达到上限后，系统会直接丢弃多余的连接（而不是继续占用资源）。</span><span class="meta prompt_"># </span><span class="language-bash">默认值180000,对于高并发的 Web 服务器或反向代理，适当调低该值（如 20480）以避免 TIME_WAIT 数量过多。</span>net.ipv4.tcp_max_tw_buckets = 20480<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置 TCP 三次握手中 SYN 请求的队列长度上限。</span><span class="meta prompt_"># </span><span class="language-bash">当服务器接收的 SYN 请求超过该值时，新的连接请求会被丢弃。</span><span class="meta prompt_"># </span><span class="language-bash">如果服务器负载较高且连接数较多，可以调高到 20480 或更高。</span>net.ipv4.tcp_max_syn_backlog = 20480<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置网络设备接收队列的最大长度。</span><span class="meta prompt_"># </span><span class="language-bash">如果接收队列中的数据包数量超过该值，内核将直接丢弃后续数据包。</span><span class="meta prompt_"># </span><span class="language-bash">在高流量环境中，设置为较高值（如 262144）以避免丢包，提高吞吐量。</span>net.core.netdev_max_backlog = 262144<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置 TCP 连接处于 FIN_WAIT2 状态的超时时间（单位：秒）。</span><span class="meta prompt_"># </span><span class="language-bash">FIN_WAIT2 状态表示服务端已发送 FIN 包等待客户端确认，此状态会持续占用资源。</span><span class="meta prompt_"># </span><span class="language-bash">默认值：通常为 60 秒。</span><span class="meta prompt_"># </span><span class="language-bash">在高并发服务器上，将该值调低（如 20）以减少 FIN_WAIT2 状态的资源占用。</span>net.ipv4.tcp_fin_timeout = 20<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重新加载 /etc/sysctl.conf 中的所有内核参数配置，并使其立即生效。</span>sysctl -p</code></pre></li></ul><h2 id="2-11-关闭-swap-分区"><a href="#2-11-关闭-swap-分区" class="headerlink" title="2.11 关闭 swap 分区"></a>2.11 关闭 swap 分区</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">swapoff -ased -i &#x27;s:/dev/mapper/rl-swap:#/dev/mapper/rl-swap:g&#x27; /etc/fstab</code></pre></blockquote><ul><li><p>命令解释</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash"> 立即关闭系统中所有的交换分区</span>swapoff -a<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">注释掉 /etc/fstab 文件中定义的交换分区挂载条目，防止系统在重启后重新启用交换分区。</span>sed -i &#x27;s:/dev/mapper/rl-swap:#/dev/mapper/rl-swap:g&#x27; /etc/fstab<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">验证交换分区是否关系</span>free -h输出中 Swap 一栏的值会变为 0。</code></pre></li></ul><h1 id="3、集群各个节点安装Docker服务"><a href="#3、集群各个节点安装Docker服务" class="headerlink" title="3、集群各个节点安装Docker服务"></a>3、集群各个节点安装Docker服务</h1><h2 id="3-1-添加-docker-ce-yum-源"><a href="#3-1-添加-docker-ce-yum-源" class="headerlink" title="3.1 添加 docker-ce yum 源"></a>3.1 添加 docker-ce yum 源</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposudo sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.reposudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre></blockquote><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">使用 dnf config-manager 命令添加 Docker 软件包的官方仓库（在这里是阿里云的镜像）。</span>sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改 docker-ce.repo 文件中的镜像源地址，将默认的 download.docker.com 替换为阿里云的镜像地址 mirrors.aliyun.com/docker-ce。</span>sudo sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装最新版本docker</span>sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre></li></ul><h2 id="3-2-开启Docker服务"><a href="#3-2-开启Docker服务" class="headerlink" title="3.2 开启Docker服务"></a>3.2 开启Docker服务</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">systemctl start dockersystemctl enable docker</code></pre></blockquote><h2 id="3-3-配置-daemon-json"><a href="#3-3-配置-daemon-json" class="headerlink" title="3.3 配置 daemon.json"></a>3.3 配置 daemon.json</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">cat &gt;&gt;/etc/docker/daemon.json &lt;&lt;EOF&#123;  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;        &quot;max-size&quot;: &quot;100m&quot;,        &quot;max-file&quot;: &quot;10&quot;  &#125;,  &quot;data-root&quot;:&quot;/data/docker&quot;,  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],  &quot;registry-mirrors&quot;: [   &quot;https://kfp63jaj.mirror.aliyuncs.com&quot;,    &quot;https://hub-mirror.c.163.com&quot;,    &quot;https://mirror.baidubce.com&quot;  ]&#125;EOF</code></pre></blockquote><ul><li><p>配置解析</p><pre><code class="highlight shell">&quot;data-root&quot;: &quot;/data/docker&quot;指定 Docker 数据的存储目录为 /data/docker。包括容器、镜像、卷等内容。默认存储在 /var/lib/docker，此配置用于更改默认路径。&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]配置 Docker 使用 systemd 作为 Cgroup 驱动程序。推荐在使用现代 Linux 发行版（如 Rocky Linux 9）或 Kubernetes 时采用此配置，以实现更好的资源管理和兼容性。&quot;log-driver&quot;: &quot;json-file&quot;指定 Docker 的日志驱动为 json-file。json-file 是 Docker 默认的日志存储方式，将日志保存在 JSON 文件中。&quot;log-opts&quot;: &#123;&#125;配置日志驱动的选项：&quot;max-size&quot;: &quot;100m&quot;：每个日志文件的最大大小为 100MB。&quot;max-file&quot;: &quot;100&quot;：最多保留 100 个日志文件（滚动日志机制）。&quot;insecure-registries&quot;: [&quot;harbor.xinxainghf.com&quot;]配置不安全的私有镜像仓库地址（即未启用 HTTPS 的仓库）。例如，harbor.xinxainghf.com 是一个私有仓库地址。&quot;registry-mirrors&quot;: [&quot;https://kfp63jaj.mirror.aliyuncs.com&quot;]配置 Docker 镜像加速器。镜像地址为阿里云镜像服务，加速从官方 Docker Hub 拉取镜像的速度。</code></pre></li></ul><h2 id="3-4-创建-Docker-服务的自定义配置目录"><a href="#3-4-创建-Docker-服务的自定义配置目录" class="headerlink" title="3.4 创建 Docker 服务的自定义配置目录"></a>3.4 创建 Docker 服务的自定义配置目录</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">mkdir -p /etc/systemd/system/docker.service.d</code></pre><p>用于存放 Docker 服务的自定义配置文件。</p></blockquote><h2 id="3-5-重新加载-Docker-配置"><a href="#3-5-重新加载-Docker-配置" class="headerlink" title="3.5 重新加载 Docker 配置"></a>3.5 重新加载 Docker 配置</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">systemctl daemon-reloadsystemctl restart docker</code></pre><ul><li><p>验证配置是否生效</p><pre><code class="highlight shell">docker info</code></pre></li></ul></blockquote><h1 id="4、安装-cri-docker"><a href="#4、安装-cri-docker" class="headerlink" title="4、安装 cri-docker"></a>4、安装 cri-docker</h1><p>从 kubernetes 1.24 开始，dockershim 已经从 kubelet 中移除（ dockershim 是 Kubernetes 的一个组件，主要目的是为了通过 CRI 操作 Docker），但因为历史问题 docker 却不支持 kubernetes 主推的CRI（容器运行时接口）标准，所以 docker 不能再作为 kubernetes 的容器运行时了，即从 kubernetesv1.24 开始不再使用 docker 了，默认使用的容器运行时是 containerd 。目前 containerd 比较新，可能存在一些功能不稳定的情况，所以这里我们使用容器运行时还是选择 docker。</p><p>如果想继续使用 docker 的话，可以在 kubelet 和 docker 之间加上一个中间层 cri-docker 。cri-docker 是一个支持CRI标准的 shim（垫片）。一头通过CRI跟kubelet 交互，另一头跟 docker api 交互，从而间接的实现了 kubernetes 以 docker 作为容器运行时。这里需要在全部节点执行 cri-docker 安装。</p><h2 id="4-1-下载-cri-docker"><a href="#4-1-下载-cri-docker" class="headerlink" title="4.1 下载 cri-docker"></a>4.1 下载 cri-docker</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建目录,并下载 cri-docker 安装文件到目录中</span>mkdir -p /opt/softwarecd /opt/softwarewget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.16/cri-dockerd-0.3.16.amd64.tgz</code></pre></blockquote><h2 id="4-2-解压-cri-docker"><a href="#4-2-解压-cri-docker" class="headerlink" title="4.2 解压 cri-docker"></a>4.2 解压 cri-docker</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">tar -xvf /opt/software/cri-dockerd-0.3.16.amd64.tgz --strip-components=1 -C /usr/local/bin/</code></pre></blockquote><h2 id="4-3-下载并修改-cri-docker-配置文件"><a href="#4-3-下载并修改-cri-docker-配置文件" class="headerlink" title="4.3 下载并修改 cri-docker 配置文件"></a>4.3 下载并修改 cri-docker 配置文件</h2><h3 id="4-3-1-下载-cri-docker-配置文件"><a href="#4-3-1-下载-cri-docker-配置文件" class="headerlink" title="4.3.1 下载 cri-docker 配置文件"></a>4.3.1 下载 cri-docker 配置文件</h3><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><p>在浏览器下载文件，通过xftp传到服务器上</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">下载 cri-docker.service</span><span class="meta prompt_"># </span><span class="language-bash">cri-docker.service 下载地址：https://github.com/Mirantis/cri-dockerd/blob/v0.3.16/packaging/systemd/cri-docker.service</span>mv /opt/software/cri-docker.service /etc/systemd/system/<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">下载 cri-docker.socket</span><span class="meta prompt_"># </span><span class="language-bash">cri-docker.socket 下载地址：https://github.com/Mirantis/cri-dockerd/blob/v0.3.16/packaging/systemd/cri-docker.socket</span>mv /opt/software/cri-docker.socket /etc/systemd/system/</code></pre></blockquote><h3 id="4-3-2-修改-cri-docker-配置文件"><a href="#4-3-2-修改-cri-docker-配置文件" class="headerlink" title="4.3.2 修改 cri-docker 配置文件"></a>4.3.2 修改 cri-docker 配置文件</h3><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p></blockquote><p><strong>修改 cri-docker.service 的启动命令 ExecStart</strong></p><pre><code class="highlight plaintext">vim /etc/systemd/system/cri-docker.service</code></pre><ul><li><p>修改内容如下：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">ExecStart=/usr/bin/cri-dockerd --container-runtime-endpoint fd://</span>ExecStart=/usr/local/bin/cri-dockerd --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9 --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock --cri-dockerd-root-directory=/data/dockershim --cri-dockerd-root-directory=/data/docker</code></pre><ul><li><p>配置解析</p><pre><code class="highlight plaintext">ExecStart作用: 定义 Systemd 启动服务时执行的命令。此命令会在服务启动时运行。/usr/local/bin/cri-dockerd解释: cri-dockerd 的可执行文件路径。作用: 启动 cri-dockerd 服务，为 Kubernetes 提供 CRI（容器运行时接口）支持。--pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9解释: 定义 Pod 的基础容器镜像。--container-runtime-endpoint=unix:///var/run/cri-dockerd.sock解释: 定义 CRI 的监听端点。作用: cri-dockerd 使用 Unix Socket 文件 /var/run/cri-dockerd.sock 提供与 Kubernetes 的交互接口。--cri-dockerd-root-directory=/data/dockershim解释: 定义 cri-dockerd 的根目录，用于存储临时文件或配置数据。作用: /data/dockershim 是修改后的 cri-dockerd 数据目录，默认存放在 /var/lib/dockershim，用于存放与 Docker 和 Kubernetes 通信相关的数据。--cri-dockerd-root-directory=/data/docker解释: 定义 Docker 的根目录。作用: Docker 的所有容器数据、镜像数据都存放在 /data/docker 目录下。</code></pre></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-213036.png" alt="cri-docker.service"></p><ul><li><p>修改cri-docker.socket的ListenStream参数</p><pre><code class="highlight shell">vim /etc/systemd/system/cri-docker.socket</code></pre><ul><li><p>修改内容如下：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">ListenStream=%t/cri-dockerd.sock</span>ListenStream=/var/run/cri-dockerd.sock</code></pre><ul><li><p>配置解析</p><pre><code class="highlight shell">ListenStream作用:定义 cri-dockerd 服务监听的通信地址和端口。在这里，指定了一个 Unix Socket 文件 /var/run/cri-dockerd.sock。/var/run/cri-dockerd.sock解释:这是一个 Unix Domain Socket 文件路径。Unix Sockets 是一种轻量级的进程间通信（IPC）方式，通常用于本地通信（与网络无关）。cri-dockerd 和 Kubernetes 的 kubelet 通过这个 Socket 文件进行交互。</code></pre></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-213125.png" alt="cri-dockerd.sock"></p></li></ul><p><strong>注意每个节点 cri-docker 都需要这么配置</strong></p><h2 id="4-4-启动-cri-docker-对应服务"><a href="#4-4-启动-cri-docker-对应服务" class="headerlink" title="4.4 启动 cri-docker 对应服务"></a>4.4 启动 cri-docker 对应服务</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">systemctl daemon-reloadsystemctl enable cri-dockersystemctl start cri-dockersystemctl is-active cri-docker</code></pre></blockquote><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">告诉 Systemd 重新加载所有服务配置文件。</span>systemctl daemon-reload<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置 cri-docker 服务为 开机自启。</span>systemctl enable cri-docker<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启动 cri-docker 服务。</span>systemctl start cri-docker<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">检查 cri-docker 服务是否正在运行。</span>systemctl is-active cri-docker</code></pre></li></ul><h1 id="5、使用-kubeadm-基于-Docker-Runtime-部署-kubernetes-集群"><a href="#5、使用-kubeadm-基于-Docker-Runtime-部署-kubernetes-集群" class="headerlink" title="5、使用 kubeadm 基于 Docker Runtime 部署 kubernetes 集群"></a>5、使用 kubeadm 基于 Docker Runtime 部署 kubernetes 集群</h1><h2 id="5-1-配置阿里云K8S源"><a href="#5-1-配置阿里云K8S源" class="headerlink" title="5.1 配置阿里云K8S源"></a>5.1 配置阿里云K8S源</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.29/rpm/enabled=1gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.29/rpm/repodata/repomd.xml.keyEOF</code></pre></blockquote><h2 id="5-2-安装K8S集群管理工具"><a href="#5-2-安装K8S集群管理工具" class="headerlink" title="5.2 安装K8S集群管理工具"></a>5.2 安装K8S集群管理工具</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">yum install -y kubelet kubeadm kubectl</code></pre></blockquote><h2 id="5-3-配置k8s-Cgoup控制组"><a href="#5-3-配置k8s-Cgoup控制组" class="headerlink" title="5.3 配置k8s Cgoup控制组"></a>5.3 配置k8s Cgoup控制组</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">vim /etc/sysconfig/kubelet</code></pre><ul><li><p>配置内容如下：</p><pre><code class="highlight shell">KUBELET_EXTRA_ARGS=&quot;--cgroup-driver=systemd&quot;</code></pre></li></ul></blockquote><ul><li><p>配置解析</p><pre><code class="highlight plaintext">KUBELET_EXTRA_ARGS含义:KUBELET_EXTRA_ARGS 是一个变量，用于为 kubelet 添加自定义的启动参数。这些参数会被系统初始化脚本或服务文件加载并传递给 kubelet 进程。--cgroup-driver=systemd作用:指定 kubelet 使用的 cgroup 驱动（Cgroup Driver）。Cgroup Driver 是 Kubernetes 用来与 Linux 内核 cgroup（控制组）交互的机制，负责资源（CPU、内存等）的限制和管理。该参数将驱动类型设置为 systemd，表示使用 systemd 来管理 cgroup。</code></pre></li></ul><h2 id="5-4-配置kubelet自启动"><a href="#5-4-配置kubelet自启动" class="headerlink" title="5.4 配置kubelet自启动"></a>5.4 配置kubelet自启动</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">systemctl enable kubelet.service</code></pre></blockquote><h2 id="5-5-初始化集群"><a href="#5-5-初始化集群" class="headerlink" title="5.5 初始化集群"></a>5.5 初始化集群</h2><h3 id="5-5-1-打印-master-节点所需的镜像文件"><a href="#5-5-1-打印-master-节点所需的镜像文件" class="headerlink" title="5.5.1 打印 master 节点所需的镜像文件"></a>5.5.1 打印 master 节点所需的镜像文件</h3><blockquote><p>只在 master01 服务器节点执行</p><pre><code class="highlight shell">kubeadm config images list</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-215555.png" alt="所需的镜像文件"></p></blockquote><h3 id="5-5-2-打印集群初始化配置文件"><a href="#5-5-2-打印集群初始化配置文件" class="headerlink" title="5.5.2 打印集群初始化配置文件"></a>5.5.2 打印集群初始化配置文件</h3><blockquote><p>只在 master01 服务器节点执行</p><pre><code class="highlight shell">kubeadm config print init-defaults &gt; kubeadm-config.yaml</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-215821.png" alt="集群初始化配置文件"></p></blockquote><h3 id="5-5-3-修改集群初始化配置文件"><a href="#5-5-3-修改集群初始化配置文件" class="headerlink" title="5.5.3 修改集群初始化配置文件"></a>5.5.3 修改集群初始化配置文件</h3><p>主要修改<code>advertiseAddress</code>,<code>criSocket</code>, <code>imageRepository</code>、<code>etcd.local.</code>dataDir 这4个参数，如下：</p><blockquote><p>只在 master01 服务器节点执行</p><pre><code class="highlight shell">vim /opt/software/kubeadm-config.yaml</code></pre><ul><li><p>修改内容如下：</p><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span><span class="attr">bootstrapTokens:</span><span class="bullet">-</span> <span class="attr">groups:</span>  <span class="bullet">-</span> <span class="string">system:bootstrappers:kubeadm:default-node-token</span>  <span class="attr">token:</span> <span class="string">abcdef.0123456789abcdef</span>  <span class="attr">ttl:</span> <span class="string">24h0m0s</span>  <span class="attr">usages:</span>  <span class="bullet">-</span> <span class="string">signing</span>  <span class="bullet">-</span> <span class="string">authentication</span><span class="attr">kind:</span> <span class="string">InitConfiguration</span><span class="attr">localAPIEndpoint:</span>  <span class="attr">advertiseAddress:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.223</span> <span class="comment"># 修改为集群初始化的master节点IP地址</span>  <span class="attr">bindPort:</span> <span class="number">6443</span><span class="attr">nodeRegistration:</span>  <span class="attr">criSocket:</span> <span class="string">unix:///var/run/cri-dockerd.sock</span> <span class="comment"># 高版本默认使用containerd，这里修改成使用dcoker</span>  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>  <span class="attr">name:</span> <span class="string">node</span>  <span class="attr">taints:</span> <span class="literal">null</span><span class="meta">---</span><span class="attr">apiServer:</span>  <span class="attr">timeoutForControlPlane:</span> <span class="string">4m0s</span><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span><span class="attr">clusterName:</span> <span class="string">kubernetes</span><span class="attr">controllerManager:</span> &#123;&#125;<span class="attr">dns:</span> &#123;&#125;<span class="attr">etcd:</span>  <span class="attr">local:</span>    <span class="attr">dataDir:</span> <span class="string">/data/etcd</span> <span class="comment"># 修改 etcd 的数据存储目录</span><span class="comment">#imageRepository: registry.k8s.io</span><span class="attr">imageRepository:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/google_containers</span> <span class="comment"># 这里修改成使用阿里云容器镜像</span><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span><span class="attr">kubernetesVersion:</span> <span class="number">1.29</span><span class="number">.0</span><span class="attr">networking:</span>  <span class="attr">dnsDomain:</span> <span class="string">cluster.local</span>  <span class="attr">serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span><span class="attr">scheduler:</span> &#123;&#125;</code></pre></li></ul></blockquote><ul><li><p>配置解析</p><pre><code class="highlight yaml"><span class="comment"># 指定配置文件的 API 版本，这里使用的是 v1beta3（Kubernetes 1.22+ 支持）。</span><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span><span class="attr">bootstrapTokens:</span><span class="bullet">-</span> <span class="attr">groups:</span>  <span class="comment"># 设置令牌的用户组，用于节点加入时的权限分配。</span>  <span class="bullet">-</span> <span class="string">system:bootstrappers:kubeadm:default-node-token</span>  <span class="comment"># 定义用于节点加入的令牌，由两部分组成：6 位前缀 + 16 位随机数。</span>  <span class="attr">token:</span> <span class="string">abcdef.0123456789abcdef</span>  <span class="comment"># 定义令牌的有效期，这里设置为 24 小时。</span>  <span class="attr">ttl:</span> <span class="string">24h0m0s</span>  <span class="attr">usages:</span>  <span class="comment"># signing：用于签署客户端证书请求。</span>  <span class="bullet">-</span> <span class="string">signing</span>  <span class="comment"># authentication：用于身份验证。</span>  <span class="bullet">-</span> <span class="string">authentication</span><span class="attr">kind:</span> <span class="string">InitConfiguration</span><span class="attr">localAPIEndpoint:</span> <span class="comment"># 配置本地 API 服务器的监听地址和端口：</span>  <span class="attr">advertiseAddress:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.223</span> <span class="comment"># 修改为集群初始化的master节点IP地址</span>  <span class="comment"># API 服务器的监听端口（默认是 6443）。</span>  <span class="attr">bindPort:</span> <span class="number">6443</span><span class="attr">nodeRegistration:</span>  <span class="comment"># 定义容器运行时接口（CRI）的 Socket 路径。</span>  <span class="attr">criSocket:</span> <span class="string">unix:///var/run/cri-dockerd.sock</span> <span class="comment"># 高版本默认使用containerd，这里修改成使用dcoker</span>  <span class="comment"># 配置镜像拉取策略，IfNotPresent 表示本地没有镜像时才拉取。</span>  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>  <span class="comment"># 注册的节点名称。</span>  <span class="attr">name:</span> <span class="string">node</span>  <span class="comment"># 设置节点的污点，这里为 null，表示不对节点进行污点设置。</span>  <span class="attr">taints:</span> <span class="literal">null</span><span class="meta">---</span><span class="attr">apiServer:</span> <span class="comment"># 配置 API 服务器的相关参数</span>  <span class="comment"># 控制平面组件的超时时间，设置为 4 分钟。</span>  <span class="attr">timeoutForControlPlane:</span> <span class="string">4m0s</span><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span><span class="comment"># 集群证书的存放路径：/etc/kubernetes/pki：默认路径。</span><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span><span class="comment"># 集群的标识名称。</span><span class="attr">clusterName:</span> <span class="string">kubernetes</span><span class="attr">controllerManager:</span> &#123;&#125;<span class="attr">dns:</span> &#123;&#125;<span class="attr">etcd:</span>  <span class="attr">local:</span>    <span class="comment"># 配置 etcd 数据存储信息</span>    <span class="attr">dataDir:</span> <span class="string">/data/etcd</span> <span class="comment"># 修改 etcd 的数据存储目录</span><span class="comment"># 定义镜像仓库地址</span><span class="comment">#imageRepository: registry.k8s.io</span><span class="attr">imageRepository:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/google_containers</span> <span class="comment"># 这里修改成使用阿里云容器镜像</span><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span><span class="comment"># 需要安装的 Kubernetes 主版本</span><span class="attr">kubernetesVersion:</span> <span class="number">1.29</span><span class="number">.0</span><span class="attr">networking:</span> <span class="comment"># 配置集群的网络信息</span>  <span class="comment"># DNS 的后缀域名（默认是 cluster.local）。</span>  <span class="attr">dnsDomain:</span> <span class="string">cluster.local</span>  <span class="comment"># 群中 Service 的虚拟 IP 子网，通常为 /12 子网。</span>  <span class="attr">serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span><span class="attr">scheduler:</span> &#123;&#125;</code></pre></li></ul><h3 id="5-5-4-使用以上配置文件进行集群初始化"><a href="#5-5-4-使用以上配置文件进行集群初始化" class="headerlink" title="5.5.4 使用以上配置文件进行集群初始化"></a>5.5.4 使用以上配置文件进行集群初始化</h3><blockquote><p>只在 master01 服务器节点执行</p><pre><code class="highlight shell">kubeadm init --config /opt/software/kubeadm-config.yaml --upload-certs</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-222023.png" alt="集群初始化"></p><p>初始化成功之后就会出现如下图打印</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-222052.png" alt="集群初始化成功"></p></blockquote><ul><li><p>命令解析</p><pre><code class="highlight plaintext">kubeadm init初始化 Kubernetes 集群的控制平面节点（Master）。这是 Kubernetes 集群部署的第一步。--config kubeadm-config.yaml指定使用自定义的配置文件 kubeadm-config.yaml 来初始化集群。配置文件中可以自定义网络、版本、镜像仓库、etcd 配置等关键参数。--upload-certs作用：将 Kubernetes 控制平面的证书（如 CA、API Server 证书等）加密后上传到集群内的 etcd 中。便于后续添加其他控制平面节点（即高可用部署时添加多个 Master 节点）。实现原理：Kubernetes 使用对称加密的方式，将证书加密后存储在集群中。生成一个临时的加密密钥，用于解密证书。后续节点加入命令：kubeadm join 时，通过指定该密钥，可以从集群中下载并解密这些证书，从而加入为控制平面节点。如果是单 Master 节点，可以不加 --upload-certs。但是如果未来计划扩展为高可用集群，建议使用 --upload-certs。</code></pre></li><li><p>master节点token过期处理</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">work token 过期后，重新申请</span>kubeadm token create --print-join-command</code></pre></li></ul><h3 id="5-5-5-配置环境变量"><a href="#5-5-5-配置环境变量" class="headerlink" title="5.5.5 配置环境变量"></a>5.5.5 配置环境变量</h3><p>集群初始化成功之后的打印中提示了我们 需要进行一下环境变量配置</p><blockquote><p>只在 master01 服务器节点执行</p><pre><code class="highlight shell">mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">如果是root用户操作，执行</span>export KUBECONFIG=/etc/kubernetes/admin.conf</code></pre></blockquote><ul><li><p>命令解析</p><pre><code class="highlight shell">mkdir -p $HOME/.kube功能：创建一个目录 $HOME/.kube，用来存放 Kubernetes 客户端 (kubectl) 的配置文件。选项：-p：确保目录路径中的每一级都被创建，如果目录已经存在则不会报错。背景：kubectl 需要一个配置文件（通常是 config）来连接 Kubernetes 集群并进行管理。<span class="meta prompt_">$</span><span class="language-bash">HOME/.kube 是 kubectl 默认查找配置文件的路径。</span>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config功能：将 Kubernetes 的集群配置文件 /etc/kubernetes/admin.conf 复制到当前用户的 $HOME/.kube/config。选项：-i：提示确认是否覆盖目标文件（如果目标文件已经存在）。背景：admin.conf 是由 kubeadm init 生成的配置文件，包含：集群的 API Server 地址认证信息（如 CA 证书、用户证书）配置上下文信息（上下文表示当前访问的集群和用户）默认情况下，该文件存储在 /etc/kubernetes/ 下，并且只有 root 用户可以访问。为了方便当前用户运行 kubectl 命令，需要将其复制到用户的主目录下。sudo chown $(id -u):$(id -g) $HOME/.kube/config功能：修改 $HOME/.kube/config 文件的所有者为当前用户和用户组。参数解析：<span class="meta prompt_">$</span><span class="language-bash">(<span class="built_in">id</span> -u)：返回当前用户的 UID。</span><span class="meta prompt_">$</span><span class="language-bash">(<span class="built_in">id</span> -g)：返回当前用户的 GID。</span>完整流程的意义创建 .kube 目录，用于存放 Kubernetes 配置文件。将集群的配置文件复制到用户目录中，使 kubectl 可以连接和管理集群。修改配置文件的权限，方便用户无权限问题地运行 kubectl 命令。</code></pre></li></ul><h3 id="5-5-6-所有woker节点加入到集群中"><a href="#5-5-6-所有woker节点加入到集群中" class="headerlink" title="5.5.6 所有woker节点加入到集群中"></a>5.5.6 所有woker节点加入到集群中</h3><blockquote><p>在 node01、node02 这2台服务器执行</p><pre><code class="highlight shell">kubeadm join 192.168.6.223:6443 --token abcdef.0123456789abcdef \--discovery-token-ca-cert-hash sha256:2abbc2082ec6ca53c24154e82e3d18d0d8bcd6410af674a1197d0c2ba75e47d6 \ --cri-socket=unix:///var/run/cri-dockerd.sock</code></pre><p>此命令来源于集群初始化时，控制台打印内容，添加了 –cri-socket&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-223427.png" alt="node01加入集群"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-223515.png" alt="node02加入集群"></p></blockquote><ul><li><p>master节点查看集群</p><pre><code class="highlight shell">kubectl get nodes</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-223611.png" alt="master节点查看集群"></p></li></ul><h1 id="6、部署网络插件"><a href="#6、部署网络插件" class="headerlink" title="6、部署网络插件"></a>6、部署网络插件</h1><h2 id="6-1-calico安装"><a href="#6-1-calico安装" class="headerlink" title="6.1 calico安装"></a>6.1 calico安装</h2><p>K8s使用calico部署集群网络,只需要在Master节点安装即可。</p><p>下载地址：<a href="https://github.com/projectcalico/calico">https://github.com/projectcalico/calico</a></p><blockquote><p>只在 master01 服务器节点执行</p><pre><code class="highlight shell">curl https://raw.githubusercontent.com/projectcalico/calico/v3.26.3/manifests/calico-typha.yaml -o /opt/software/calico.yaml</code></pre></blockquote><h2 id="6-2-创建calico网络"><a href="#6-2-创建calico网络" class="headerlink" title="6.2 创建calico网络"></a>6.2 创建calico网络</h2><blockquote><p>只在 master01 服务器节点执行</p><pre><code class="highlight shell">kubectl apply -f /opt/software/calico.yaml</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-225119.png" alt="创建calico网络"></p></blockquote><h2 id="6-3-验证集群可用性"><a href="#6-3-验证集群可用性" class="headerlink" title="6.3 验证集群可用性"></a>6.3 验证集群可用性</h2><blockquote><p>只在 master01 服务器节点执行</p><pre><code class="highlight shell">kubectl get nodes</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-225225.png" alt="验证集群可用性"></p><p>node1 与 node2 几点都处于 NotReady 状态，这是因为集群正在拉取 calico 所需的镜像，而这个镜像在国外，所以很慢，甚至会失败。</p><p>需要的镜像在 &#x2F;opt&#x2F;software&#x2F;calico.yaml 这个文件中，可以先下载好，再导入到服务器中。</p><p><strong>集群可用时</strong></p><p>如果所需镜像都下载完成，并成功启动后，执行 <code>kubectl get nodes</code> 显示如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/08/20250108-135619.png" alt="验证集群可用性"></p></blockquote><p>在安装 k8s 集群时，关于如何下载外网镜像是个绕不过去的问题。这里只说一种最稳妥的方式，就是给服务器配置网络代理，实现从官方下载镜像。</p><p>具体方式见：</p><blockquote><p>第一步：服务器配置外网代理,保证服务器可以正常访问谷歌等外网</p><ul><li><a href="https://georgechan95.github.io/blog/7f174b3e.html">Rocky9安装Shadowsocks实现科学上网</a></li></ul><p>第二步：配置Docker网络代理，实现k8s镜像的正常拉取</p><ul><li><a href="https://georgechan95.github.io/blog/b01d5c62.html">Docker配置网络代理实现外网镜像下载</a></li></ul></blockquote><h2 id="6-4-查看集群健康情况"><a href="#6-4-查看集群健康情况" class="headerlink" title="6.4 查看集群健康情况"></a>6.4 查看集群健康情况</h2><blockquote><p>只在 master01 服务器节点执行</p><pre><code class="highlight shell">kubectl get cs</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-225329.png" alt="查看集群健康情况"></p></blockquote><h2 id="6-5-查看kubernetes集群pod运行情况"><a href="#6-5-查看kubernetes集群pod运行情况" class="headerlink" title="6.5 查看kubernetes集群pod运行情况"></a>6.5 查看kubernetes集群pod运行情况</h2><blockquote><p>只在 master01 服务器节点执行</p><pre><code class="highlight shell">kubectl get pods -n kube-system</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/07/20250107-225718.png" alt="查看kubernetes集群pod运行情况"></p></blockquote><h2 id="6-6-worker节点配置"><a href="#6-6-worker节点配置" class="headerlink" title="6.6 worker节点配置"></a>6.6 worker节点配置</h2><p>当我们在Worker节点上执行kubectl命令管理时会报如下错误：</p><blockquote><p>在node节点执行</p><pre><code class="highlight shell">kubectl get pods -n kube-system</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/08/20250108-135945.png" alt="node节点执行kubectl命令报错"></p></blockquote><p><strong>解决方式：</strong></p><p>只要把 master上的管理文件 <code>/etc/kubernetes/admin.conf</code> 拷贝到 Worker 节点的 <code>$HOME/.kube/config</code> 就可以让 Worker 节点也可以实现 kubectl 命令管理。</p><blockquote><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">在 node1 节点执行</span>[root@k8s-node01 ~]$ mkdir /root/.kube<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">在node2节点执行</span>[root@k8s-node02 ~]$ mkdir /root/.kube<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">在master节点执行</span>[root@k8s-master01 ~]$ scp /etc/kubernetes/admin.conf root@192.168.6.225:/root/.kube/config[root@k8s-master01 ~]$ scp /etc/kubernetes/admin.conf root@192.168.6.226:/root/.kube/config</code></pre><ul><li><p>在node节点测试 kubectl 命令</p><pre><code class="highlight shell">[root@k8s-node01 ~]$ kubectl get pods -n kube-system</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/08/20250108-140700.png" alt="在node节点测试 kubectl 命令"></p></li></ul></blockquote><p><strong>至此，使用 kubeadm 完成了k8s集群的安装。</strong></p><h1 id="7、K8S集群的启停管理"><a href="#7、K8S集群的启停管理" class="headerlink" title="7、K8S集群的启停管理"></a>7、K8S集群的启停管理</h1><p>默认K8S我们只要设置了 <code>systemctl enable kubelet.service</code> 后，会在开机自动启动K8S集群，如果想要停止 kubernetes 集群，我们可以通过 <code>systemctl stop kubelet.service</code> 命令停止集群，但是必须先将节点上的docker停止。</p><p>不管你是通过哪种方式安装的K8S集群， 只要记住一句口诀就行了：<strong>启动K8S集群，先启动集群上所有的容器服务(不管是Docker还是Containerd)，停止K8S集群，先停止集群上所有的容器服务。</strong></p><h2 id="7-1-停止K8S集群"><a href="#7-1-停止K8S集群" class="headerlink" title="7.1 停止K8S集群"></a>7.1 停止K8S集群</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">systemctl stop dockersystemctl stop kubelet.service</code></pre></blockquote><h2 id="7-2-启动K8S集群"><a href="#7-2-启动K8S集群" class="headerlink" title="7.2 启动K8S集群"></a>7.2 启动K8S集群</h2><blockquote><p>在 master01、node01、node02 三台服务器分别执行</p><pre><code class="highlight shell">systemctl start dockersystemctl start kubelet.service</code></pre></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RockyLinux：9.3&lt;/p&gt;
&lt;p&gt;K8s版本：1.29&lt;/p&gt;
&lt;p&gt;Docker版本：27.4.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;软件包来源&lt;/str</summary>
      
    
    
    
    <category term="k8s" scheme="https://georgechan95.github.io/categories/k8s/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="Docker" scheme="https://georgechan95.github.io/tags/Docker/"/>
    
    <category term="Rocky" scheme="https://georgechan95.github.io/tags/Rocky/"/>
    
  </entry>
  
  <entry>
    <title>002-Rocky9.3系统初始化设置和Docker安装</title>
    <link href="https://georgechan95.github.io/blog/3c79d8d9.html"/>
    <id>https://georgechan95.github.io/blog/3c79d8d9.html</id>
    <published>2025-01-02T05:25:00.000Z</published>
    <updated>2025-01-04T02:44:14.317Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>RockyLinux：9.3</p><p>镜像下载官网：<a href="https://rockylinux.org/zh-CN/download">https://rockylinux.org/zh-CN/download</a></p><p>镜像下载地址：<a href="https://dl.rockylinux.org/vault/rocky/9.3/isos/x86_64/">https://dl.rockylinux.org/vault/rocky/9.3/isos/x86_64/</a></p><p>安装镜像文件：Rocky-9.3-x86_64-minimal.iso</p></blockquote><h1 id="1、环境初始化"><a href="#1、环境初始化" class="headerlink" title="1、环境初始化"></a>1、环境初始化</h1><h2 id="1-1-配置静态IP"><a href="#1-1-配置静态IP" class="headerlink" title="1.1 配置静态IP"></a>1.1 配置静态IP</h2><ul><li><p>查看当前要设置的网卡</p><pre><code class="highlight shell">ip addr</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-133612.png" alt="查看网卡信息"></p></li><li><p>编辑网卡配置</p><pre><code class="highlight shell">vi /etc/NetworkManager/system-connections/ens34.nmconnection</code></pre><ul><li><p>添加如下配置</p><pre><code class="highlight shell">[ipv4]method=manualaddress1=192.168.6.221/24,192.168.6.1dns=114.114.114.114;8.8.8.8</code></pre></li><li><p>配置解析</p><pre><code class="highlight shell">[ipv4]<span class="meta prompt_"># </span><span class="language-bash">ip设置为手动配置</span>method=manual<span class="meta prompt_"># </span><span class="language-bash">设置IP为：192.168.6.222</span><span class="meta prompt_"># </span><span class="language-bash">/24 表示子网掩码为：255.255.255.0</span><span class="meta prompt_"># </span><span class="language-bash">,192.168.6.1 表示网关地址为：192.168.6.1</span>address1=192.168.6.222/24,192.168.6.1<span class="meta prompt_"># </span><span class="language-bash">dns地址</span>dns=114.114.114.114;8.8.8.8</code></pre></li></ul><h2 id="1-2-重启设备和连接配置"><a href="#1-2-重启设备和连接配置" class="headerlink" title="1.2 重启设备和连接配置"></a>1.2 重启设备和连接配置</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">重新应用网络设备 ens34 的当前配置</span>nmcli device reapply ens34<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重新加载 ens34 的网络连接配置。在网络配置文件被手动更改后，通过此命令重新加载连接设置，使更改生效。</span>nmcli connection reload ens34<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">使用 nmcli 命令激活网络设备</span>nmcli device connect ens34<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看IP配置是否成功</span>ip addrping www.baidu.com</code></pre><ul><li><p>其它命令</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">断开网络设备 ens34 的网络连接。</span>nmcli device disconnect ens34<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">激活连接（Connection）如果设备已连接，但未启用对应的网络连接配置，可以激活配置：</span>nmcli connection up ens34<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">检查设备状态</span>nmcli device status<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">如果希望设备在每次系统启动时自动启用，可以执行以下命令：</span>nmcli connection modify ens34 connection.autoconnect yes</code></pre></li></ul></li></ul><h2 id="1-3-更换系统软件源"><a href="#1-3-更换系统软件源" class="headerlink" title="1.3 更换系统软件源"></a>1.3 更换系统软件源</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">更新源</span>sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \    -e &#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27; \    -i.bak /etc/yum.repos.d/[Rr]ocky*.repo    <span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">刷新dnf缓存</span>dnf makecache<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">验证源更新</span>dnf repolist</code></pre><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">使用 sed 命令修改 Rocky Linux 的 YUM/DNF 源配置文件，切换到阿里云的镜像源。</span>sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \    -e &#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27; \    -i.bak /etc/yum.repos.d/[Rr]ocky*.repo    <span class="meta prompt_"># </span><span class="language-bash">将以 mirrorlist= 开头的行注释掉（在前面加 <span class="comment">#）</span></span>-e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">将以 <span class="comment">#baseurl= 开头并指向默认 Rocky Linux 源的行取消注释，并替换为阿里云镜像源 URL。</span></span>&#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">-i.bak：直接修改文件，并为原文件创建备份（扩展名为 .bak）。</span><span class="meta prompt_"># </span><span class="language-bash">修改 /etc/yum.repos.d/ 目录下所有以 rocky 或 Rocky 开头的 .repo 文件。</span><span class="meta prompt_"># </span><span class="language-bash">修改完成后，原始文件会被备份为 .bak 文件。</span>-i.bak /etc/yum.repos.d/[Rr]ocky*.repo<span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">更新本地缓存，确保系统可以快速查询软件包信息。</span>dnf makecache</code></pre></li></ul><h2 id="1-4-修改防火墙"><a href="#1-4-修改防火墙" class="headerlink" title="1.4 修改防火墙"></a>1.4 修改防火墙</h2><p>防火墙修改 firewalld 为 iptables</p><pre><code class="highlight shell">systemctl stop firewalldsystemctl disable firewalldyum -y install iptables-servicessystemctl start iptablesiptables -Fsystemctl enable iptablesservice iptables save</code></pre><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">停止运行 firewalld</span>systemctl stop firewalld<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">禁止 firewalld 开机自启</span>systemctl disable firewalld<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装 iptables 服务，用于管理 Linux 的防火墙规则</span>yum -y install iptables-services<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">使防火墙规则立即生效，并开始运行 iptables 防火墙服务。</span>systemctl start iptables<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">删除当前的防火墙规则，通常用于重置或清理防火墙规则。</span>iptables -F<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置 iptables 服务开机自启动，确保服务器重启后，iptables 服务会自动加载防火墙规则。</span>systemctl enable iptables<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">将当前 iptables 的规则配置保存到文件中（通常是 /etc/sysconfig/iptables），以便在系统重启或 iptables 服务重新启动后，能够自动加载保存的规则。</span>service iptables save</code></pre></li></ul><h2 id="1-5-禁用-Selinux"><a href="#1-5-禁用-Selinux" class="headerlink" title="1.5 禁用 Selinux"></a>1.5 禁用 Selinux</h2><pre><code class="highlight shell">setenforce 0sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/configgrubby --update-kernel ALL --args selinux=0</code></pre><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">将 SELinux 的模式设置为 Permissive（宽容模式）。</span><span class="meta prompt_"># </span><span class="language-bash">0：表示设置为 Permissive 模式，此模式下 SELinux 不会强制执行安全策略，而是记录违规日志。</span><span class="meta prompt_"># </span><span class="language-bash">1：表示 Enforcing 模式，此模式下 SELinux 会强制执行安全策略。</span>setenforce 0<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改 SELinux 配置文件 /etc/selinux/config，将 SELINUX 设置为 disabled。永久禁用 SELinux，即使系统重启也不会再启用。</span>sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">通过 grubby 工具将 selinux=0 参数添加到所有内核启动配置中。</span>grubby --update-kernel ALL --args selinux=0grubby --info DEFAULT<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看是否禁用，</span>grubby --info DEFAULT<span class="meta prompt_"># </span><span class="language-bash">回滚内核层禁用操作，、</span>grubby --update-kernel ALL --remove-args selinux</code></pre></li><li><p>修改完成后重启系统</p><pre><code class="highlight shell">reboot</code></pre></li></ul><h2 id="1-6-设置时区"><a href="#1-6-设置时区" class="headerlink" title="1.6 设置时区"></a>1.6 设置时区</h2><pre><code class="highlight shell">timedatectl set-timezone Asia/Shanghai</code></pre><h1 id="2、安装Docker"><a href="#2、安装Docker" class="headerlink" title="2、安装Docker"></a>2、安装Docker</h1><h2 id="2-1-安装必要的库和网络设置"><a href="#2-1-安装必要的库和网络设置" class="headerlink" title="2.1 安装必要的库和网络设置"></a>2.1 安装必要的库和网络设置</h2><pre><code class="highlight shell">yum install -y epel-releaseyum install -y bridge-utilsmodprobe br_netfilterecho &#x27;br_netfilter&#x27; &gt;&gt; /etc/modules-load.d/bridge.confcat &gt;&gt; /etc/sysctl.conf &lt;&lt;EOFnet.bridge.bridge-nf-call-iptables=1net.bridge.bridge-nf-call-ip6tables=1net.ipv4.ip_forward=1net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_tw_buckets = 20480net.ipv4.tcp_max_syn_backlog = 20480net.core.netdev_max_backlog = 262144net.ipv4.tcp_fin_timeout = 20EOFsysctl -p</code></pre><ul><li><p>命令解释</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">安装 EPEL（Extra Packages <span class="keyword">for</span> Enterprise Linux） 仓库的 Release 包。</span><span class="meta prompt_"># </span><span class="language-bash">EPEL 是由 Fedora 社区维护的一个软件仓库，提供许多额外的软件包，这些包在默认的 RHEL（或其衍生版如 CentOS、Rocky Linux 等）中没有包含。</span>yum install -y epel-release<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装 bridge-utils 软件包。</span><span class="meta prompt_"># </span><span class="language-bash">bridge-utils 是一个 Linux 工具集，用于创建和管理网络桥接（bridging）。</span>yum install -y bridge-utils<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">加载 br_netfilter 内核模块。</span><span class="meta prompt_"># </span><span class="language-bash">该模块用于启用网络桥接（bridge）时的流量过滤功能。</span><span class="meta prompt_"># </span><span class="language-bash">允许通过桥接的网络流量被 iptables 规则管理。</span><span class="meta prompt_"># </span><span class="language-bash">在容器或虚拟化环境中，确保桥接网络的流量可以被正确处理。</span>modprobe br_netfilter<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">将 br_netfilter 模块名称添加到 /etc/modules-load.d/bridge.conf 文件中。</span><span class="meta prompt_"># </span><span class="language-bash">配置系统在启动时自动加载 br_netfilter 模块。</span>echo &#x27;br_netfilter&#x27; &gt;&gt; /etc/modules-load.d/bridge.conf<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">向 /etc/sysctl.conf 文件添加配置，使桥接流量可以通过 iptables 规则管理。</span><span class="meta prompt_"># </span><span class="language-bash">启用桥接网络上的 IPv4 流量通过 iptables 的规则处理。</span>net.bridge.bridge-nf-call-iptables=1<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">向 /etc/sysctl.conf 文件添加配置，使桥接流量中的 IPv6 流量可以通过 ip6tables 规则管理。</span>net.bridge.bridge-nf-call-ip6tables=1<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">向 /etc/sysctl.conf 文件添加配置，启用 IP 转发功能。</span><span class="meta prompt_"># </span><span class="language-bash">用途：在容器网络或 Kubernetes 集群中，允许跨子网通信。</span>net.ipv4.ip_forward=1<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启用 TCP SYN Cookie 技术，用于防范 SYN Flood 攻击。</span><span class="meta prompt_"># </span><span class="language-bash">在服务器收到大量的 TCP SYN 请求但无法分配足够资源时，启用 SYN Cookie 可通过一种临时编码方式验证连接合法性，避免资源耗尽。</span>net.ipv4.tcp_syncookies = 1<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置系统同时保持的 TCP TIME_WAIT 状态的连接数上限。达到上限后，系统会直接丢弃多余的连接（而不是继续占用资源）。</span><span class="meta prompt_"># </span><span class="language-bash">默认值180000,对于高并发的 Web 服务器或反向代理，适当调低该值（如 20480）以避免 TIME_WAIT 数量过多。</span>net.ipv4.tcp_max_tw_buckets = 20480<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置 TCP 三次握手中 SYN 请求的队列长度上限。</span><span class="meta prompt_"># </span><span class="language-bash">当服务器接收的 SYN 请求超过该值时，新的连接请求会被丢弃。</span><span class="meta prompt_"># </span><span class="language-bash">如果服务器负载较高且连接数较多，可以调高到 20480 或更高。</span>net.ipv4.tcp_max_syn_backlog = 20480<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置网络设备接收队列的最大长度。</span><span class="meta prompt_"># </span><span class="language-bash">如果接收队列中的数据包数量超过该值，内核将直接丢弃后续数据包。</span><span class="meta prompt_"># </span><span class="language-bash">在高流量环境中，设置为较高值（如 262144）以避免丢包，提高吞吐量。</span>net.core.netdev_max_backlog = 262144<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置 TCP 连接处于 FIN_WAIT2 状态的超时时间（单位：秒）。</span><span class="meta prompt_"># </span><span class="language-bash">FIN_WAIT2 状态表示服务端已发送 FIN 包等待客户端确认，此状态会持续占用资源。</span><span class="meta prompt_"># </span><span class="language-bash">默认值：通常为 60 秒。</span><span class="meta prompt_"># </span><span class="language-bash">在高并发服务器上，将该值调低（如 20）以减少 FIN_WAIT2 状态的资源占用。</span>net.ipv4.tcp_fin_timeout = 20<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重新加载 /etc/sysctl.conf 中的所有内核参数配置，并使其立即生效。</span>sysctl -p</code></pre></li></ul><h2 id="2-2-安装docker"><a href="#2-2-安装docker" class="headerlink" title="2.2 安装docker"></a>2.2 安装docker</h2><p>添加 docker-ce yum 源</p><pre><code class="highlight shell">sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposudo sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.reposudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">使用 dnf config-manager 命令添加 Docker 软件包的官方仓库（在这里是阿里云的镜像）。</span>sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改 docker-ce.repo 文件中的镜像源地址，将默认的 download.docker.com 替换为阿里云的镜像地址 mirrors.aliyun.com/docker-ce。</span>sudo sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装最新版本docker</span>sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre></li></ul><h2 id="2-3-开启Docker服务"><a href="#2-3-开启Docker服务" class="headerlink" title="2.3 开启Docker服务"></a>2.3 开启Docker服务</h2><pre><code class="highlight shell">systemctl start dockersystemctl enable docker</code></pre><h2 id="2-4-配置-daemon-json"><a href="#2-4-配置-daemon-json" class="headerlink" title="2.4 配置 daemon.json"></a>2.4 配置 daemon.json</h2><pre><code class="highlight shell">cat &gt;&gt;/etc/docker/daemon.json &lt;&lt;EOF&#123;  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;        &quot;max-size&quot;: &quot;100m&quot;,        &quot;max-file&quot;: &quot;10&quot;  &#125;,  &quot;data-root&quot;:&quot;/data/docker&quot;,  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],  &quot;registry-mirrors&quot;: [   &quot;https://kfp63jaj.mirror.aliyuncs.com&quot;,    &quot;https://hub-mirror.c.163.com&quot;,    &quot;https://mirror.baidubce.com&quot;  ]&#125;EOF</code></pre><ul><li><p>配置解析</p><pre><code class="highlight shell">&quot;data-root&quot;: &quot;/data/docker&quot;指定 Docker 数据的存储目录为 /data/docker。包括容器、镜像、卷等内容。默认存储在 /var/lib/docker，此配置用于更改默认路径。&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]配置 Docker 使用 systemd 作为 Cgroup 驱动程序。推荐在使用现代 Linux 发行版（如 Rocky Linux 9）或 Kubernetes 时采用此配置，以实现更好的资源管理和兼容性。&quot;log-driver&quot;: &quot;json-file&quot;指定 Docker 的日志驱动为 json-file。json-file 是 Docker 默认的日志存储方式，将日志保存在 JSON 文件中。&quot;log-opts&quot;: &#123;&#125;配置日志驱动的选项：&quot;max-size&quot;: &quot;100m&quot;：每个日志文件的最大大小为 100MB。&quot;max-file&quot;: &quot;100&quot;：最多保留 100 个日志文件（滚动日志机制）。&quot;insecure-registries&quot;: [&quot;harbor.xinxainghf.com&quot;]配置不安全的私有镜像仓库地址（即未启用 HTTPS 的仓库）。例如，harbor.xinxainghf.com 是一个私有仓库地址。&quot;registry-mirrors&quot;: [&quot;https://kfp63jaj.mirror.aliyuncs.com&quot;]配置 Docker 镜像加速器。镜像地址为阿里云镜像服务，加速从官方 Docker Hub 拉取镜像的速度。</code></pre></li></ul><h2 id="2-5-创建-Docker-服务的自定义配置目录"><a href="#2-5-创建-Docker-服务的自定义配置目录" class="headerlink" title="2.5 创建 Docker 服务的自定义配置目录"></a>2.5 创建 Docker 服务的自定义配置目录</h2><pre><code class="highlight shell">mkdir -p /etc/systemd/system/docker.service.d</code></pre><p>用于存放 Docker 服务的自定义配置文件。</p><h2 id="2-6-重新加载-Docker-配置"><a href="#2-6-重新加载-Docker-配置" class="headerlink" title="2.6 重新加载 Docker 配置"></a>2.6 重新加载 Docker 配置</h2><pre><code class="highlight shell">systemctl daemon-reloadsystemctl restart docker</code></pre><ul><li><p>验证配置是否生效</p><pre><code class="highlight shell">docker info</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RockyLinux：9.3&lt;/p&gt;
&lt;p&gt;镜像下载官网：&lt;a href=&quot;https://rockylinux.org/zh-CN/download&quot;&gt;https://rockylinux</summary>
      
    
    
    
    <category term="k8s" scheme="https://georgechan95.github.io/categories/k8s/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="Docker" scheme="https://georgechan95.github.io/tags/Docker/"/>
    
    <category term="Rocky" scheme="https://georgechan95.github.io/tags/Rocky/"/>
    
  </entry>
  
  <entry>
    <title>001-ESXi8安装Rocky9.3虚拟机</title>
    <link href="https://georgechan95.github.io/blog/7e3a5200.html"/>
    <id>https://georgechan95.github.io/blog/7e3a5200.html</id>
    <published>2025-01-02T01:34:00.000Z</published>
    <updated>2025-01-02T10:53:44.586Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>ESXI：8.0</p><p>RockyLinux：9.3</p><p>镜像下载官网：<a href="https://rockylinux.org/zh-CN/download">https://rockylinux.org/zh-CN/download</a></p><p>镜像下载地址：<a href="https://dl.rockylinux.org/vault/rocky/9.3/isos/x86_64/">https://dl.rockylinux.org/vault/rocky/9.3/isos/x86_64/</a></p><p>安装镜像文件：Rocky-9.3-x86_64-minimal.iso</p></blockquote><h1 id="1、创建虚拟机"><a href="#1、创建虚拟机" class="headerlink" title="1、创建虚拟机"></a>1、创建虚拟机</h1><h2 id="1-1-创建新虚拟机"><a href="#1-1-创建新虚拟机" class="headerlink" title="1.1 创建新虚拟机"></a>1.1 创建新虚拟机</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-111758.png" alt="创建新虚拟机"></p><h2 id="1-2-设置虚拟机名称和操作系统"><a href="#1-2-设置虚拟机名称和操作系统" class="headerlink" title="1.2 设置虚拟机名称和操作系统"></a>1.2 设置虚拟机名称和操作系统</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-111812.png" alt="设置虚拟机名称和操作系统"></p><h2 id="1-3-选择磁盘"><a href="#1-3-选择磁盘" class="headerlink" title="1.3 选择磁盘"></a>1.3 选择磁盘</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-111829.png" alt="选择磁盘"></p><h2 id="1-4-自定义虚拟机硬件设置，选择镜像文件"><a href="#1-4-自定义虚拟机硬件设置，选择镜像文件" class="headerlink" title="1.4 自定义虚拟机硬件设置，选择镜像文件"></a>1.4 自定义虚拟机硬件设置，选择镜像文件</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-111938.png" alt="自定义虚拟机硬件设置，选择镜像文件"></p><h2 id="1-5-查看虚拟机设置"><a href="#1-5-查看虚拟机设置" class="headerlink" title="1.5 查看虚拟机设置"></a>1.5 查看虚拟机设置</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-112008.png" alt="查看虚拟机设置"></p><h1 id="2、开始系统安装"><a href="#2、开始系统安装" class="headerlink" title="2、开始系统安装"></a>2、开始系统安装</h1><h2 id="2-1-打开虚拟机电源"><a href="#2-1-打开虚拟机电源" class="headerlink" title="2.1 打开虚拟机电源"></a>2.1 打开虚拟机电源</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130300.png" alt="打开虚拟机电源"></p><h2 id="2-2-键盘上下键，光标移动到-Install-Rocky-Linux-9-3-，回车开始安装系统"><a href="#2-2-键盘上下键，光标移动到-Install-Rocky-Linux-9-3-，回车开始安装系统" class="headerlink" title="2.2 键盘上下键，光标移动到 Install Rocky Linux 9.3 ，回车开始安装系统"></a>2.2 键盘上下键，光标移动到 Install Rocky Linux 9.3 ，回车开始安装系统</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130444.png" alt="Install Rocky Linux 9.3"></p><h2 id="2-3-等待系统加载"><a href="#2-3-等待系统加载" class="headerlink" title="2.3 等待系统加载"></a>2.3 等待系统加载</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130421.png" alt="等待系统加载"></p><h2 id="2-4-选择语言为中文，目的是这样会自动把时区设置到中国"><a href="#2-4-选择语言为中文，目的是这样会自动把时区设置到中国" class="headerlink" title="2.4 选择语言为中文，目的是这样会自动把时区设置到中国"></a>2.4 选择语言为中文，目的是这样会自动把时区设置到中国</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130501.png" alt="选择语言为中文"></p><h2 id="2-5-设置root和硬盘"><a href="#2-5-设置root和硬盘" class="headerlink" title="2.5 设置root和硬盘"></a>2.5 设置root和硬盘</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130628.png" alt="设置root，和硬盘"></p><h2 id="2-6-设置root密码，允许root远程登录"><a href="#2-6-设置root密码，允许root远程登录" class="headerlink" title="2.6 设置root密码，允许root远程登录"></a>2.6 设置root密码，允许root远程登录</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130711.png" alt="设置root密码，允许root远程登录"></p><h2 id="2-7-选择磁盘"><a href="#2-7-选择磁盘" class="headerlink" title="2.7 选择磁盘"></a>2.7 选择磁盘</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-131738.png" alt="选择磁盘"></p><h2 id="2-8-设置完成后，正式开始安装"><a href="#2-8-设置完成后，正式开始安装" class="headerlink" title="2.8 设置完成后，正式开始安装"></a>2.8 设置完成后，正式开始安装</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130828.png" alt="设置完成后，正式开始安装"></p><h2 id="2-9-等待安装完成"><a href="#2-9-等待安装完成" class="headerlink" title="2.9 等待安装完成"></a>2.9 等待安装完成</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130851.png" alt="等待安装完成"></p><h2 id="2-10-安装完成，重启系统"><a href="#2-10-安装完成，重启系统" class="headerlink" title="2.10 安装完成，重启系统"></a>2.10 安装完成，重启系统</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-131511.png" alt="安装完成，重启系统"></p><h2 id="2-11-等待系统重启中"><a href="#2-11-等待系统重启中" class="headerlink" title="2.11 等待系统重启中"></a>2.11 等待系统重启中</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-131611.png" alt="等待系统重启中"></p><h2 id="2-12-重启完成，开始登录"><a href="#2-12-重启完成，开始登录" class="headerlink" title="2.12 重启完成，开始登录"></a>2.12 重启完成，开始登录</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-131648.png" alt="重启完成，开始登录"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ESXI：8.0&lt;/p&gt;
&lt;p&gt;RockyLinux：9.3&lt;/p&gt;
&lt;p&gt;镜像下载官网：&lt;a href=&quot;https://rockylinux.org/zh-CN/download&quot;&gt;ht</summary>
      
    
    
    
    <category term="k8s" scheme="https://georgechan95.github.io/categories/k8s/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="Rocky" scheme="https://georgechan95.github.io/tags/Rocky/"/>
    
  </entry>
  
  <entry>
    <title>25-责任链模式</title>
    <link href="https://georgechan95.github.io/blog/77d85f50.html"/>
    <id>https://georgechan95.github.io/blog/77d85f50.html</id>
    <published>2024-12-03T13:08:00.000Z</published>
    <updated>2024-12-03T08:57:39.735Z</updated>
    
    <content type="html"><![CDATA[<p><strong>责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</strong></p><p>一、从击鼓传花谈起</p><p>击鼓传花是一种热闹而又紧张的饮酒游戏。在酒宴上宾客依次坐定位置，由一人击鼓，击鼓的地方与传花的地方是分开的，以示公正。开始击鼓时，花束就开始依次传递，鼓声一落，如果花束在某人手中，则该人就得饮酒。</p><p>比如说，贾母、贾赦、贾政、贾宝玉和贾环是五个参加击鼓传花游戏的传花者，他们组成一个环链。击鼓者将花传给贾母，开始传花游戏。花由贾母传给贾赦，由贾赦传给贾政，由贾政传给贾宝玉，又贾宝玉传给贾环，由贾环传回给贾母，如此往复，如下图所示。当鼓声停止时，手中有花的人就得执行酒令。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-155845.png" alt="击鼓传花"></p><p>击鼓传花便是责任链模式的应用。责任链可能是一条直线、一个环链或者一个树结构的一部分。</p><p>二、责任链模式的结构</p><p>下面使用了一个责任链模式的最简单的实现。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-155934.png" alt="责任链模式结构图"></p><p>责任链模式涉及到的角色如下所示：</p><ul><li><p><strong>抽象处理者(Handler)角色：</strong>定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法 <code>handleRequest()</code> 规范了子类处理请求的操作。</p></li><li><p><strong>具体处理者(ConcreteHandler)角色：</strong>具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。</p></li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象处理者角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;    <span class="comment">// 持有后继的责任对象</span>    <span class="keyword">private</span> Handler successor;    <span class="comment">/**</span><span class="comment">     * 处理请求方法的示例，这里没有传参，实际上可根据需要传参</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 获取后继责任对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Handler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;        <span class="keyword">return</span> successor;    &#125;    <span class="comment">/**</span><span class="comment">     * 设置后继责任对象</span><span class="comment">     * <span class="doctag">@param</span> successor</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;        <span class="built_in">this</span>.successor = successor;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体处理者角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;    <span class="comment">/**</span><span class="comment">     * 请求处理方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (getSuccessor() != <span class="literal">null</span>) &#123; <span class="comment">// 如果有后继处理者</span>            System.out.println(<span class="string">&quot;放过请求&quot;</span>);            <span class="comment">// 调用后继处理者，处理请求</span>            getSuccessor().handleRequest();        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 自己处理请求</span>            System.out.println(<span class="string">&quot;处理请求&quot;</span>);        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建责任链上的具体处理者对象</span>        <span class="type">Handler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler</span>();        <span class="type">Handler</span> <span class="variable">handler2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler</span>();        <span class="comment">// 组装责任链</span>        handler1.setSuccessor(handler2);        <span class="comment">// 处理请求</span>        handler1.handleRequest();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">放过请求处理请求</code></pre></blockquote><p>可以看出，客户端创建了两个处理者对象，并指定第一个处理者对象的下家是第二个处理者对象，而第二个处理者对象没有下家。然后客户端将请求传递给第一个处理者对象。</p><p>由于本示例的传递逻辑非常简单：只要有下家，就传给下家处理；如果没有下家，就自行处理。因此，第一个处理者对象接到请求后，会将请求传递给第二个处理者对象。由于第二个处理者对象没有下家，于是自行处理请求。活动时序图如下所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-161859.png" alt="责任链处理时序图"></p><p>二、使用场景</p><p>来考虑这样一个功能: <strong>申请聚餐费用的管理。</strong></p><p>很多公司都是这样的福利，就是项目组或者是部门可以向公司申请一些聚餐费用，用于组织项目组成员或者是部门成员进行聚餐活动。</p><p>申请聚餐费用的大致流程一般是：由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。</p><p>不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。</p><p>也就是说，当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。</p><p>可以使用责任链模式来实现上述功能：当某人提出聚餐费用申请的请求后，该请求会在 <strong>项目经理—〉部门经理—〉总经理</strong> 这样一条领导处理链上进行传递，发出请求的人并不知道谁会来处理他的请求，每个领导会根据自己的职责范围，来判断是处理请求还是把请求交给更高级别的领导，只要有领导处理了，传递就结束了。</p><p>需要把每位领导的处理独立出来，实现成单独的职责处理对象，然后为它们提供一个公共的、抽象的父职责对象，这样就可以在客户端来动态地组合职责链，实现不同的功能要求了。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-162843.png" alt="责任链模式UML"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象处理者角色类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;    <span class="comment">/**</span><span class="comment">     * 持有下一个处理请求的对象</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">/**</span><span class="comment">     * 获取下一个处理请求的对象</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Handler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;        <span class="keyword">return</span> successor;    &#125;    <span class="comment">/**</span><span class="comment">     * 设置下一个处理请求的对象</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> successor</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;        <span class="built_in">this</span>.successor = successor;    &#125;    <span class="comment">/**</span><span class="comment">     * 处理聚餐费用的申请</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> user 申请人</span><span class="comment">     * <span class="doctag">@param</span> fee  申请的钱数</span><span class="comment">     * <span class="doctag">@return</span> 成功或失败的具体通知</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体处理者-项目经理</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span> &#123;        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="comment">//项目经理权限比较小，只能在500以内</span>        <span class="keyword">if</span> (fee &lt; <span class="number">500</span>) &#123;            <span class="comment">//为了测试，简单点，只同意张三的请求</span>            <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span>.equals(user)) &#123;                str = <span class="string">&quot;成功：项目经理同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">//其他人一律不同意</span>                str = <span class="string">&quot;失败：项目经理不同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125;        &#125; <span class="keyword">else</span> &#123;            <span class="comment">//超过500，继续传递给级别更高的人处理</span>            <span class="keyword">if</span> (getSuccessor() != <span class="literal">null</span>) &#123;                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);            &#125;        &#125;        <span class="keyword">return</span> str;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体处理者-部门经理</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span> &#123;        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="comment">//部门经理的权限只能在1000以内</span>        <span class="keyword">if</span> (fee &lt; <span class="number">1000</span>) &#123;            <span class="comment">//为了测试，简单点，只同意张三的请求</span>            <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span>.equals(user)) &#123;                str = <span class="string">&quot;成功：部门经理同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">//其他人一律不同意</span>                str = <span class="string">&quot;失败：部门经理不同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125;        &#125; <span class="keyword">else</span> &#123;            <span class="comment">//超过1000，继续传递给级别更高的人处理</span>            <span class="keyword">if</span> (getSuccessor() != <span class="literal">null</span>) &#123;                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);            &#125;        &#125;        <span class="keyword">return</span> str;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体处理者-总经理</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span> &#123;        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="comment">//总经理的权限很大，只要请求到了这里，他都可以处理</span>        <span class="keyword">if</span> (fee &gt;= <span class="number">1000</span>) &#123;            <span class="comment">//为了测试，简单点，只同意张三的请求</span>            <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span>.equals(user)) &#123;                str = <span class="string">&quot;成功：总经理同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">//其他人一律不同意</span>                str = <span class="string">&quot;失败：总经理不同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125;        &#125; <span class="keyword">else</span> &#123;            <span class="comment">//如果还有后继的处理对象，继续传递</span>            <span class="keyword">if</span> (getSuccessor() != <span class="literal">null</span>) &#123;                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);            &#125;        &#125;        <span class="keyword">return</span> str;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//先要组装责任链</span>        <span class="type">Handler</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();        <span class="type">Handler</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeptManager</span>();        <span class="type">Handler</span> <span class="variable">h3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProjectManager</span>();        h3.setSuccessor(h2);        h2.setSuccessor(h1);        <span class="comment">//开始测试</span>        <span class="type">String</span> <span class="variable">test1</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;张三&quot;</span>, <span class="number">300</span>);        System.out.println(<span class="string">&quot;test1 = &quot;</span> + test1);        <span class="type">String</span> <span class="variable">test2</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;李四&quot;</span>, <span class="number">300</span>);        System.out.println(<span class="string">&quot;test2 = &quot;</span> + test2);        System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);        <span class="type">String</span> <span class="variable">test3</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;张三&quot;</span>, <span class="number">700</span>);        System.out.println(<span class="string">&quot;test3 = &quot;</span> + test3);        <span class="type">String</span> <span class="variable">test4</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;李四&quot;</span>, <span class="number">700</span>);        System.out.println(<span class="string">&quot;test4 = &quot;</span> + test4);        System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);        <span class="type">String</span> <span class="variable">test5</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;张三&quot;</span>, <span class="number">1500</span>);        System.out.println(<span class="string">&quot;test5 = &quot;</span> + test5);        <span class="type">String</span> <span class="variable">test6</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;李四&quot;</span>, <span class="number">1500</span>);        System.out.println(<span class="string">&quot;test6 = &quot;</span> + test6);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">test1 = 成功：项目经理同意【张三】的聚餐费用，金额为300.0元test2 = 失败：项目经理不同意【李四】的聚餐费用，金额为300.0元---------------------------------------test3 = 成功：部门经理同意【张三】的聚餐费用，金额为700.0元test4 = 失败：部门经理不同意【李四】的聚餐费用，金额为700.0元---------------------------------------test5 = 成功：总经理同意【张三】的聚餐费用，金额为1500.0元test6 = 失败：总经理不同意【李四】的聚餐费用，金额为1500.0元</code></pre></blockquote><p>三、纯的与不纯的责任链模式</p><ul><li><p>一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又 把责任向下传的情况。</p></li><li><p>在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。</p></li><li><p>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。有些人认为不纯的责任链根本不是责任链模式，这也许是有道理的。但是在实际的系统里，纯的责任链很难找到。如果坚持责任链不纯便不是责任链模式，那么责任链模式便不会有太大意义了。</p></li></ul><p>四、责任链模式在Tomcat中的应用</p><p>众所周知Tomcat中的Filter就是使用了责任链模式，创建一个Filter除了要在web.xml文件中做相应配置外，还需要实现javax.servlet.Filter接口。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;                chain.doFilter(request, response);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;    &#125;&#125;</code></pre><p>使用DEBUG模式所看到的结果如下</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-164526.png" alt="Filter责任链"></p><p>其实在真正执行到TestFilter类之前，会经过很多Tomcat内部的类。<strong>顺带提一下其实Tomcat的容器设置也是责任链模式，注意被红色方框所圈中的类，从Engine到Host再到Context一直到Wrapper都是通过一个链传递请求</strong>。被绿色方框所圈中的地方有一个名为ApplicationFilterChain的类，ApplicationFilterChain类所扮演的就是抽象处理者角色，而具体处理者角色由各个Filter扮演。</p><p><em>第一个疑问是ApplicationFilterChain将所有的Filter存放在哪里？</em></p><p>答案是保存在ApplicationFilterChain类中的一个ApplicationFilterConfig对象的数组中。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Filters.</span><span class="comment"> */</span><span class="keyword">private</span> ApplicationFilterConfig[] filters =     <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[<span class="number">0</span>];</code></pre><p><em>那ApplicationFilterConfig对象又是什么呢？</em></p><p>ApplicationFilterConfig是一个Filter容器。以下是ApplicationFilterConfig类的声明：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Implementation of a &lt;code&gt;javax.servlet.FilterConfig&lt;/code&gt; useful in</span><span class="comment"> * managing the filter instances instantiated when a web application</span><span class="comment"> * is first started.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@author</span> Craig R. McClanahan</span><span class="comment"> * <span class="doctag">@version</span> $Id: ApplicationFilterConfig.java 1201569 2011-11-14 01:36:07Z kkolinko $</span><span class="comment"> */</span></code></pre><p>当一个web应用首次启动时ApplicationFilterConfig会自动实例化，它会从该web应用的web.xml文件中读取配置的Filter的信息，然后装进该容器。</p><p><em>刚刚看到在ApplicationFilterChain类中所创建的ApplicationFilterConfig数组长度为零，那它是在什么时候被重新赋值的呢？</em></p><pre><code class="highlight java"><span class="keyword">private</span> ApplicationFilterConfig[] filters =         <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[<span class="number">0</span>];</code></pre><p>是在调用ApplicationFilterChain类的addFilter()方法时。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * The int which gives the current number of filters in the chain.</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INCREMENT</span> <span class="operator">=</span> <span class="number">10</span>;</code></pre><pre><code class="highlight java"><span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> &#123;    <span class="comment">// Prevent the same filter being added multiple times</span>    <span class="keyword">for</span>(ApplicationFilterConfig filter:filters)        <span class="keyword">if</span>(filter==filterConfig)            <span class="keyword">return</span>;    <span class="keyword">if</span> (n == filters.length) &#123;        ApplicationFilterConfig[] newFilters =            <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[n + INCREMENT];        System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);        filters = newFilters;    &#125;    filters[n++] = filterConfig;&#125;</code></pre><p>变量n用来记录当前过滤器链里面拥有的过滤器数目，默认情况下n等于0，ApplicationFilterConfig对象数组的长度也等于0，所以当第一次调用addFilter()方法时，if (n &#x3D;&#x3D; filters.length)的条件成立，ApplicationFilterConfig数组长度被改变。之后filters[n++] &#x3D; filterConfig;将变量filterConfig放入ApplicationFilterConfig数组中并将当前过滤器链里面拥有的过滤器数目+1。</p><p><em>那ApplicationFilterChain的addFilter()方法又是在什么地方被调用的呢？</em></p><p>是在ApplicationFilterFactory类的createFilterChain()方法中。</p><pre><code class="highlight java"><span class="keyword">public</span> ApplicationFilterChain <span class="title function_">createFilterChain</span>        <span class="params">(ServletRequest request, Wrapper wrapper, Servlet servlet)</span> &#123;    <span class="comment">// get the dispatcher type</span>    <span class="type">DispatcherType</span> <span class="variable">dispatcher</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">if</span> (request.getAttribute(DISPATCHER_TYPE_ATTR) != <span class="literal">null</span>) &#123;        dispatcher = (DispatcherType) request.getAttribute(DISPATCHER_TYPE_ATTR);    &#125;    <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> request.getAttribute(DISPATCHER_REQUEST_PATH_ATTR);    <span class="keyword">if</span> (attribute != <span class="literal">null</span>)&#123;        requestPath = attribute.toString();    &#125;    <span class="comment">// If there is no servlet to execute, return null</span>    <span class="keyword">if</span> (servlet == <span class="literal">null</span>)        <span class="keyword">return</span> (<span class="literal">null</span>);    <span class="type">boolean</span> <span class="variable">comet</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="comment">// Create and initialize a filter chain object</span>    <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> Request) &#123;        <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) request;        comet = req.isComet();        <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;            <span class="comment">// Security: Do not recycle</span>            filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();            <span class="keyword">if</span> (comet) &#123;                req.setFilterChain(filterChain);            &#125;        &#125; <span class="keyword">else</span> &#123;            filterChain = (ApplicationFilterChain) req.getFilterChain();            <span class="keyword">if</span> (filterChain == <span class="literal">null</span>) &#123;                filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();                req.setFilterChain(filterChain);            &#125;        &#125;    &#125; <span class="keyword">else</span> &#123;        <span class="comment">// Request dispatcher in use</span>        filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();    &#125;    filterChain.setServlet(servlet);    filterChain.setSupport        (((StandardWrapper)wrapper).getInstanceSupport());    <span class="comment">// Acquire the filter mappings for this Context</span>    <span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span> (StandardContext) wrapper.getParent();    FilterMap filterMaps[] = context.findFilterMaps();    <span class="comment">// If there are no filter mappings, we are done</span>    <span class="keyword">if</span> ((filterMaps == <span class="literal">null</span>) || (filterMaps.length == <span class="number">0</span>))        <span class="keyword">return</span> (filterChain);    <span class="comment">// Acquire the information we will need to match filter mappings</span>    <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> wrapper.getName();    <span class="comment">// Add the relevant path-mapped filters to this filter chain</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;        <span class="keyword">if</span> (!matchDispatcher(filterMaps[i] ,dispatcher)) &#123;            <span class="keyword">continue</span>;        &#125;        <span class="keyword">if</span> (!matchFiltersURL(filterMaps[i], requestPath))            <span class="keyword">continue</span>;        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig)            context.findFilterConfig(filterMaps[i].getFilterName());        <span class="keyword">if</span> (filterConfig == <span class="literal">null</span>) &#123;            <span class="comment">// FIXME - log configuration problem</span>            <span class="keyword">continue</span>;        &#125;        <span class="type">boolean</span> <span class="variable">isCometFilter</span> <span class="operator">=</span> <span class="literal">false</span>;        <span class="keyword">if</span> (comet) &#123;            <span class="keyword">try</span> &#123;                isCometFilter = filterConfig.getFilter() <span class="keyword">instanceof</span> CometFilter;            &#125; <span class="keyword">catch</span> (Exception e) &#123;                <span class="comment">// Note: The try catch is there because getFilter has a lot of</span>                <span class="comment">// declared exceptions. However, the filter is allocated much</span>                <span class="comment">// earlier</span>                <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> ExceptionUtils.unwrapInvocationTargetException(e);                ExceptionUtils.handleThrowable(t);            &#125;            <span class="keyword">if</span> (isCometFilter) &#123;                filterChain.addFilter(filterConfig);            &#125;        &#125; <span class="keyword">else</span> &#123;            filterChain.addFilter(filterConfig);        &#125;    &#125;    <span class="comment">// Add filters that match on servlet name second</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;        <span class="keyword">if</span> (!matchDispatcher(filterMaps[i] ,dispatcher)) &#123;            <span class="keyword">continue</span>;        &#125;        <span class="keyword">if</span> (!matchFiltersServlet(filterMaps[i], servletName))            <span class="keyword">continue</span>;        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig)            context.findFilterConfig(filterMaps[i].getFilterName());        <span class="keyword">if</span> (filterConfig == <span class="literal">null</span>) &#123;            <span class="comment">// FIXME - log configuration problem</span>            <span class="keyword">continue</span>;        &#125;        <span class="type">boolean</span> <span class="variable">isCometFilter</span> <span class="operator">=</span> <span class="literal">false</span>;        <span class="keyword">if</span> (comet) &#123;            <span class="keyword">try</span> &#123;                isCometFilter = filterConfig.getFilter() <span class="keyword">instanceof</span> CometFilter;            &#125; <span class="keyword">catch</span> (Exception e) &#123;                <span class="comment">// Note: The try catch is there because getFilter has a lot of</span>                <span class="comment">// declared exceptions. However, the filter is allocated much</span>                <span class="comment">// earlier</span>            &#125;            <span class="keyword">if</span> (isCometFilter) &#123;                filterChain.addFilter(filterConfig);            &#125;        &#125; <span class="keyword">else</span> &#123;            filterChain.addFilter(filterConfig);        &#125;    &#125;    <span class="comment">// Return the completed filter chain</span>    <span class="keyword">return</span> (filterChain);&#125;</code></pre><p>可以将如上代码分为两段，51行之前为第一段( <code>StandardContext context = (StandardContext) wrapper.getParent();</code> )，51行之后为第二段。</p><p>第一段的主要目的是创建ApplicationFilterChain对象以及一些参数设置。</p><p>第二段的主要目的是从上下文中获取所有Filter信息，之后使用for循环遍历并调用 <code>filterChain.addFilter(filterConfig);</code> 将filterConfig放入ApplicationFilterChain对象的ApplicationFilterConfig数组中。</p><p>那ApplicationFilterFactory类的createFilterChain()方法又是在什么地方被调用的呢？</p><p>是在StandardWrapperValue类的invoke()方法中被调用的。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-165319.png" alt="StandardWrapperValue"></p><p>由于invoke()方法较长，所以将很多地方省略。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span>        <span class="keyword">throws</span> IOException, ServletException &#123;...省略中间代码　　　　 <span class="comment">// Create the filter chain for this request</span>    <span class="type">ApplicationFilterFactory</span> <span class="variable">factory</span> <span class="operator">=</span>        ApplicationFilterFactory.getInstance();    <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span>        factory.createFilterChain(request, wrapper, servlet);...省略中间代码     filterChain.doFilter(request.getRequest(), response.getResponse());...省略中间代码&#125;</code></pre><p>那正常的流程应该是这样的：</p><p>在<code>StandardWrapperValue</code>类的<code>invoke()</code>方法中调用<code>ApplicationFilterChai</code>类的<code>createFilterChain()</code>方法———&gt;在<code>ApplicationFilterChai</code>类的<code>createFilterChain()</code>方法中调用<code>ApplicationFilterChain</code>类的<code>addFilter()</code>方法———&gt;在<code>ApplicationFilterChain</code>类的<code>addFilter()</code>方法中给<code>ApplicationFilterConfig</code>数组赋值。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-165514.png" alt="调用流程"></p><p>根据上面的代码可以看出StandardWrapperValue类的invoke()方法在执行完createFilterChain()方法后，会继续执行ApplicationFilterChain类的doFilter()方法，然后在doFilter()方法中会调用internalDoFilter()方法。</p><p>以下是internalDoFilter()方法的部分代码</p><pre><code class="highlight java"><span class="comment">// Call the next filter if there is one</span><span class="keyword">if</span> (pos &lt; n) &#123;　　　　　　　<span class="comment">//拿到下一个Filter，将指针向下移动一位            //pos它来标识当前ApplicationFilterChain（当前过滤器链）执行到哪个过滤器</span>    <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];    <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">try</span> &#123;　　　　　　　　　 <span class="comment">//获取当前指向的Filter的实例</span>        filter = filterConfig.getFilter();        support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,                                  filter, request, response);        <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; <span class="string">&quot;false&quot;</span>.equalsIgnoreCase(                filterConfig.getFilterDef().getAsyncSupported())) &#123;            request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,                    Boolean.FALSE);        &#125;        <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;            <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;            <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;            <span class="type">Principal</span> <span class="variable">principal</span> <span class="operator">=</span>                 ((HttpServletRequest) req).getUserPrincipal();            Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;req, res, <span class="built_in">this</span>&#125;;            SecurityUtil.doAsPrivilege                (<span class="string">&quot;doFilter&quot;</span>, filter, classType, args, principal);        &#125; <span class="keyword">else</span> &#123;　　　　　　　　　　　　<span class="comment">//调用Filter的doFilter()方法  </span>            filter.doFilter(request, response, <span class="built_in">this</span>);        &#125;</code></pre><p>这里的filter.doFilter(request, response, this);就是调用我们前面创建的TestFilter中的doFilter()方法。而TestFilter中的doFilter()方法会继续调用chain.doFilter(request, response);方法，而这个chain其实就是ApplicationFilterChain,所以调用过程又回到了上面调用dofilter和调用internalDoFilter方法，这样执行直到里面的过滤器全部执行。</p><p>如果定义两个过滤器，则Debug结果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-165659.png" alt="Debug"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>24-策略模式</title>
    <link href="https://georgechan95.github.io/blog/fcec839d.html"/>
    <id>https://georgechan95.github.io/blog/fcec839d.html</id>
    <published>2024-12-02T10:16:00.000Z</published>
    <updated>2024-12-03T05:08:38.752Z</updated>
    
    <content type="html"><![CDATA[<p><strong>策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。</strong></p><h1 id="一、策略模式的结构"><a href="#一、策略模式的结构" class="headerlink" title="一、策略模式的结构"></a>一、策略模式的结构</h1><p>策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-123412.png" alt="策略模式结构"></p><p>这个模式涉及到三个角色：</p><ul><li><strong>环境(Context)角色：</strong>持有一个Strategy的引用。</li><li><strong>抽象策略(Strategy)角色：</strong>这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li><strong>具体策略(ConcreteStrategy)角色：</strong>包装了相关的算法或行为。</li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 环境角色类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;    <span class="comment">// 持有一个具体的策略对象</span>    <span class="keyword">private</span> Strategy strategy;    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;        <span class="built_in">this</span>.strategy = strategy;    &#125;    <span class="comment">/**</span><span class="comment">     * 调用策略方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInterface</span><span class="params">()</span> &#123;        strategy.strategyInterface();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象策略类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;    <span class="comment">/**</span><span class="comment">     * 策略方法</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体策略类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span> &#123;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体策略类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span> &#123;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体策略类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span> &#123;    &#125;&#125;</code></pre><h1 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h1><p>假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。</p><p>根据描述，折扣是根据以下的几个算法中的一个进行的：</p><ul><li>算法一：对初级会员没有折扣。</li><li>算法二：对中级会员提供10%的促销折扣。</li><li>算法三：对高级会员提供20%的促销折扣。</li></ul><p>使用策略模式来实现的结构图如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-125237.png" alt="策略模式UML"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象折扣类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MemberStrategy</span> &#123;    <span class="comment">/**</span><span class="comment">     * 计算图书的价格</span><span class="comment">     * <span class="doctag">@param</span> booksPrice 图书的原价</span><span class="comment">     * <span class="doctag">@return</span> 计算出打折后的价格</span><span class="comment">     */</span>    <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(<span class="type">double</span> booksPrice)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 初级会员折扣类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimaryMemberStrategy</span> <span class="keyword">implements</span> <span class="title class_">MemberStrategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(<span class="type">double</span> booksPrice)</span> &#123;        System.out.println(<span class="string">&quot;对于初级会员的没有折扣&quot;</span>);        <span class="keyword">return</span> booksPrice;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 中级会员折扣类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntermediateMemberStrategy</span> <span class="keyword">implements</span> <span class="title class_">MemberStrategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(<span class="type">double</span> booksPrice)</span> &#123;        System.out.println(<span class="string">&quot;对于中级会员的折扣为10%&quot;</span>);        <span class="keyword">return</span> booksPrice * <span class="number">0.9</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 高级会员折扣类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvancedMemberStrategy</span> <span class="keyword">implements</span> <span class="title class_">MemberStrategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(<span class="type">double</span> booksPrice)</span> &#123;        System.out.println(<span class="string">&quot;对于高级会员的折扣为20%&quot;</span>);        <span class="keyword">return</span> booksPrice * <span class="number">0.8</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 价格计算类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Price</span> &#123;    <span class="comment">// 持有一个具体的策略对象</span>    <span class="keyword">private</span> MemberStrategy memberStrategy;    <span class="keyword">public</span> <span class="title function_">Price</span><span class="params">(MemberStrategy memberStrategy)</span> &#123;        <span class="built_in">this</span>.memberStrategy = memberStrategy;    &#125;    <span class="comment">/**</span><span class="comment">     * 计算图书的价格</span><span class="comment">     * <span class="doctag">@param</span> booksPrice 图书的原价</span><span class="comment">     * <span class="doctag">@return</span> 计算出打折后的价格</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">quote</span><span class="params">(<span class="type">double</span> booksPrice)</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.memberStrategy.calcPrice(booksPrice);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//选择并创建需要使用的策略对象</span>        <span class="type">MemberStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvancedMemberStrategy</span>();        <span class="comment">//创建环境</span>        <span class="type">Price</span> <span class="variable">price</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Price</span>(strategy);        <span class="comment">//计算价格</span>        <span class="type">double</span> <span class="variable">quote</span> <span class="operator">=</span> price.quote(<span class="number">300</span>);        System.out.println(<span class="string">&quot;图书的最终价格为：&quot;</span> + quote);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">对于高级会员的折扣为20%图书的最终价格为：240.0</code></pre></blockquote><p>从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。</p><h1 id="三、认识策略模式"><a href="#三、认识策略模式" class="headerlink" title="三、认识策略模式"></a>三、认识策略模式</h1><ul><li><p><strong>策略模式的重心</strong></p><p>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p></li><li><p><strong>算法的平等性</strong></p><p>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p><p>所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。</p></li><li><p><strong>运行时策略的唯一性</strong></p><p>运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p></li><li><p><strong>公有的行为</strong></p><p>经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。</p><p>这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-130623.png" alt="使用抽象类实现共有行为"></p></li></ul><h1 id="四、策略模式的优-缺点"><a href="#四、策略模式的优-缺点" class="headerlink" title="四、策略模式的优&#x2F;缺点"></a>四、策略模式的优&#x2F;缺点</h1><ul><li>优点<ul><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后</li></ul></li><li>缺点<ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</li><li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、策略模式的结构&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23-状态模式</title>
    <link href="https://georgechan95.github.io/blog/6109865a.html"/>
    <id>https://georgechan95.github.io/blog/6109865a.html</id>
    <published>2024-11-29T11:30:00.000Z</published>
    <updated>2024-11-30T09:49:58.580Z</updated>
    
    <content type="html"><![CDATA[<p><strong>状态模式，又称状态对象模式（Pattern of Objects for States），状态模式是对象的行为模式。</strong></p><p><strong>状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。</strong></p><h1 id="一、状态模式的结构"><a href="#一、状态模式的结构" class="headerlink" title="一、状态模式的结构"></a>一、状态模式的结构</h1><p>用一句话来表述，状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式的示意性类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-164732.png" alt="状态模式结构"></p><p>状态模式所涉及到的角色有：</p><ul><li>环境(Context)角色，也称上下文：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。</li><li>抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为。</li><li>具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。</li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象状态接口, 定义具体状态类共用的处理方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;    <span class="comment">/**</span><span class="comment">     * 状态对应的处理</span><span class="comment">     * <span class="doctag">@param</span> sampleParameter 相同的参数</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String sampleParameter)</span>;&#125;<span class="comment">/***</span><span class="comment"> * 环境角色类， 当内部状态（state）改变的时候，行为（request）也发生了改变</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;    <span class="comment">// 持有一个State类型的对象实例</span>    <span class="keyword">private</span> State state;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;        <span class="built_in">this</span>.state = state;    &#125;    <span class="comment">/**</span><span class="comment">     * 请求的方法</span><span class="comment">     * <span class="doctag">@param</span> sampleParameter</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(String sampleParameter)</span> &#123;        state.handle(sampleParameter);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态类A</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String sampleParameter)</span> &#123;        System.out.println(<span class="string">&quot;ConcreteStateA handle : &quot;</span> + sampleParameter);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态类B</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String sampleParameter)</span> &#123;        System.out.println(<span class="string">&quot;ConcreteStateB handle : &quot;</span> + sampleParameter);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建一个State对象</span>        <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStateA</span>();        <span class="comment">// 创建环境</span>        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();        <span class="comment">// 将状态设置到环境中</span>        context.setState(state);        <span class="comment">// 调用请求</span>        context.request(<span class="string">&quot;param A&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">ConcreteStateA handle : param A</code></pre></blockquote><p>从上面可以看出，环境类 <code>Context</code> 的行为<code>request()</code>是委派给某一个具体状态类的。通过使用多态性原则，可以动态改变环境类<code>Context</code>的属性<code>State</code>的内容，使其从指向一个具体状态类变换到指向另一个具体状态类，从而使环境类的行为<code>request(</code>)由不同的具体状态类来执行。</p><h1 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h1><p>考虑一个在线投票系统的应用，要实现控制同一个用户只能投一票，如果一个用户反复投票，而且投票次数超过5次，则判定为恶意刷票，要取消该用户投票的资格，当然同时也要取消他所投的票；如果一个用户的投票次数超过8次，将进入黑名单，禁止再登录和使用系统。</p><p>要使用状态模式实现，首先需要把投票过程的各种状态定义出来，根据以上描述大致分为四种状态：正常投票、反复投票、恶意刷票、进入黑名单。然后创建一个投票管理对象（相当于Context）。</p><p>系统的结构图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-172729.png" alt="状态模式UML"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象状态类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VoteState</span> &#123;    <span class="comment">/**</span><span class="comment">     * 不同状态共有的投票方法</span><span class="comment">     * <span class="doctag">@param</span> user 投票人</span><span class="comment">     * <span class="doctag">@param</span> voteItem 投票项目</span><span class="comment">     * <span class="doctag">@param</span> voteManager 投票上下文，用来在实现状态对应的功能处理的时候，可以回调上下文的数据</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem, VoteManager voteManager)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态：正常投票</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalVoteState</span> <span class="keyword">implements</span> <span class="title class_">VoteState</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem, VoteManager voteManager)</span> &#123;        <span class="comment">//正常投票，记录到投票记录中</span>        Map&lt;String, String&gt; mapVote = voteManager.getMapVote();        mapVote.put(user, voteItem);        System.out.println(<span class="string">&quot;投票成功&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态：重复投票</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatVoteState</span> <span class="keyword">implements</span> <span class="title class_">VoteState</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem, VoteManager voteManager)</span> &#123;        System.out.println(<span class="string">&quot;请不要重复投票&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态：恶意刷票</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpiteVoteState</span> <span class="keyword">implements</span> <span class="title class_">VoteState</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem, VoteManager voteManager)</span> &#123;        Map&lt;String, String&gt; mapVote = voteManager.getMapVote();        <span class="keyword">if</span> (mapVote.get(user) != <span class="literal">null</span>) &#123;            mapVote.remove(user);        &#125;        System.out.println(<span class="string">&quot;你有恶意刷屏行为，取消投票资格&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态类：进入黑名单</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackVoteState</span> <span class="keyword">implements</span> <span class="title class_">VoteState</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem, VoteManager voteManager)</span> &#123;        <span class="comment">//记录黑名单中，禁止登录系统</span>        System.out.println(<span class="string">&quot;进入黑名单，将禁止登录和使用本系统&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 环境类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoteManager</span> &#123;    <span class="comment">// 持有的状态处理对象</span>    <span class="keyword">private</span> <span class="type">VoteState</span> <span class="variable">state</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// 记录用户投票的结果，Map&lt;String,String&gt;对应Map&lt;用户名称，投票的选项&gt;</span>    <span class="keyword">private</span> Map&lt;String, String&gt; mapVote = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">// 记录用户投票次数，Map&lt;String,Integer&gt;对应Map&lt;用户名称，投票的次数&gt;</span>    <span class="keyword">private</span> Map&lt;String, Integer&gt; mapVoteCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 获取用户投票结果的Map</span><span class="comment">     */</span>    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getMapVote</span><span class="params">()</span> &#123;        <span class="keyword">return</span> mapVote;    &#125;    <span class="comment">/**</span><span class="comment">     * 投票方法</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> user     投票人</span><span class="comment">     * <span class="doctag">@param</span> voteItem 投票项</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem)</span> &#123;        <span class="comment">// 1.为该用户增加投票次数</span>        <span class="type">Integer</span> <span class="variable">voteCount</span> <span class="operator">=</span> mapVoteCount.get(user);        <span class="keyword">if</span> (voteCount == <span class="literal">null</span>) &#123;            voteCount = <span class="number">0</span>;        &#125;        voteCount++;        mapVoteCount.put(user, voteCount);        <span class="comment">// 2.判断该用户的投票类型，就相当于判断对应的状态</span>        <span class="keyword">if</span> (voteCount == <span class="number">1</span>) &#123; <span class="comment">// 正常投票</span>            state = <span class="keyword">new</span> <span class="title class_">NormalVoteState</span>();        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (voteCount &gt; <span class="number">1</span> &amp;&amp; voteCount &lt; <span class="number">5</span>) &#123; <span class="comment">// 重复投票</span>            state = <span class="keyword">new</span> <span class="title class_">RepeatVoteState</span>();        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (voteCount &gt;= <span class="number">5</span> &amp;&amp; voteCount &lt; <span class="number">8</span>) &#123; <span class="comment">// 恶意刷票</span>            state = <span class="keyword">new</span> <span class="title class_">SpiteVoteState</span>();        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (voteCount &gt; <span class="number">8</span>) &#123; <span class="comment">// 黑名单</span>            state = <span class="keyword">new</span> <span class="title class_">BlackVoteState</span>();        &#125;        <span class="comment">// 调用状态接口方法，进行投票</span>        state.vote(user, voteItem, <span class="built_in">this</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">VoteManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoteManager</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;            vm.vote(<span class="string">&quot;George&quot;</span>, <span class="string">&quot;A&quot;</span>);        &#125;    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">投票成功请不要重复投票请不要重复投票请不要重复投票你有恶意刷屏行为，取消投票资格你有恶意刷屏行为，取消投票资格你有恶意刷屏行为，取消投票资格你有恶意刷屏行为，取消投票资格进入黑名单，将禁止登录和使用本系统</code></pre></blockquote><p>从上面的示例可以看出，状态的转换基本上都是内部行为，主要在状态模式内部来维护。比如对于投票的人员，任何时候他的操作都是投票，但是投票管理对象的处理却不一定一样，会根据投票的次数来判断状态，然后根据状态去选择不同的处理。</p><h1 id="三、认识状态模式"><a href="#三、认识状态模式" class="headerlink" title="三、认识状态模式"></a>三、认识状态模式</h1><ul><li><p><strong>状态和行为</strong></p><p>所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。</p><p>状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：<strong>状态决定行为</strong>。</p><p>由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。</p></li><li><p><strong>行为的平行性</strong></p><p>注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-174703.png" alt="状态的平行性示意图"></p><p>而平等性强调的是可替换性，大家是同一行为的不同描述或实现，因此在同一个行为发生的时候，可以根据条件挑选任意一个实现来进行相应的处理。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-174758.png" alt="平等性"></p><p>大家可能会发现状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。</p></li><li><p><strong>环境和状态处理对象</strong></p><ul><li>在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。</li><li>在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。</li><li>客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;状态模式，又称状态对象模式（Pattern of Objects for States），状态模式是对象的行为模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>22-解释器模式</title>
    <link href="https://georgechan95.github.io/blog/58d4db7.html"/>
    <id>https://georgechan95.github.io/blog/58d4db7.html</id>
    <published>2024-11-28T14:00:00.000Z</published>
    <updated>2024-11-30T08:03:09.600Z</updated>
    
    <content type="html"><![CDATA[<p><strong>解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。</strong></p><p>一、解释器模式的结构</p><p>下面就以一个示意性的系统为例，讨论解释器模式的结构。系统的结构图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-144657.png" alt="解释器模式结构"></p><p>模式所涉及的角色如下所示：</p><ul><li><strong>抽象表达式(Expression)角色：</strong>声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。</li><li><strong>终结符表达式(Terminal Expression)角色：</strong>实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R&#x3D;R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。</li><li><strong>非终结符表达式(Nonterminal Expression)角色：</strong>文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R&#x3D;R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。</li><li><strong>环境(Context)角色：</strong>这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R&#x3D;R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。</li></ul><p>为了说明解释器模式的实现办法，这里给出一个最简单的文法和对应的解释器模式的实现，这就是模拟Java语言中对布尔表达式进行操作和求值。</p><p>在这个语言中终结符是布尔变量，也就是常量true和false。非终结符表达式包含运算符and，or和not等布尔表达式。这个简单的文法如下：</p><p><strong>Expression::&#x3D; Constant | Variable | Or | And | Not</strong></p><p><strong>And::&#x3D; Expression ‘AND’ Expression</strong></p><p><strong>Or   ::&#x3D; Expression ‘OR’ Expression</strong></p><p><strong>Not  ::&#x3D; ‘NOT’ Expression</strong></p><p><strong>Variable  ::&#x3D; 任何标识符</strong></p><p><strong>Constant ::&#x3D; ‘true’ | ‘false’</strong></p><p>解释器模式的结构图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-145645.png" alt="解释器模式结构UML"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象表达式角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Expression</span> &#123;    <span class="comment">/**</span><span class="comment">     * 以环境为准，本方法解释给定的任何一个表达式</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span>;    <span class="comment">/**</span><span class="comment">     * 检验两个表达式在结构上是否相同</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;    <span class="comment">/**</span><span class="comment">     * 返回表达式的hash code</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 将表达式转换成字符串</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">toString</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 一个Constant对象代表一个布尔常量</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;    <span class="keyword">private</span> <span class="type">boolean</span> value;    <span class="keyword">public</span> <span class="title function_">Constant</span><span class="params">(<span class="type">boolean</span> value)</span> &#123;        <span class="built_in">this</span>.value = value;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;        <span class="keyword">return</span> value;    &#125;    <span class="comment">/**</span><span class="comment">     * 检验两个表达式在结构上是否相同</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Constant) &#123;            <span class="keyword">return</span> <span class="built_in">this</span>.value == ((Constant) obj).value;        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.toString().hashCode();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(value).toString();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 一个Variable对象代表一个有名变量</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">Variable</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;        <span class="comment">// 获取变量对应的值</span>        <span class="type">boolean</span> <span class="variable">value</span> <span class="operator">=</span> ctx.lookup(<span class="built_in">this</span>);        <span class="keyword">return</span> value;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Variable) &#123;            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(((Variable)obj).name);        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.toString().hashCode();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.name;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 代表逻辑“与”操作的And类，表示由两个布尔表达式通过逻辑“与”操作给出一个新的布尔表达式的操作</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">And</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;    <span class="keyword">private</span> Expression left, right;    <span class="keyword">public</span> <span class="title function_">And</span><span class="params">(Expression left, Expression right)</span> &#123;        <span class="built_in">this</span>.left = left;        <span class="built_in">this</span>.right = right;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;        <span class="keyword">return</span> left.interpret(ctx) &amp;&amp; right.interpret(ctx);    &#125;    <span class="comment">/**</span><span class="comment">     * 检验两个表达式在结构上是否相同</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> And) &#123;            <span class="keyword">return</span> left.equals(((And) obj).left) &amp;&amp;                    right.equals(((And) obj).right);        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.toString().hashCode();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; AND &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 代表逻辑“或”操作的Or类，代表由两个布尔表达式通过逻辑“或”操作给出一个新的布尔表达式的操作</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Or</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;    <span class="keyword">private</span> Expression left, right;    <span class="keyword">public</span> <span class="title function_">Or</span><span class="params">(Expression left, Expression right)</span> &#123;        <span class="built_in">this</span>.left = left;        <span class="built_in">this</span>.right = right;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;        <span class="keyword">return</span> left.interpret(ctx) || right.interpret(ctx);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Or) &#123;            <span class="keyword">return</span> <span class="built_in">this</span>.left.equals(((Or) obj).left)                    &amp;&amp; <span class="built_in">this</span>.right.equals(((Or) obj).right);        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.toString().hashCode();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; OR &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 代表逻辑“非”操作的Not类，代表由一个布尔表达式通过逻辑“非”操作给出一个新的布尔表达式的操作</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Not</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;    <span class="keyword">private</span> Expression exp;    <span class="keyword">public</span> <span class="title function_">Not</span><span class="params">(Expression exp)</span> &#123;        <span class="built_in">this</span>.exp = exp;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;        <span class="keyword">return</span> !exp.interpret(ctx);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Not) &#123;            <span class="keyword">return</span> exp.equals(                    ((Not) obj).exp);        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.toString().hashCode();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;(Not &quot;</span> + exp.toString() + <span class="string">&quot;)&quot;</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 环境(Context)类定义出从变量到布尔值的一个映射</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;    <span class="keyword">private</span> Map&lt;Variable, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 设置变量和值</span><span class="comment">     * <span class="doctag">@param</span> variable</span><span class="comment">     * <span class="doctag">@param</span> value</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">(Variable variable, <span class="type">boolean</span> value)</span> &#123;        map.put(variable, value);    &#125;    <span class="comment">/**</span><span class="comment">     * 根据变量获取变量的值</span><span class="comment">     * <span class="doctag">@param</span> var</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lookup</span><span class="params">(Variable <span class="keyword">var</span>)</span> &#123;        <span class="type">Boolean</span> <span class="variable">value</span> <span class="operator">=</span> map.get(<span class="keyword">var</span>);        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();        &#125;        <span class="keyword">return</span> value.booleanValue();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 环境</span>        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();        <span class="comment">// 变量</span>        <span class="type">Variable</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;x&quot;</span>);        <span class="type">Variable</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;y&quot;</span>);        <span class="comment">// 布尔常量</span>        <span class="type">Constant</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Constant</span>(<span class="literal">true</span>);        <span class="comment">// 将变量名和常量值设置到环境中</span>        context.assign(x, <span class="literal">false</span>);        context.assign(y, <span class="literal">true</span>);        <span class="type">Expression</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Or</span>(<span class="keyword">new</span> <span class="title class_">And</span>(c,x) , <span class="keyword">new</span> <span class="title class_">And</span>(y,<span class="keyword">new</span> <span class="title class_">Not</span>(x)));        System.out.println(<span class="string">&quot;x=&quot;</span> + x.interpret(context));        System.out.println(<span class="string">&quot;y=&quot;</span> + y.interpret(context));        System.out.println(exp.toString() + <span class="string">&quot;=&quot;</span> + exp.interpret(context));    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">x=falsey=true((true AND x) OR (y AND (Not x)))=true</code></pre></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、解释器模式的结构&lt;/p&gt;
&lt;p&gt;下面就以一个示意性的系统为例，讨论解</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>21-备忘录模式</title>
    <link href="https://georgechan95.github.io/blog/a5cf7eb4.html"/>
    <id>https://georgechan95.github.io/blog/a5cf7eb4.html</id>
    <published>2024-11-27T13:40:00.000Z</published>
    <updated>2024-11-30T06:29:06.910Z</updated>
    
    <content type="html"><![CDATA[<p><strong>备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。</strong></p><p><strong>备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代器模式一同使用。</strong></p><h1 id="一、备忘录模式的结构"><a href="#一、备忘录模式的结构" class="headerlink" title="一、备忘录模式的结构"></a>一、备忘录模式的结构</h1><p>备忘录模式的结构图如下所示</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-090723.png" alt="备忘录模式结构图"></p><p>备忘录模式所涉及的角色有三个：<strong>备忘录(Memento)角色、发起人(Originator)角色、负责人(Caretaker)角色</strong>。</p><h2 id="1-备忘录-Memento-角色"><a href="#1-备忘录-Memento-角色" class="headerlink" title="1. 备忘录(Memento)角色"></a>1. 备忘录(Memento)角色</h2><p>备忘录角色又如下责任：</p><ul><li>将发起人（Originator）对象的内存状态存储起来。备忘录可以根据发起人对象的判断来决定存储多少发起人（Originator）对象的内部状态。</li><li>备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。</li></ul><p>备忘录有两个等效的接口：</p><ul><li><strong>窄接口：</strong>负责人（Caretaker）对象（和其他除发起人对象之外的任何对象）看到的是备忘录的窄接口(narrow interface)，这个窄接口只允许它把备忘录对象传给其他的对象。</li><li><strong>宽接口：</strong>与负责人对象看到的窄接口相反的是，发起人对象可以看到一个宽接口(wide interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li></ul><h2 id="2-发起人（Originator）角色"><a href="#2-发起人（Originator）角色" class="headerlink" title="2. 发起人（Originator）角色"></a>2. 发起人（Originator）角色</h2><p>发起人角色有如下责任：</p><ul><li>创建一个含有当前的内部状态的备忘录对象。</li><li>使用备忘录对象存储其内部状态。</li></ul><h2 id="3-负责人（Caretaker）角色"><a href="#3-负责人（Caretaker）角色" class="headerlink" title="3. 负责人（Caretaker）角色"></a>3. 负责人（Caretaker）角色</h2><p>负责人角色有如下责任：</p><ul><li>负责保存备忘录对象。</li><li>不检查备忘录对象的内容。</li></ul><h1 id="二、“白箱”备忘录模式的实现"><a href="#二、“白箱”备忘录模式的实现" class="headerlink" title="二、“白箱”备忘录模式的实现"></a>二、“白箱”备忘录模式的实现</h1><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。因此这个实现又叫做“白箱实现”。</p><p>“白箱”实现将发起人角色的状态存储在一个大家都看得到的地方，因此是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。因此白箱实现仍然是有意义的。</p><p>下面给出一个示意性的“白箱实现”。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-092423.png" alt="备忘录-白箱模式"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 备忘录角色，备忘录对象将发起人对象传入的状态存储起来。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;    <span class="keyword">private</span> String state;    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.state = state;    &#125;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.state = state;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 发起人角色类，利用备忘录角色对象存储自身的状态</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;    <span class="keyword">private</span> String state;    <span class="comment">/**</span><span class="comment">     * 工厂方法，创建一个新的备忘录对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);    &#125;    <span class="comment">/**</span><span class="comment">     * 通过备忘录对象，将发起人状态恢复到备忘录记载的状态</span><span class="comment">     * <span class="doctag">@param</span> memento</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(Memento memento)</span> &#123;        <span class="built_in">this</span>.state = memento.getState();    &#125;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.state = state;        System.out.println(<span class="string">&quot;发起人当前状态：&quot;</span> + <span class="built_in">this</span>.state);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 负责人角色，负责保存备忘录对象，但是从不修改（甚至不查看）备忘录对象的内容。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;    <span class="keyword">private</span> Memento memento;    <span class="comment">/**</span><span class="comment">     * 备忘录取值方法</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Memento <span class="title function_">retrieveMemento</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.memento;    &#125;    <span class="comment">/**</span><span class="comment">     * 备忘录的赋值方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveMemento</span><span class="params">(Memento memento)</span> &#123;        <span class="built_in">this</span>.memento = memento;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 发起人角色</span>        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();        <span class="comment">// 负责人角色</span>        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();        <span class="comment">// 设置状态</span>        originator.setState(<span class="string">&quot;ON&quot;</span>);        <span class="comment">// 创建一个备忘录对象，并使用负责人对象保存</span>        caretaker.saveMemento(originator.createMemento());        <span class="comment">// 修改发起人状态</span>        originator.setState(<span class="string">&quot;OFF&quot;</span>);        <span class="comment">// 恢复发起人对象的状态</span>        originator.restoreMemento(caretaker.retrieveMemento());        System.out.println(<span class="string">&quot;发起人状态恢复到：&quot;</span> + originator.getState());    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">发起人当前状态：ON发起人当前状态：OFF发起人状态恢复到：ON</code></pre></blockquote><p>在上面的这个示意性的客户端角色里面，首先将发起人对象的状态设置成“On”，并创建一个备忘录对象将这个状态存储起来；然后将发起人对象的状态改成“Off”；最后又将发起人对象恢复到备忘录对象所存储起来的状态，即“On”状态。</p><p>系统的时序图更能够反映出系统各个角色被调用的时间顺序。如下图是将发起人对象的状态存储到白箱备忘录对象中去的时序图。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-095455.png" alt="时序图1"></p><p>可以看出系统运行的时序是这样的：</p><ul><li>将发起人对象的状态设置成“On”</li><li>调用发起人角色的 <code>createMemento()</code> 方法，创建一个备忘录对象将这个状态存储起来。</li><li>将备忘录对象存储到负责人对象中去。</li></ul><p><strong>将发起人对象恢复到备忘录对象所记录的状态的时序图如下所示：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-095703.png" alt="时序图2"></p><p>可以看出，将发起人对象恢复到备忘录对象所记录的状态时，系统的运行时序是这样的：</p><ul><li>将发起人状态设置成 “Off” 。</li><li>将备忘录对象从负责人对象中取出。</li><li>将发起人对象恢复到备忘录对象所存储起来的状态，即“On”状态。</li></ul><h1 id="三、“黑箱”备忘录模式的实现"><a href="#三、“黑箱”备忘录模式的实现" class="headerlink" title="三、“黑箱”备忘录模式的实现"></a>三、“黑箱”备忘录模式的实现</h1><p>备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口。这样的实现叫做“黑箱实现”。</p><p>在JAVA语言中，实现双重接口的办法就是将 <strong>备忘录角色类</strong> 设计成 <strong>发起人角色类</strong> 的内部成员类。</p><p>将 <code>Memento</code> 设成 <code>Originator</code> 类的内部类，从而将 <code>Memento</code> 对象封装在 <code>Originator</code> 里面；在外部提供一个标识接口 <code>MementoIF</code> 给<code>Caretaker</code>以及其他对象。这样，<code>Originator</code> 类看到的是 <code>Menmento</code> 的所有接口，而 <code>Caretaker</code> 以及其他对象看到的仅仅是标识接口 <code>MementoIF</code> 所暴露出来的接口。</p><p>使用内部类实现备忘录模式的类图如下所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-100422.png" alt="黑箱备忘录模式"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 窄接口MementoIF，这是一个标识接口，没有定义出任何的方法。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MementoIF</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 发起人角色， 定义了一个内部的Memento类。由于此Memento类的全部接口都是私有的，因此只有它自己和发起人类可以调用。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;    <span class="keyword">private</span> String state;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.state = state;        System.out.println(<span class="string">&quot;发起人当前状态：&quot;</span> + <span class="built_in">this</span>.state);    &#125;    <span class="comment">/**</span><span class="comment">     * 工厂方法，创建一个新的备忘录对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> MementoIF <span class="title function_">createMemento</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(<span class="built_in">this</span>.state);    &#125;    <span class="comment">/**</span><span class="comment">     * 发起人恢复到备忘录对象记录的状态</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(MementoIF mementoIF)</span> &#123;        <span class="type">Memento</span> <span class="variable">memento</span> <span class="operator">=</span> (Memento) mementoIF;        <span class="built_in">this</span>.setState(memento.getState());    &#125;    <span class="comment">/**</span><span class="comment">     * 备忘录角色，实现MementoIF接口，作为内部类发起人类可以全部使用其功能接口，其它类只能获得其接口引用</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Memento</span> <span class="keyword">implements</span> <span class="title class_">MementoIF</span> &#123;        <span class="keyword">private</span> String state;        <span class="keyword">private</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;            <span class="built_in">this</span>.state = state;        &#125;        <span class="keyword">private</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;            <span class="keyword">return</span> state;        &#125;        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;            <span class="built_in">this</span>.state = state;        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 负责人对象，得到的备忘录对象是以MementoIF为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;    <span class="keyword">private</span> MementoIF mementoIF;    <span class="comment">/**</span><span class="comment">     * 获取备忘录对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> MementoIF <span class="title function_">retrieveMemento</span><span class="params">()</span> &#123;        <span class="keyword">return</span> mementoIF;    &#125;    <span class="comment">/**</span><span class="comment">     * 备忘录赋值方法</span><span class="comment">     * <span class="doctag">@param</span> mementoIF</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveMemento</span><span class="params">(MementoIF mementoIF)</span> &#123;        <span class="built_in">this</span>.mementoIF = mementoIF;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 发起人对象</span>        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();        <span class="comment">// 负责人对象</span>        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();        <span class="comment">// 设置状态</span>        originator.setState(<span class="string">&quot;ON&quot;</span>);        <span class="comment">// 创建备忘录</span>        <span class="type">MementoIF</span> <span class="variable">mementoIF</span> <span class="operator">=</span> originator.createMemento();        <span class="comment">// 负责人对象保存备忘录</span>        caretaker.saveMemento(mementoIF);        <span class="comment">// 改变发起人状态</span>        originator.setState(<span class="string">&quot;OFF&quot;</span>);        <span class="comment">// 通过备忘录，恢复发起人对象的状态</span>        originator.restoreMemento(caretaker.retrieveMemento());    &#125;&#125;</code></pre><blockquote><p>运行结果如下：</p><pre><code class="highlight shell">发起人当前状态：ON发起人当前状态：OFF发起人当前状态：ON</code></pre></blockquote><p>客户端首先</p><ul><li>将发起人对象的状态设置为“On”。</li><li>调用 <code>createMemento()</code> 方法，创建一个备忘录对象将这个状态存储起来（此时 <code>createMemento()</code> 方法还回的类型是 <code>MementoIF</code> 接口，真实类型为<code>Originator</code>内部的 <code>Memento</code> 对象）。</li><li>将备忘录对象存储到负责人对象中去。由于负责人对象拿到的仅是 <code>MementoIF</code> 接口，因此无法读出备忘录对象内部的状态。</li><li>将发起人对象的状态设置为“Off”。</li><li>调用负责人对象的 <code>retrieveMemento()</code> 方法将备忘录对象取出。注意此时仅能得到 <code>MementoIF</code> 接口，因此无法读出此对象的内部状态。</li><li>调用发起人对象的 <code>restoreMemento()</code> 方法将发起人对象的状态恢复成备忘录对象所存储的起来的状态，即“On”状态。由于发起人对象的内部类<code>Memento</code>实现了<code>MementoIF</code>接口，这个内部类是传入的备忘录对象的真实类型，因此发起人对象可以利用内部类 <code>Memento</code> 的私有接口读出此对象的内部状态。</li></ul><h1 id="四、多重检查点"><a href="#四、多重检查点" class="headerlink" title="四、多重检查点"></a>四、多重检查点</h1><p>前面所给出的白箱和黑箱的示意性实现都是只存储一个状态的简单实现，也可以叫做只有一个检查点。常见的系统往往需要存储不止一个状态，而是需要存储多个状态，或者叫做有多个检查点。</p><p>备忘录模式可以将发起人对象的状态存储到备忘录对象里面，备忘录模式可以将发起人对象恢复到备忘录对象所存储的某一个检查点上。下面给出一个示意性的、有多重检查点的备忘录模式的实现。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-112032.png" alt="多重检查点"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 备忘录角色，这个实现可以存储任意多的状态，外界可以使用检查点索引index来取出检查点上的状态。　　</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;    <span class="keyword">private</span> List&lt;String&gt; states;    <span class="keyword">private</span> <span class="type">int</span> index;    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(List&lt;String&gt; states, <span class="type">int</span> index)</span> &#123;        <span class="comment">// states是引用，重新创建新的对象</span>        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(states);        <span class="built_in">this</span>.index = index;    &#125;    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getStates</span><span class="params">()</span> &#123;        <span class="keyword">return</span> states;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">()</span> &#123;        <span class="keyword">return</span> index;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 发起人角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;    <span class="keyword">private</span> List&lt;String&gt; states;    <span class="comment">//检查点指数</span>    <span class="keyword">private</span> <span class="type">int</span> index;    <span class="keyword">public</span> <span class="title function_">Originator</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="built_in">this</span>.index = <span class="number">0</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 工厂方法，返还一个新的备忘录对象</span><span class="comment">     */</span>    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(states , index);    &#125;    <span class="comment">/**</span><span class="comment">     * 将发起人恢复到备忘录对象记录的状态上</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(Memento memento)</span>&#123;        states = memento.getStates();        index = memento.getIndex();    &#125;    <span class="comment">/**</span><span class="comment">     * 状态赋值，更新states和索引</span><span class="comment">     * <span class="doctag">@param</span> state</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.states.add(state);        <span class="built_in">this</span>.index++;    &#125;    <span class="comment">/**</span><span class="comment">     * 打印当前检查点的状态</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStates</span><span class="params">()</span> &#123;        System.out.print(<span class="string">&quot;发起人检查点索引：&quot;</span> + <span class="built_in">this</span>.index + <span class="string">&quot;， 状态：&quot;</span>);        <span class="keyword">for</span> (String state : states) &#123;            System.out.print(state + <span class="string">&quot; &quot;</span>);        &#125;        System.out.println();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 负责人角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;    <span class="keyword">private</span> Originator originator;    <span class="keyword">private</span> List&lt;Memento&gt; mementos;    <span class="keyword">private</span> <span class="type">int</span> current;    <span class="keyword">public</span> <span class="title function_">Caretaker</span><span class="params">(Originator originator)</span> &#123;        <span class="built_in">this</span>.originator = originator;        mementos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        current = <span class="number">0</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 创建一个新的检查点</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">createMemento</span><span class="params">()</span> &#123;        <span class="type">Memento</span> <span class="variable">memento</span> <span class="operator">=</span> originator.createMemento();        mementos.add(memento);        <span class="keyword">return</span> current++;    &#125;    <span class="comment">/**</span><span class="comment">     * 将发起人恢复到某个检查点</span><span class="comment">     * <span class="doctag">@param</span> index</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(<span class="type">int</span> index)</span> &#123;        <span class="type">Memento</span> <span class="variable">memento</span> <span class="operator">=</span> mementos.get(index);        originator.restoreMemento(memento);    &#125;    <span class="comment">/**</span><span class="comment">     * 删除某个检查点</span><span class="comment">     * <span class="doctag">@param</span> index</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeMemento</span><span class="params">(<span class="type">int</span> index)</span> &#123;        mementos.remove(index);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 发起人</span>        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();        <span class="comment">// 负责人</span>        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>(originator);        <span class="comment">// 变更状态，并保存检查点</span>        originator.setState(<span class="string">&quot;State 0&quot;</span>);        caretaker.createMemento();        <span class="comment">// 变更状态，并保存检查点</span>        originator.setState(<span class="string">&quot;State 1&quot;</span>);        caretaker.createMemento();        <span class="comment">// 变更状态，并保存检查点</span>        originator.setState(<span class="string">&quot;State 2&quot;</span>);        caretaker.createMemento();        <span class="comment">// 打印当前检查点</span>        originator.printStates();        <span class="comment">// 恢复到检查点1</span>        caretaker.restoreMemento(<span class="number">1</span>);        <span class="comment">// 打印当前检查点</span>        originator.printStates();        <span class="comment">// 恢复到检查点2</span>        caretaker.restoreMemento(<span class="number">2</span>);        <span class="comment">// 打印当前检查点</span>        originator.printStates();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">发起人检查点索引：3， 状态：State 0 State 1 State 2 发起人检查点索引：2， 状态：State 0 State 1 发起人检查点索引：3， 状态：State 0 State 1 State 2</code></pre></blockquote><p>可以看出，客户端角色通过不断改变发起人角色的状态，并将之存储在备忘录里面。通过指明检查点指数可以将发起人角色恢复到相应的检查点所对应的状态上。</p><p>将发起人的状态存储到备忘录对象中的活动序列图如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-114712.png" alt="多重检查点时序图1"></p><p><strong>系统运行的时序是这样的：</strong></p><ul><li>将发起人对象的状态设置成某个有效状态；</li><li>调用负责人角色的 <code>createMemento()</code> 方法，负责人角色会负责调用发起人角色和备忘录角色，将发起人对象的状态存储起来。</li></ul><p><strong>将发起人对象恢复到某一个备忘录对象的检查点的活动序列图如下：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-114846.png" alt="多重检查点时序图2"></p><p>由于负责人角色的功能被增强了，因此将发起人对象恢复到备忘录对象所记录的状态时，系统运行的时序被简化了：</p><ul><li>调用负责人角色的 <code>restoreMemento()</code> 方法，将发起人恢复到某个检查点。</li></ul><h1 id="五、“自述历史”模式"><a href="#五、“自述历史”模式" class="headerlink" title="五、“自述历史”模式"></a>五、“自述历史”模式</h1><p>所谓“自述历史”模式(<code>History-On-Self Pattern</code>)实际上就是备忘录模式的一个变种。在备忘录模式中，发起人(Originator)角色、负责人(Caretaker)角色和备忘录(Memento)角色都是独立的角色。虽然在实现上备忘录类可以成为发起人类的内部成员类，但是备忘录类仍然保持作为一个角色的独立意义。在“自述历史”模式里面，发起人角色自己兼任负责人角色。</p><p>“自述历史”模式的类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-115121.png" alt="自述历史模式"></p><p><strong>备忘录角色有如下责任：</strong></p><ul><li>将发起人（Originator）对象的内部状态存储起来。</li><li>备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。</li></ul><p><strong>发起人角色有如下责任：</strong></p><ul><li>创建一个含有它当前的内部状态的备忘录对象。</li><li>使用备忘录对象存储其内部状态。</li></ul><p>客户端角色有负责保存备忘录对象的责任。</p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 窄接口MementoIF，这是一个标识接口，因此它没有定义出任何的方法。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MementoIF</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 发起人角色同时还兼任负责人角色，也就是说它自己负责保持自己的备忘录对象。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;    <span class="keyword">public</span> String state;    <span class="comment">/**</span><span class="comment">     * 改变状态</span><span class="comment">     * <span class="doctag">@param</span> state</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeState</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.state = state;        System.out.println(<span class="string">&quot;状态改变为：&quot;</span> + state);    &#125;    <span class="comment">/**</span><span class="comment">     * 工厂方法，返还一个新的备忘录对象</span><span class="comment">     */</span>    <span class="keyword">public</span> MementoIF <span class="title function_">createMemento</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(<span class="built_in">this</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 将发起人恢复到备忘录对象所记录的状态上</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(MementoIF mementoIF)</span> &#123;        <span class="type">Memento</span> <span class="variable">memento</span> <span class="operator">=</span> (Memento) mementoIF;        changeState(memento.getState());    &#125;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="comment">/**</span><span class="comment">     * 备忘录角色，作为内部类</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Memento</span> <span class="keyword">implements</span> <span class="title class_">MementoIF</span> &#123;        <span class="keyword">private</span> String state;        <span class="comment">/**</span><span class="comment">         * 构造方法</span><span class="comment">         * <span class="doctag">@param</span> originator</span><span class="comment">         */</span>        <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(Originator originator)</span> &#123;            <span class="built_in">this</span>.state = originator.getState();        &#125;        <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;            <span class="keyword">return</span> state;        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 发起人</span>        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();        <span class="comment">// 改变状态</span>        originator.changeState(<span class="string">&quot;ON&quot;</span>);        <span class="comment">// 存储发起人状态</span>        <span class="type">MementoIF</span> <span class="variable">memento</span> <span class="operator">=</span> originator.createMemento();        <span class="comment">// 改变状态</span>        originator.changeState(<span class="string">&quot;OFF&quot;</span>);        <span class="comment">// 恢复发起人状态</span>        originator.restoreMemento(memento);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">状态改变为：ON状态改变为：OFF状态改变为：ON</code></pre></blockquote><p>由于“自述历史”作为一个备忘录模式的特殊实现形式非常简单易懂，它可能是备忘录模式最为流行的实现形式。</p><blockquote><p>参考链接：<a href="https://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html">https://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>20-中介者模式</title>
    <link href="https://georgechan95.github.io/blog/3148d6be.html"/>
    <id>https://georgechan95.github.io/blog/3148d6be.html</id>
    <published>2024-11-26T12:35:00.000Z</published>
    <updated>2024-11-27T05:21:35.927Z</updated>
    
    <content type="html"><![CDATA[<p><strong>中介者模式是对象的行为模式。中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。</strong></p><h1 id="一、为什么需要中介者"><a href="#一、为什么需要中介者" class="headerlink" title="一、为什么需要中介者"></a>一、为什么需要中介者</h1><p>如下图所示，这个示意图中有大量的对象，这些对象既会影响别的对象，又会被别的对象所影响，因此常常叫做同事(Colleague)对象。这些同事对象通过彼此的相互作用形成系统的行为。从图中可以看出，几乎每一个对象都需要与其他的对象发生相互作用，而这种相互作用表现为一个对象与另一个对象的直接耦合。这就是过度耦合的系统。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-122831.png" alt="过度耦合系统"></p><p>通过引入中介者对象(Mediator)，可以将系统的网状结构变成以中介者为中心的星形结构，如下图所示。在这个星形结构中，同事对象不再通过直接的联系与另一个对象发生相互作用；相反的，它通过中介者对象与另一个对象发生相互作用。中介者对象的存在保证了对象结构上的稳定，也就是说，系统的结构不会因为新对象的引入造成大量的修改工作。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-122939.png" alt="有中介者的系统"></p><p>一个好的面向对象的设计可以使对象之间增加协作性(Collaboration)，减少耦合度(Couping)。一个深思熟虑的设计会把一个系统分解为一群相互协作的同事对象，然后给每一个同事对象以独特的责任，恰当的配置它们之间的协作关系，使它们可以在一起工作。</p><h1 id="二、中介者案例"><a href="#二、中介者案例" class="headerlink" title="二、中介者案例"></a>二、中介者案例</h1><h2 id="1-如果没有主板"><a href="#1-如果没有主板" class="headerlink" title="1. 如果没有主板"></a>1. 如果没有主板</h2><p>大家都知道，电脑里面各个配件之间的交互，主要是通过主板来完成的。如果电脑里面没有了主板，那么各个配件之间就必须自行相互交互，以互相传送数据。而且由于各个配件的接口不同，相互之间交互时，还必须把数据接口进行转换才能匹配上。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-123241.png" alt="无主板的各组件之间的联系"></p><p>所幸是有了主板，各个配件的交互完全通过主板来完成，每个配件都只需要和主板交互，而主板知道如何跟所有的配件打交道，这样就简单多了。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-123326.png" alt="通过主板连接各个组件"></p><h2 id="2-中介者模式的结构"><a href="#2-中介者模式的结构" class="headerlink" title="2. 中介者模式的结构"></a>2. 中介者模式的结构</h2><p>中介者模式的示意性类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-123641.png" alt="中介者模式"></p><p>中介者模式包括以下角色：</p><ul><li><strong>抽象中介者(Mediator)角色：</strong>定义出同事对象到中介者对象的接口，其中主要方法是一个（或多个）事件方法。</li><li><strong>具体中介者(ConcreteMediator)角色：</strong>实现了抽象中介者所声明的事件方法。具体中介者知晓所有的具体同事类，并负责具体的协调各同事对象的交互关系。</li><li><strong>抽象同事类(Colleague)角色：</strong>定义出中介者到同事对象的接口。同事对象只知道中介者而不知道其余的同事对象。</li><li><strong>具体同事类(ConcreteColleague)角色：</strong>所有的具体同事类均从抽象同事类继承而来。实现自己的业务，在需要与其他同事通信的时候，就与持有的中介者通信，中介者会负责与其他的同事交互。</li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象中介者类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;    <span class="comment">/**</span><span class="comment">     * 同事对象在自身改变的时候来通知中介者方法</span><span class="comment">     * 让中介者去负责相应的与其他同事对象的交互</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">changed</span><span class="params">(Colleague c)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体中介者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span>&#123;    <span class="comment">// 持有并维护同事A</span>    <span class="keyword">private</span> ConcreteColleagueA colleagueA;    <span class="comment">// 持有并维护同事B</span>    <span class="keyword">private</span> ConcreteColleagueB colleagueB;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleagueA</span><span class="params">(ConcreteColleagueA colleagueA)</span> &#123;        <span class="built_in">this</span>.colleagueA = colleagueA;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleagueB</span><span class="params">(ConcreteColleagueB colleagueB)</span> &#123;        <span class="built_in">this</span>.colleagueB = colleagueB;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changed</span><span class="params">(Colleague c)</span> &#123;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象同事类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;    <span class="comment">// 持有一个中介者对象</span>    <span class="keyword">private</span> Mediator mediator;    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">this</span>.mediator = mediator;    &#125;    <span class="comment">/**</span><span class="comment">     * 获取当前同事类对应的中介者对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Mediator <span class="title function_">getMediator</span><span class="params">()</span> &#123;        <span class="keyword">return</span> mediator;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体同事对象A</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteColleagueA</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="keyword">public</span> <span class="title function_">ConcreteColleagueA</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 示意方法，执行某些操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;        <span class="comment">//在需要跟其他同事通信的时候，通知中介者对象</span>        getMediator().changed(<span class="built_in">this</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体同事对象B</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteColleagueB</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="keyword">public</span> <span class="title function_">ConcreteColleagueB</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 示意方法，执行某些操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;        <span class="comment">//在需要跟其他同事通信的时候，通知中介者对象</span>        getMediator().changed(<span class="built_in">this</span>);    &#125;&#125;</code></pre><h2 id="3-使用电脑来看电影"><a href="#3-使用电脑来看电影" class="headerlink" title="3. 使用电脑来看电影"></a>3. 使用电脑来看电影</h2><p>在日常生活中，我们经常使用电脑来看电影，把这个过程描述出来，简化后假定会有如下的交互过程：</p><ul><li>首先是光驱要读取光盘上的数据，然后告诉主板，它的状态改变了。</li><li>主板去得到光驱的数据，把这些数据交给CPU进行分析处理。</li><li>CPU处理完后，把数据分成了视频数据和音频数据，通知主板，它处理完了。</li><li>主板去得到CPU处理过后的数据，分别把数据交给显卡和声卡，去显示出视频和发出声音</li></ul><p>要使用中介者模式来实现示例，那就要区分出同事对象和中介者对象。很明显，主板是中介者，而光驱、声卡、CPU、显卡等配件，都是作为同事对象。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-193234.png" alt="中介者模式应用"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象的同事类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;    <span class="comment">// 持有一个中介者对象</span>    <span class="keyword">private</span> Mediator mediator;    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">this</span>.mediator = mediator;    &#125;    <span class="comment">/**</span><span class="comment">     * 返回当前同事类持有的中介者对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Mediator <span class="title function_">getMediator</span><span class="params">()</span> &#123;        <span class="keyword">return</span> mediator;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象中介者类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;    <span class="comment">/**</span><span class="comment">     * 同事对象在自身改变的时候来通知中介者方法</span><span class="comment">     * 让中介者去负责相应的与其他同事对象的交互</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">changed</span><span class="params">(Colleague c)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 同事类-光驱</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDDriver</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="comment">// 读取的数据</span>    <span class="keyword">private</span> String data;    <span class="keyword">public</span> <span class="title function_">CDDriver</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 读取数据</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;        <span class="keyword">return</span> data;    &#125;    <span class="comment">/**</span><span class="comment">     * 读取光盘</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readCD</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;~驱动器工作中&quot;</span>);        <span class="comment">// 逗号前是视频显示的数据，逗号后是声音</span>        <span class="built_in">this</span>.data = <span class="string">&quot;One Piece,海贼王我当定了&quot;</span>;        <span class="comment">// 通知主板（中介者），已经读取到数据了</span>        <span class="built_in">this</span>.getMediator().changed(<span class="built_in">this</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 同事类-CPU</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CPU</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="comment">//分解出来的视频数据</span>    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">videoData</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;    <span class="comment">//分解出来的声音数据</span>    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">soundData</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;    <span class="keyword">public</span> <span class="title function_">CPU</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 获取视频数据</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">getVideoData</span><span class="params">()</span> &#123;        <span class="keyword">return</span> videoData;    &#125;    <span class="comment">/**</span><span class="comment">     * 获取音频数据</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">getSoundData</span><span class="params">()</span> &#123;        <span class="keyword">return</span> soundData;    &#125;    <span class="comment">/**</span><span class="comment">     * 接收主板调用，将数据解析成视频数据和音频数据</span><span class="comment">     * <span class="doctag">@param</span> data</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeData</span><span class="params">(String data)</span> &#123;        System.out.println(<span class="string">&quot;~CPU工作中&quot;</span>);        String[] dataArr = data.split(<span class="string">&quot;,&quot;</span>);        <span class="built_in">this</span>.soundData = dataArr[<span class="number">0</span>];        <span class="built_in">this</span>.videoData = dataArr[<span class="number">1</span>];        <span class="comment">// 解析完成后通知主板（中介者），进行下一步处理</span>        <span class="built_in">this</span>.getMediator().changed(<span class="built_in">this</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 同事类-声卡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoundCard</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="keyword">public</span> <span class="title function_">SoundCard</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 播放音频</span><span class="comment">     * <span class="doctag">@param</span> data</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">soundData</span><span class="params">(String data)</span> &#123;        System.out.println(<span class="string">&quot;~声卡工作中&quot;</span>);        System.out.println(<span class="string">&quot;您正在收听的是：&quot;</span> + data);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 同事类-显卡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoCard</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="keyword">public</span> <span class="title function_">VideoCard</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 播放视频内容</span><span class="comment">     * <span class="doctag">@param</span> data</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showData</span><span class="params">(String data)</span> &#123;        System.out.println(<span class="string">&quot;~显卡工作中&quot;</span>);        System.out.println(<span class="string">&quot;您正在观看内容：&quot;</span> + data);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体中介者-主板</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainBoard</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;    <span class="comment">// 驱动</span>    <span class="keyword">private</span> CDDriver cdDriver;    <span class="comment">// CPU</span>    <span class="keyword">private</span> CPU cpu;    <span class="comment">// 声卡</span>    <span class="keyword">private</span> SoundCard soundCard;    <span class="comment">// 显卡</span>    <span class="keyword">private</span> VideoCard videoCard;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changed</span><span class="params">(Colleague c)</span> &#123;        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> CDDriver) &#123;            <span class="comment">// 数据读取</span>            <span class="built_in">this</span>.cdDriverReadData((CDDriver) c);        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> CPU) &#123;            <span class="built_in">this</span>.openCPU((CPU) c);        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * CDDriver读取数据，调用CPU处理数据</span><span class="comment">     * <span class="doctag">@param</span> cdDriver</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cdDriverReadData</span><span class="params">(CDDriver cdDriver)</span> &#123;        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> cdDriver.getData();        cpu.executeData(data);    &#125;    <span class="comment">/**</span><span class="comment">     * CPU解析数据，调用显卡、声卡处理数据</span><span class="comment">     * <span class="doctag">@param</span> cpu</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">openCPU</span><span class="params">(CPU cpu)</span> &#123;        <span class="comment">// 解析数据</span>        <span class="type">String</span> <span class="variable">soundData</span> <span class="operator">=</span> cpu.getSoundData();        <span class="type">String</span> <span class="variable">videoData</span> <span class="operator">=</span> cpu.getVideoData();        <span class="comment">// 声卡播放数据</span>        <span class="built_in">this</span>.soundCard.soundData(soundData);        <span class="comment">// 显卡播放数据</span>        <span class="built_in">this</span>.videoCard.showData(videoData);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCdDriver</span><span class="params">(CDDriver cdDriver)</span> &#123;        <span class="built_in">this</span>.cdDriver = cdDriver;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(CPU cpu)</span> &#123;        <span class="built_in">this</span>.cpu = cpu;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSoundCard</span><span class="params">(SoundCard soundCard)</span> &#123;        <span class="built_in">this</span>.soundCard = soundCard;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoCard</span><span class="params">(VideoCard videoCard)</span> &#123;        <span class="built_in">this</span>.videoCard = videoCard;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建中介者</span>        <span class="type">MainBoard</span> <span class="variable">mainBoard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MainBoard</span>();        <span class="comment">// 具体同事类-驱动器</span>        <span class="type">CDDriver</span> <span class="variable">cdDriver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CDDriver</span>(mainBoard);        <span class="comment">// 具体同事类-CPU</span>        <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CPU</span>(mainBoard);        <span class="comment">// 具体同事类-显卡</span>        <span class="type">VideoCard</span> <span class="variable">videoCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoCard</span>(mainBoard);        <span class="comment">// 具体同事类-声卡</span>        <span class="type">SoundCard</span> <span class="variable">soundCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoundCard</span>(mainBoard);        <span class="comment">// 设置中介者管理的同事类</span>        mainBoard.setCdDriver(cdDriver);        mainBoard.setCpu(cpu);        mainBoard.setSoundCard(soundCard);        mainBoard.setVideoCard(videoCard);        <span class="comment">// 开始读取CD</span>        cdDriver.readCD();    &#125;&#125;</code></pre><blockquote><p>运行结果</p><pre><code class="highlight shell">~驱动器工作中~CPU工作中~声卡工作中您正在收听的是：One Piece~显卡工作中您正在观看内容：海贼王我当定了</code></pre></blockquote><h1 id="三、中介者模式的优-缺点"><a href="#三、中介者模式的优-缺点" class="headerlink" title="三、中介者模式的优&#x2F;缺点"></a>三、中介者模式的优&#x2F;缺点</h1><h2 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h2><ul><li><p><strong>松散耦合</strong></p><p>中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互不依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p></li><li><p><strong>集中控制交互</strong></p><p>多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p></li><li><p><strong>多对多变成一对多</strong></p><p>没有使用中介者模式的时候，同事对象之间的关系通常是多对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对多，这会让对象的关系更容易理解和实现。</p></li></ul><h2 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h2><p>中介者模式的一个潜在缺点是，过度集中化。如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到中介者的时候，会导致中介者对象变得十分复杂，而且难于管理和维护。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;中介者模式是对象的行为模式。中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>19-观察者模式</title>
    <link href="https://georgechan95.github.io/blog/f06aea0b.html"/>
    <id>https://georgechan95.github.io/blog/f06aea0b.html</id>
    <published>2024-11-25T13:07:00.000Z</published>
    <updated>2024-11-25T12:38:35.384Z</updated>
    
    <content type="html"><![CDATA[<p><strong>观察者模式是对象的行为模式，又叫发布-订阅(Publish&#x2F;Subscribe)模式、模型-视图(Model&#x2F;View)模式、源-监听器(Source&#x2F;Listener)模式或从属者(Dependents)模式。</strong></p><p><strong>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</strong></p><h1 id="一、观察者模式的结构"><a href="#一、观察者模式的结构" class="headerlink" title="一、观察者模式的结构"></a>一、观察者模式的结构</h1><p>一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。</p><p>同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。</p><p>下面以一个简单的示意性实现为例，讨论观察者模式的结构。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/25/20241125-193801.png" alt="观察者模式"></p><p><em>观察者模式所涉及的角色有：</em></p><ul><li><strong>抽象主题(Subject)角色：</strong>抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</li><li><strong>具体主题(ConcreteSubject)角色：</strong>将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</li><li><strong>抽象观察者(Observer)角色：</strong>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</li><li><strong>具体观察者(ConcreteObserver)角色：</strong>存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象主题角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;    <span class="comment">/**</span><span class="comment">     * 保存注册的观察者对象</span><span class="comment">     */</span>    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 注册观察者</span><span class="comment">     * <span class="doctag">@param</span> observer</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;        list.add(observer);        System.out.println(<span class="string">&quot;注册了一个观察者对象&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 移除观察者</span><span class="comment">     * <span class="doctag">@param</span> observer</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;        list.remove(observer);    &#125;    <span class="comment">/**</span><span class="comment">     * 通知所有的观察者对象</span><span class="comment">     * <span class="doctag">@param</span> newState</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(String newState)</span> &#123;        <span class="keyword">for</span> (Observer observer : list) &#123;            observer.update(newState);        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的观察者对象</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;    <span class="keyword">private</span> String state;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="comment">/**</span><span class="comment">     * 主题状态更新方法</span><span class="comment">     * <span class="doctag">@param</span> newState 新状态</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String newState)</span> &#123;        <span class="built_in">this</span>.state = newState;        System.out.println(<span class="string">&quot;主题状态为：&quot;</span> + state);        <span class="comment">//状态发生改变，通知各个观察者</span>        <span class="built_in">super</span>.notifyObservers(newState);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象观察者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;    <span class="comment">/**</span><span class="comment">     * 观察者更新接口</span><span class="comment">     * <span class="doctag">@param</span> newState</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String newState)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体的观察者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;    <span class="comment">// 观察者的状态</span>    <span class="keyword">private</span> String observerState;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String newState)</span> &#123;        <span class="built_in">this</span>.observerState = newState;        <span class="comment">/**</span><span class="comment">         * 更新观察者的状态，使其与目标的状态保持一致</span><span class="comment">         */</span>        System.out.println(<span class="string">&quot;观察者的状态更新为：&quot;</span> + <span class="built_in">this</span>.observerState);    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建观察者</span>        <span class="type">Observer</span> <span class="variable">observer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();        <span class="type">Observer</span> <span class="variable">observer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();        <span class="comment">// 创建具体的主题</span>        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();        <span class="comment">// 给主题注册观察者</span>        subject.attach(observer1);        subject.attach(observer2);        <span class="comment">// 更新主题状态</span>        subject.change(<span class="string">&quot;doWork&quot;</span>);        <span class="comment">// 主题移除观察者</span>        subject.detach(observer2);        <span class="comment">// 更新主题状态</span>        subject.change(<span class="string">&quot;sleep&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">注册了一个观察者对象注册了一个观察者对象主题状态为：doWork观察者的状态更新为：doWork观察者的状态更新为：doWork主题状态为：sleep观察者的状态更新为：sleep</code></pre></blockquote><p>在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的attach()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。</p><p>这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象。</p><h1 id="二、推模型和拉模型"><a href="#二、推模型和拉模型" class="headerlink" title="二、推模型和拉模型"></a>二、推模型和拉模型</h1><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><ul><li><p><strong>推模型</strong></p><p>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p></li><li><p><strong>拉模型</strong></p><p>主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p></li></ul><p>　根据上面的描述，发现前面的例子就是典型的推模型，下面给出一个拉模型的实例。</p><h2 id="1-拉模型的抽象观察者类"><a href="#1-拉模型的抽象观察者类" class="headerlink" title="1. 拉模型的抽象观察者类"></a>1. 拉模型的抽象观察者类</h2><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">// 拉模型通常都是把主题对象当做参数传递。</span><span class="comment">/**</span><span class="comment"> * 抽象观察者角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;    <span class="comment">/**</span><span class="comment">     * 更新接口</span><span class="comment">     * <span class="doctag">@param</span> subject 传入主题对象，方面获取相应的主题对象的状态</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Subject subject)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体的观察者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;    <span class="comment">// 观察者的状态</span>    <span class="keyword">private</span> String observerState;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Subject subject)</span> &#123;        <span class="built_in">this</span>.observerState = ((ConcreteSubject) subject).getState();        <span class="comment">/**</span><span class="comment">         * 更新观察者的状态，使其与目标的状态保持一致</span><span class="comment">         */</span>        System.out.println(<span class="string">&quot;观察者的状态更新为：&quot;</span> + <span class="built_in">this</span>.observerState);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象主题角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;    <span class="comment">/**</span><span class="comment">     * 保存注册的观察者对象</span><span class="comment">     */</span>    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 注册观察者</span><span class="comment">     * <span class="doctag">@param</span> observer</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;        list.add(observer);        System.out.println(<span class="string">&quot;注册了一个观察者对象&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 移除观察者</span><span class="comment">     * <span class="doctag">@param</span> observer</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;        list.remove(observer);    &#125;    <span class="comment">/**</span><span class="comment">     * 通知所有的观察者对象</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;        <span class="keyword">for</span> (Observer observer : list) &#123;            observer.update(<span class="built_in">this</span>);        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的观察者对象</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;    <span class="keyword">private</span> String state;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="comment">/**</span><span class="comment">     * 主题状态更新方法</span><span class="comment">     * <span class="doctag">@param</span> newState 新状态</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String newState)</span> &#123;        <span class="built_in">this</span>.state = newState;        System.out.println(<span class="string">&quot;主题状态为：&quot;</span> + state);        <span class="comment">//状态发生改变，通知各个观察者</span>        <span class="built_in">super</span>.notifyObservers();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建观察者</span>        <span class="type">Observer</span> <span class="variable">observer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();        <span class="type">Observer</span> <span class="variable">observer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();        <span class="comment">// 创建具体的主题</span>        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();        <span class="comment">// 给主题注册观察者</span>        subject.attach(observer1);        subject.attach(observer2);        <span class="comment">// 更新主题状态</span>        subject.change(<span class="string">&quot;doWork&quot;</span>);        <span class="comment">// 主题移除观察者</span>        subject.detach(observer2);        <span class="comment">// 更新主题状态</span>        subject.change(<span class="string">&quot;sleep&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">注册了一个观察者对象注册了一个观察者对象主题状态为：doWork观察者的状态更新为：doWork观察者的状态更新为：doWork主题状态为：sleep观察者的状态更新为：sleep</code></pre></blockquote><h2 id="2-两种模式的比较"><a href="#2-两种模式的比较" class="headerlink" title="2. 两种模式的比较"></a>2. 两种模式的比较</h2><ul><li>推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。</li><li>推模型可能会使得观察者对象难以复用，因为观察者的 <code>update()</code> 方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的 <code>update()</code> 方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，<code>update()</code> 方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</li></ul><h1 id="三、JAVA提供的对观察者模式的支持"><a href="#三、JAVA提供的对观察者模式的支持" class="headerlink" title="三、JAVA提供的对观察者模式的支持"></a>三、JAVA提供的对观察者模式的支持</h1><p>在JAVA语言的java.util库里面，提供了一个<code>Observable类</code> 以及一个 <code>Observer接口</code> ，构成JAVA语言对观察者模式的支持。</p><h2 id="1-Observer接口"><a href="#1-Observer接口" class="headerlink" title="1. Observer接口"></a>1. Observer接口</h2><p>这个接口只定义了一个方法，即 <code>update()</code> 方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span>;&#125;</code></pre><h2 id="2-Observable类"><a href="#2-Observable类" class="headerlink" title="2. Observable类"></a>2. Observable类</h2><p>被观察者类都是 <code>java.util.Observable</code> 类的子类。<code>java.util.Observable</code> 提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是 <code>setChanged()</code>，另一个是 <code>notifyObservers()</code> 。第一方法 <code>setChanged()</code> 被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是 <code>notifyObservers()</code>，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="keyword">private</span> Vector obs;       <span class="comment">/** Construct an Observable with zero Observers. */</span>    <span class="keyword">public</span> <span class="title function_">Observable</span><span class="params">()</span> &#123;    obs = <span class="keyword">new</span> <span class="title class_">Vector</span>();    &#125;    <span class="comment">/**</span><span class="comment">     * 将一个观察者添加到观察者聚集上面</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer o)</span> &#123;        <span class="keyword">if</span> (o == <span class="literal">null</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();    <span class="keyword">if</span> (!obs.contains(o)) &#123;        obs.addElement(o);    &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 将一个观察者从观察者聚集上删除</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deleteObserver</span><span class="params">(Observer o)</span> &#123;        obs.removeElement(o);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;    notifyObservers(<span class="literal">null</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 如果本对象有变化（那时hasChanged 方法会返回true）</span><span class="comment">     * 调用本方法通知所有登记的观察者，即调用它们的update()方法</span><span class="comment">     * 传入this和arg作为参数</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Object arg)</span> &#123;        Object[] arrLocal;    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;        <span class="keyword">if</span> (!changed)                <span class="keyword">return</span>;            arrLocal = obs.toArray();            clearChanged();        &#125;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)            ((Observer)arrLocal[i]).update(<span class="built_in">this</span>, arg);    &#125;    <span class="comment">/**</span><span class="comment">     * 将观察者聚集清空</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deleteObservers</span><span class="params">()</span> &#123;    obs.removeAllElements();    &#125;    <span class="comment">/**</span><span class="comment">     * 将“已变化”设置为true</span><span class="comment">     */</span>    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setChanged</span><span class="params">()</span> &#123;    changed = <span class="literal">true</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 将“已变化”重置为false</span><span class="comment">     */</span>    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clearChanged</span><span class="params">()</span> &#123;    changed = <span class="literal">false</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 检测本对象是否已变化</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">hasChanged</span><span class="params">()</span> &#123;    <span class="keyword">return</span> changed;    &#125;    <span class="comment">/**</span><span class="comment">     * Returns the number of observers of this &lt;tt&gt;Observable&lt;/tt&gt; object.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span>  the number of observers of this object.</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">countObservers</span><span class="params">()</span> &#123;    <span class="keyword">return</span> obs.size();    &#125;&#125;</code></pre><p>这个类代表一个被观察者对象，有时称之为主题对象。一个被观察者对象可以有数个观察者对象，每个观察者对象都是实现Observer接口的对象。在被观察者发生变化时，会调用Observable的 <code>notifyObservers()</code> 方法，此方法调用所有的具体观察者的update()方法，从而使所有的观察者都被通知更新自己。</p><h1 id="四、怎样使用JAVA对观察者模式的支持"><a href="#四、怎样使用JAVA对观察者模式的支持" class="headerlink" title="四、怎样使用JAVA对观察者模式的支持"></a>四、怎样使用JAVA对观察者模式的支持</h1><p>这里给出一个非常简单的例子，说明怎样使用JAVA所提供的对观察者模式的支持。在这个例子中，被观察对象叫做 <code>Watched</code>；而观察者对象叫做 <code>Watcher</code>。<code>Watched</code> 对象继承自 <code>java.util.Observable</code> 类；而<code>Watcher</code>对象实现了 <code>java.util.Observer</code> 接口。另外有一个Test类扮演客户端角色。</p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 主题角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Watched</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;    <span class="keyword">private</span> String data;    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;        <span class="keyword">return</span> data;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(String data)</span> &#123;        <span class="keyword">if</span> (!data.equals(<span class="built_in">this</span>.data)) &#123;            <span class="built_in">this</span>.data = data;            <span class="comment">// 调用父类方法，更新 changed标识</span>            setChanged();        &#125;        <span class="comment">// 调用父类方法， 更新观察者</span>        notifyObservers();    &#125;&#125;<span class="comment">// 观察者角色</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;    <span class="keyword">public</span> <span class="title function_">Watcher</span><span class="params">(Observable observable)</span> &#123;        <span class="comment">// 添加观察者到主题中</span>        observable.addObserver(<span class="built_in">this</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;        System.out.println(<span class="string">&quot;主题状态发生改变：&quot;</span> + ((Watched)o).getData());    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建被观察者对象</span>        <span class="type">Watched</span> <span class="variable">watched</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watched</span>();        <span class="comment">//创建观察者对象，并将被观察者对象登记</span>        <span class="type">Observer</span> <span class="variable">watcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watcher</span>(watched);        <span class="comment">//给被观察者状态赋值</span>        watched.setData(<span class="string">&quot;start&quot;</span>);        watched.setData(<span class="string">&quot;run&quot;</span>);        watched.setData(<span class="string">&quot;stop&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">主题状态发生改变：start主题状态发生改变：run主题状态发生改变：stop</code></pre></blockquote><p>Test对象首先创建了Watched和Watcher对象。在创建Watcher对象时，将Watched对象作为参数传入；然后Test对象调用Watched对象的setData()方法，触发Watched对象的内部状态变化；Watched对象进而通知实现登记过的Watcher对象，也就是调用它的update()方法。</p><p>参考链接：<a href="https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html">https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;观察者模式是对象的行为模式，又叫发布-订阅(Publish&amp;#x2F;Subscribe)模式、模型-视图(Model&amp;#x2F;View)模式、源-监听器(Source&amp;#x2F;Listener)模式或从属者(Dependents)模式。&lt;/strong</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>18-迭代器模式</title>
    <link href="https://georgechan95.github.io/blog/7dbd9149.html"/>
    <id>https://georgechan95.github.io/blog/7dbd9149.html</id>
    <published>2024-11-23T16:02:00.000Z</published>
    <updated>2024-11-25T01:24:55.343Z</updated>
    
    <content type="html"><![CDATA[<p><strong>迭代器模式又叫游标(Cursor)模式，是对象的行为模式。迭代器模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（<em>internal representation</em>）。</strong></p><h1 id="一、聚集和Java聚集"><a href="#一、聚集和Java聚集" class="headerlink" title="一、聚集和Java聚集"></a>一、聚集和Java聚集</h1><p>多个对象聚在一起形成的总体称之为聚集(Aggregate)，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂化和多样性。数组就是最基本的聚集，也是其他的JAVA聚集对象的设计基础。</p><p>JAVA聚集对象是实现了共同的java.util.Collection接口的对象，是JAVA语言对聚集概念的直接支持。从1.2版开始，JAVA语言提供了很多种聚集，包括Vector、ArrayList、HashSet、HashMap、Hashtable等，这些都是JAVA聚集的例子。</p><h1 id="二、迭代器模式的结构"><a href="#二、迭代器模式的结构" class="headerlink" title="二、迭代器模式的结构"></a>二、迭代器模式的结构</h1><p>迭代器模式有两种实现方式，分别是<strong>白箱聚集与外禀迭代器</strong>和<strong>黑箱聚集于内禀迭代器。</strong></p><h2 id="1-白箱聚集与外禀迭代器"><a href="#1-白箱聚集与外禀迭代器" class="headerlink" title="1. 白箱聚集与外禀迭代器"></a>1. 白箱聚集与外禀迭代器</h2><h3 id="1-1-理论概述"><a href="#1-1-理论概述" class="headerlink" title="1.1 理论概述"></a>1.1 理论概述</h3><p>如果一个聚集的接口提供了可以用来修改聚集元素的方法，这个接口就是所谓的<strong>宽接口</strong>。</p><p>如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代器模式对迭代器对象的要求。但是，这样会破坏对聚集对象的封装。这种提供宽接口的聚集叫做<strong>白箱聚集</strong>。聚集对象向外界提供同样的宽接口，如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/24/20241124-135235.png" alt="宽接口"></p><p>由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代器可以从外部控制聚集元素的迭代过程。这样一来迭代器所控制的仅仅是一个游标而已，这种迭代器叫做<strong>游标迭代器（Cursor Iterator）</strong>。由于迭代器是在聚集结构之外的，因此这样的迭代器又叫做<strong>外禀迭代器（Extrinsic Iterator）</strong>。</p><p>现在看一看白箱聚集与外禀迭代器的实现。一个白箱聚集向外界提供访问自己内部元素的接口（称作遍历方法或者Traversing Method），从而使外禀迭代器可以通过聚集的遍历方法实现迭代功能。</p><p>因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代器角色往往仅仅保持迭代的游标位置。</p><p>一个典型的由白箱聚集与外禀迭代器组成的系统如下图所示，在这个实现中具体迭代器角色是一个外部类，而具体聚集角色向外界提供遍历聚集元素的接口。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/24/20241124-135617.png" alt="外禀迭代器"></p><p>迭代器模式涉及到以下几个角色：</p><ul><li>抽象迭代器器(Iterator)角色：此抽象角色定义出遍历元素所需的接口。</li><li>具体迭代器(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。</li><li>聚集(Aggregate)角色：此抽象角色给出创建迭代器(Iterator)对象的接口。</li><li>具体聚集(ConcreteAggregate)角色：实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。</li><li>客户端(Client)角色：持有对聚集及其迭代器对象的引用，调用迭代器对象的迭代接口，也有可能通过迭代器操作聚集元素的增加和删除。</li></ul><h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><blockquote><p>抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代器模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代器对象的实例。</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象聚集类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Aggregate</span> &#123;    <span class="comment">/**</span><span class="comment">     * 工厂方法, 创建相应的迭代器对象接口</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span>;&#125;</code></pre><blockquote><p>具体聚集角色类，实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 具体聚集类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">extends</span> <span class="title class_">Aggregate</span> &#123;    <span class="keyword">private</span> Object[] objArray = <span class="literal">null</span>;    <span class="comment">/**</span><span class="comment">     * 构造方法传入聚集数据</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> objArray</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="title function_">ConcreteAggregate</span><span class="params">(Object[] objArray)</span> &#123;        <span class="built_in">this</span>.objArray = objArray;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(<span class="built_in">this</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 取值方法：向外界提供聚集元素</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">getElement</span><span class="params">(<span class="type">int</span> index)</span> &#123;        <span class="keyword">if</span> (index &lt; objArray.length) &#123;            <span class="keyword">return</span> objArray[index];        &#125; <span class="keyword">else</span> &#123;            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 取值方法：向外界提供聚集的大小</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;        <span class="keyword">return</span> objArray.length;    &#125;&#125;</code></pre><blockquote><p>抽象迭代器角色类</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象迭代器角色类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;    <span class="comment">/**</span><span class="comment">     * 迭代方法：移动到第一个元素</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：移动到下一个元素</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：是否为最后一个元素</span><span class="comment">     */</span>    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：返还当前元素</span><span class="comment">     */</span>    Object <span class="title function_">currentItem</span><span class="params">()</span>;&#125;</code></pre><blockquote><p>具体迭代器角色类</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;    <span class="comment">// 持有迭代的具体的聚合对象</span>    <span class="keyword">private</span> <span class="type">ConcreteAggregate</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// 内部索引，记录当前迭代到的索引位置</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 记录当前聚集对象的大小</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(ConcreteAggregate aggregate)</span> &#123;        <span class="built_in">this</span>.aggregate = aggregate;        <span class="built_in">this</span>.size = aggregate.size();        <span class="built_in">this</span>.index = <span class="number">0</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 迭代方法,移动到第一个元素</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span> &#123;        index = <span class="number">0</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 迭代方法,移动到下一个元素</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (index &lt; size) &#123;            index++;        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 迭代方法:是否为最后一个元素</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;        <span class="keyword">return</span> index &gt;= size;    &#125;    <span class="comment">/**</span><span class="comment">     * 迭代方法：返还当前元素</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span> &#123;        <span class="keyword">return</span> aggregate.getElement(index);    &#125;&#125;</code></pre><blockquote><p>客户端</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Marray&quot;</span>, <span class="string">&quot;Green&quot;</span>&#125;;        <span class="comment">// 创建聚合角色</span>        <span class="type">Aggregate</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>(strings);        <span class="comment">// 创建迭代器</span>        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> aggregate.createIterator();        <span class="keyword">while</span> (!iterator.isDone()) &#123;            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) iterator.currentItem();            System.out.println(name);            iterator.next();        &#125;    &#125;&#125;</code></pre><blockquote><p>运行结果</p><pre><code class="highlight shell">TomJerryJackMarrayGreen</code></pre></blockquote><p>这个例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代器对象。在得到迭代器的实例后，客户端开始迭代过程，打印出所有的聚集元素。</p><h3 id="1-3-外禀迭代器的意义"><a href="#1-3-外禀迭代器的意义" class="headerlink" title="1.3 外禀迭代器的意义"></a>1.3 外禀迭代器的意义</h3><p>​        一个常常会问的问题是：既然白箱聚集已经向外界提供了遍历方法，客户端已经可以自行进行迭代了，为什么还要应用迭代器模式，并创建一个迭代器对象进行迭代呢？</p><p>　　客户端当然可以自行进行迭代，不一定非得需要一个迭代器对象。但是，迭代器对象和迭代模式会将迭代过程抽象化，将作为迭代消费者的客户端与迭代负责人的迭代器责任分隔开，使得两者可以独立的演化。在聚集对象的种类发生变化，或者迭代的方法发生改变时，迭代器作为一个中介层可以吸收变化的因素，而避免修改客户端或者聚集本身。</p><p>　　此外，如果系统需要同时针对几个不同的聚集对象进行迭代，而这些聚集对象所提供的遍历方法有所不同时，使用迭代器模式和一个外界的迭代器对象是有意义的。具有同一迭代接口的不同迭代器对象处理具有不同遍历接口的聚集对象，使得系统可以使用一个统一的迭代接口进行所有的迭代。</p><h2 id="2-黑箱聚集与内禀迭代器"><a href="#2-黑箱聚集与内禀迭代器" class="headerlink" title="2. 黑箱聚集与内禀迭代器"></a>2. 黑箱聚集与内禀迭代器</h2><h3 id="2-1-理论概述"><a href="#2-1-理论概述" class="headerlink" title="2.1 理论概述"></a>2.1 理论概述</h3><p>如果一个聚集的接口没有提供修改聚集元素的方法，这样的接口就是所谓的<strong>窄接口</strong>。</p><p>聚集对象为迭代器对象提供一个宽接口，而为其他对象提供一个窄接口。换言之，聚集对象的内部结构应当对迭代器对象适当公开，以便迭代器对象能够对聚集对象有足够的了解，从而可以进行迭代操作。但是，聚集对象应当避免向其他的对象提供这些方法，因为其他对象应当经过迭代器对象进行这些工作，而不是直接操控聚集对象。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/24/20241124-143320.png" alt="内禀迭代器"></p><p>在JAVA语言中，实现双重接口的办法就是将迭代器类设计成聚集类的内部成员类。这样迭代器对象将可以像聚集对象的内部成员一样访问聚集对象的内部结构。下面给出一个示意性的实现，说明这种双重接口的结构时怎么样产生的，以及使用了双重接口结构之后迭代器模式的实现方案。这种同时保证聚集对象的封装和迭代器功能的实现的方案叫做<strong>黑箱实现方案</strong>。</p><p>由于迭代器是聚集的内部类，迭代器可以自由访问聚集的元素，所以迭代器可以自行实现迭代功能并控制对聚集元素的迭代逻辑。由于迭代器是在聚集的结构之内定义的，因此这样的迭代器又叫做<strong>内禀迭代器（Intrinsic Iterator）。</strong></p><p>为了说明黑箱方案的细节，这里给出一个示意性的黑箱实现。在这个实现里，聚集类ConcreteAggregate含有一个内部成员类ConcreteIterator，也就是实现了抽象迭代器接口的具体迭代器类，同时聚集并不向外界提供访问自己内部元素的方法。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/24/20241124-143636.png" alt="内禀迭代器实现示例"></p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象聚集类</span><span class="comment"> 这个角色规定出所有的具体聚集必须实现的接口。迭代器模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代器对象的实例。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Aggregate</span> &#123;    <span class="comment">/**</span><span class="comment">     * 工厂方法, 创建相应的迭代器对象接口</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 抽象迭代器角色类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;    <span class="comment">/**</span><span class="comment">     * 迭代方法：移动到第一个元素</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：移动到下一个元素</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：是否为最后一个元素</span><span class="comment">     */</span>    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：返还当前元素</span><span class="comment">     */</span>    Object <span class="title function_">currentItem</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体聚集类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">extends</span> <span class="title class_">Aggregate</span> &#123;    <span class="keyword">private</span> Object[] objArray = <span class="literal">null</span>;    <span class="comment">/**</span><span class="comment">     * 构造方法传入聚集数据</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> objArray</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="title function_">ConcreteAggregate</span><span class="params">(Object[] objArray)</span> &#123;        <span class="built_in">this</span>.objArray = objArray;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>();    &#125;    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;        <span class="comment">// 内部索引，记录当前迭代到的索引位置</span>        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 记录当前聚集对象的大小</span>        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">()</span> &#123;            <span class="built_in">this</span>.size = objArray.length;            <span class="built_in">this</span>.index = <span class="number">0</span>;        &#125;        <span class="comment">/**</span><span class="comment">         * 迭代方法,移动到第一个元素</span><span class="comment">         */</span>        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span> &#123;            index = <span class="number">0</span>;        &#125;        <span class="comment">/**</span><span class="comment">         * 迭代方法,移动到下一个元素</span><span class="comment">         */</span>        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;            <span class="keyword">if</span> (index &lt; size) &#123;                index++;            &#125;        &#125;        <span class="comment">/**</span><span class="comment">         * 迭代方法:是否为最后一个元素</span><span class="comment">         * <span class="doctag">@return</span></span><span class="comment">         */</span>        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;            <span class="keyword">return</span> index &gt;= size;        &#125;        <span class="comment">/**</span><span class="comment">         * 迭代方法：返还当前元素</span><span class="comment">         */</span>        <span class="meta">@Override</span>        <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span> &#123;            <span class="keyword">return</span> objArray[index];        &#125;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Marray&quot;</span>, <span class="string">&quot;Green&quot;</span>&#125;;        <span class="comment">// 创建集合对象,传入数据</span>        <span class="type">Aggregate</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>(strings);        <span class="comment">// 创建迭代器</span>        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> aggregate.createIterator();        <span class="comment">// 循环打印元素</span>        <span class="keyword">while</span> (!iterator.isDone()) &#123;            System.out.println(iterator.currentItem());            iterator.next();        &#125;    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">TomJerryJackMarrayGreen</code></pre></blockquote><p>上面的例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代器对象。在得到迭代器的实例后，客户端开始迭代过程，打印出所有的聚集元素。</p><h1 id="三、主动迭代器和被动迭代器"><a href="#三、主动迭代器和被动迭代器" class="headerlink" title="三、主动迭代器和被动迭代器"></a>三、主动迭代器和被动迭代器</h1><ul><li>主动迭代器和被动迭代器又称作外部迭代器和内部迭代器。</li><li>所谓主动（外部）迭代器，指的是由客户端来控制迭代下一个元素的步骤，客户端会明显调用迭代器的next()等迭代方法，在遍历过程中向前进行。</li><li>所谓被动（内部）迭代器，指的是由迭代器自己来控制迭代下一个元素的步骤。因此，如果想要在迭代的过程中完成工作的话，客户端就需要把操作传递给迭代器，迭代器在迭代的时候会在每个元素上执行这个操作，类似于JAVA的回调机制。</li><li>总体来说外部迭代器比内部迭代器要灵活一些，因此我们常见的实现多属于主动迭代器。</li></ul><h1 id="四、静态迭代器和动态迭代器"><a href="#四、静态迭代器和动态迭代器" class="headerlink" title="四、静态迭代器和动态迭代器"></a>四、静态迭代器和动态迭代器</h1><ul><li><p>静态迭代器由聚集对象创建，并持有聚集对象的一份快照(snapshot)，在产生后这个快照的内容就不再变化。客户端可以继续修改原聚集的内容，但是迭代器对象不会反映出聚集的新变化。</p><p>静态迭代器的好处是它的安全性和简易性，换言之，静态迭代器易于实现，不容易出现错误。但是由于静态迭代器将原聚集复制了一份，因此它的短处是对时间和内存资源的消耗。</p></li><li><p>动态迭代器则与静态迭代器完全相反，在迭代器被产生之后，迭代器保持着对聚集元素的引用，因此，任何对原聚集内容的修改都会在迭代器对象上反映出来。</p><p>完整的动态迭代器不容易实现，但是简化的动态迭代器并不难实现。大多数JAVA设计师遇到的迭代器都是这种简化的动态迭代器。为了说明什么是简化的动态迭代器，首先需要介绍一个新的概念：<strong>Fail Fast</strong>。</p></li></ul><h1 id="五、Fail-Fast"><a href="#五、Fail-Fast" class="headerlink" title="五、Fail Fast"></a>五、Fail Fast</h1><p>如果一个算法开始之后，它的运算环境发生变化，使得算法无法进行必需的调整时，这个算法就应当立即发出故障信号。这就是Fail Fast的含义。</p><p>如果聚集对象的元素在一个动态迭代器的迭代过程中发生变化时，迭代过程会受到影响而变得不能自恰。这时候，迭代器就应当立即抛出一个异常。这种迭代器就是实现了Fail Fast功能的迭代器。</p><h2 id="1-Fail-Fast在JAVA聚集中的使用"><a href="#1-Fail-Fast在JAVA聚集中的使用" class="headerlink" title="1. Fail Fast在JAVA聚集中的使用"></a>1. Fail Fast在JAVA聚集中的使用</h2><p>JAVA语言以接口 <code>java.util.Iterator</code> 的方式支持迭代器模式，Collection接口要求提供<code>iterator()</code>方法，此方法在调用时返还一个Iterator类型的对象。而作为 Collection 接口的子类型，AbstractList 类的内部成员类Itr便是实现 Iterator 接口的类。</p><blockquote><p>Itr类的源代码如下所示</p></blockquote><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;        <span class="comment">/**</span><span class="comment">         * Index of element to be returned by subsequent call to next.</span><span class="comment">         */</span>        <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">/**</span><span class="comment">         * Index of element returned by most recent call to next or</span><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span><span class="comment">         * to remove.</span><span class="comment">         */</span>        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;        <span class="comment">/**</span><span class="comment">         * The modCount value that the iterator believes that the backing</span><span class="comment">         * List should have.  If this expectation is violated, the iterator</span><span class="comment">         * has detected concurrent modification.</span><span class="comment">         */</span>        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;                <span class="keyword">return</span> cursor != size();        &#125;        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;                checkForComodification();            <span class="keyword">try</span> &#123;            <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> get(cursor);            lastRet = cursor++;            <span class="keyword">return</span> next;            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;            checkForComodification();            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();            &#125;        &#125;        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;            <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();                checkForComodification();            <span class="keyword">try</span> &#123;            AbstractList.<span class="built_in">this</span>.remove(lastRet);            <span class="keyword">if</span> (lastRet &lt; cursor)                cursor--;            lastRet = -<span class="number">1</span>;            expectedModCount = modCount;            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();            &#125;        &#125;        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;            <span class="keyword">if</span> (modCount != expectedModCount)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();        &#125;&#125;</code></pre><p>从Itr类的源代码中可以看到，方法 <code>checkForComodification()</code> 会检查聚集的内容是否刚刚被外界直接修改过(不是通过迭代器提供的方法修改的)。如果在迭代开始后，聚集的内容被外界绕过迭代器对象而直接修改的话，这个方法会立即抛出<code>ConcurrentModificationException()</code> 异常。</p><p>这就是说，<code>AbstractList.Itr</code> 迭代器是一个Fail Fast的迭代器。</p><h1 id="六、迭代器模式的优点"><a href="#六、迭代器模式的优点" class="headerlink" title="六、迭代器模式的优点"></a>六、迭代器模式的优点</h1><ul><li><p>迭代器模式简化了聚集的接口。迭代器具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。</p></li><li><p>每一个聚集对象都可以有一个或多个迭代器对象，每一个迭代器的迭代状态可以是彼此独立的。因此，一个聚集对象可以同时有几个迭代在进行之中。</p></li><li><p>由于遍历算法被封装在迭代器角色里面，因此迭代的算法可以独立于聚集角色变化。</p></li></ul><p>  　　</p><p><strong>参考链接：</strong><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html">https://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;迭代器模式又叫游标(Cursor)模式，是对象的行为模式。迭代器模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（&lt;em&gt;internal representation&lt;/em&gt;）。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、聚集和Java聚集</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>17-访问者模式</title>
    <link href="https://georgechan95.github.io/blog/4fdf6e52.html"/>
    <id>https://georgechan95.github.io/blog/4fdf6e52.html</id>
    <published>2024-11-23T13:55:00.000Z</published>
    <updated>2024-11-23T09:42:23.551Z</updated>
    
    <content type="html"><![CDATA[<p><strong>访问者模式是对象的行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。</strong></p><h1 id="一、分派的概念"><a href="#一、分派的概念" class="headerlink" title="一、分派的概念"></a>一、分派的概念</h1><p>变量被声明时的类型叫做变量的静态类型(Static Type)，有些人又把静态类型叫做明显类型(Apparent Type)；而变量所引用的对象的真实类型又叫做变量的实际类型(Actual Type)。比如：</p><pre><code class="highlight java"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="literal">null</span>;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</code></pre><p>声明了一个变量list，它的静态类型（也叫明显类型）是List，而它的实际类型是ArrayList。</p><p>根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即<strong>静态分派</strong>和<strong>动态分派</strong>。</p><p>**静态分派(Static Dispatch)**发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。</p><p>**动态分派(Dynamic Dispatch)**发生在运行时期，动态分派动态地置换掉某个方法。</p><h2 id="1-静态分派"><a href="#1-静态分派" class="headerlink" title="1. 静态分派"></a>1. 静态分派</h2><p>Java通过方法重载支持静态分派。用墨子骑马的故事作为例子，墨子可以骑白马或者黑马。墨子与白马、黑马和马的类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-155058.png" alt="分派"></p><p>在这个系统中，墨子由Mozi类代表</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 静态分派：方法重载是根据静态类型进行的</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mozi</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ride</span><span class="params">(Horse h)</span>&#123;        System.out.println(<span class="string">&quot;骑马&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ride</span><span class="params">(WhiteHorse wh)</span>&#123;        System.out.println(<span class="string">&quot;骑白马&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ride</span><span class="params">(BlackHorse bh)</span>&#123;        System.out.println(<span class="string">&quot;骑黑马&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Horse</span> <span class="variable">wh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhiteHorse</span>();        <span class="type">Horse</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlackHorse</span>();        <span class="type">Mozi</span> <span class="variable">mozi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mozi</span>();        mozi.ride(wh);        mozi.ride(bh);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">骑马骑马</code></pre></blockquote><p>显然，Mozi类的ride()方法是由三个方法重载而成的。这三个方法分别接受马(Horse)、白马(WhiteHorse)、黑马(BlackHorse)等类型的参数。</p><p>那么在运行时，程序会打印出什么结果呢？结果是程序会打印出相同的两行“骑马”。换言之，墨子发现他所骑的都是马。</p><p>为什么呢？两次对ride()方法的调用传入的是不同的参数，也就是wh和bh。它们虽然具有不同的真实类型，但是它们的静态类型都是一样的，均是Horse类型。</p><p><strong>重载方法</strong>的分派是根据<strong>静态类型</strong>进行的，这个分派过程在编译时期就完成了。</p><h2 id="2-动态分派"><a href="#2-动态分派" class="headerlink" title="2. 动态分派"></a>2. 动态分派</h2><p>Java通过<strong>方法的重写</strong>支持动态分派。用马吃草的故事作为例子，代码如下所示：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Horse</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;马吃草&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackHorse</span> <span class="keyword">extends</span> <span class="title class_">Horse</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;黑马吃草&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhiteHorse</span> <span class="keyword">extends</span> <span class="title class_">Horse</span> &#123;        <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;白马吃草&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Horse</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlackHorse</span>();        h.eat();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">黑马吃草</code></pre></blockquote><p>变量h的静态类型是Horse，而真实类型是BlackHorse。如果上面最后一行的eat()方法调用的是BlackHorse类的eat()方法，那么上面打印的就是“黑马吃草”；相反，如果上面的eat()方法调用的是Horse类的eat()方法，那么打印的就是“马吃草”。</p><p>所以，问题的核心就是Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。这样一来，上面最后一行的eat()方法调用的是BlackHorse类的eat()方法，打印的是“黑马吃草”。</p><h2 id="3-分派的类型"><a href="#3-分派的类型" class="headerlink" title="3. 分派的类型"></a>3. 分派的类型</h2><p>一个方法所属的对象叫做方法的接收者，方法的接收者与方法的参数统称做方法的宗量。比如下面例子中的Test类:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;        System.out.println(str);    &#125;&#125;</code></pre><p>在上面的类中，print()方法属于Test对象，所以它的接收者也就是Test对象了。print()方法有一个参数是str,它的类型是String。</p><p>根据分派可以基于多少种宗量，可以将面向对象的语言划分为单分派语言(Uni-Dispatch)和多分派语言(Multi-Dispatch)。单分派语言根据一个宗量的类型进行对方法的选择，多分派语言根据多于一个的宗量的类型对方法进行选择。</p><p>C++和Java均是单分派语言，多分派语言的例子包括CLOS和Cecil。按照这样的区分，Java就是<strong>动态的单分派语言</strong>，因为这种语言的动态分派仅仅会考虑到方法的接收者的类型，同时又是<strong>静态的多分派语言</strong>，因为这种语言对重载方法的分派会考虑到方法的接收者的类型以及方法的所有参数的类型。</p><p>在一个支持动态单分派的语言里面，有两个条件决定了一个请求会调用哪一个操作：一是请求的名字，二是接收者的真实类型。单分派限制了方法的选择过程，使得只有一个宗量可以被考虑到，这个宗量通常就是方法的接收者。在Java语言里面，如果一个操作是作用于某个类型不明的对象上面，那么对这个对象的真实类型测试仅会发生一次，这就是动态的单分派的特征。</p><h2 id="4-双重分派"><a href="#4-双重分派" class="headerlink" title="4. 双重分派"></a>4. 双重分派</h2><p>一个方法根据两个宗量的类型来决定执行不同的代码，这就是“双重分派”。Java语言不支持动态的多分派，也就意味着Java不支持动态的双分派。但是通过使用设计模式，也可以在Java语言里实现动态的双重分派。</p><p>在Java中可以通过两次方法调用来达到两次分派的目的。类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-161136.png" alt="双重分派"></p><p>在图中有两个对象，左边的叫做West，右边的叫做East。现在West对象首先调用East对象的 <code>goEast()</code> 方法，并将它自己传入。在East对象被调用时，立即根据传入的参数知道了调用者是谁，于是反过来调用“调用者”对象的 <code>goWest()</code> 方法。通过两次调用将程序控制权轮番交给两个对象，其时序图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-161216.png" alt="双重分派-时序图"></p><p>这样就出现了两次方法调用，程序控制权被两个对象像传球一样，首先由West对象传给了East对象，然后又被返传给了West对象。</p><p>但是仅仅返传了一下球，并不能解决双重分派的问题。关键是怎样利用这两次调用，以及Java语言的动态单分派功能，使得在这种传球的过程中，能够触发两次单分派。</p><p>动态单分派在Java语言中是在子类重写父类的方法时发生的。换言之，West和East都必须分别置身于自己的类型等级结构中，如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-161503.png" alt="双重分派实现"></p><p><strong>代码实现：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">West</span> &#123;    <span class="comment">// 传入East子类作为参数</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">goWest1</span><span class="params">(SubEast1 east)</span>;    <span class="comment">// 传入East子类作为参数</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">goWest2</span><span class="params">(SubEast2 east)</span>;&#125; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubWest1</span> <span class="keyword">extends</span> <span class="title class_">West</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goWest1</span><span class="params">(SubEast1 east)</span> &#123;        System.out.println(<span class="string">&quot;SubWest1 + &quot;</span> + east.myName1());    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goWest2</span><span class="params">(SubEast2 east)</span> &#123;        System.out.println(<span class="string">&quot;SubWest1 + &quot;</span> + east.myName2());    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubWest2</span> <span class="keyword">extends</span> <span class="title class_">West</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goWest1</span><span class="params">(SubEast1 east)</span> &#123;        System.out.println(<span class="string">&quot;SubWest2 + &quot;</span> + east.myName1());    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goWest2</span><span class="params">(SubEast2 east)</span> &#123;        System.out.println(<span class="string">&quot;SubWest2 + &quot;</span> + east.myName2());    &#125;&#125;<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">East</span> &#123;    <span class="comment">// 传入West接口作为参数</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">goEast</span><span class="params">(West west)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubEast1</span> <span class="keyword">extends</span> <span class="title class_">East</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goEast</span><span class="params">(West west)</span> &#123;        west.goWest1(<span class="built_in">this</span>);    &#125;    <span class="keyword">public</span> String <span class="title function_">myName1</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;SubEast1&quot;</span>;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubEast2</span> <span class="keyword">extends</span> <span class="title class_">East</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goEast</span><span class="params">(West west)</span> &#123;        west.goWest2(<span class="built_in">this</span>);    &#125;    <span class="keyword">public</span> String <span class="title function_">myName2</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;SubEast2&quot;</span>;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 组合1</span>        <span class="type">East</span> <span class="variable">east</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubEast1</span>();        <span class="type">West</span> <span class="variable">west</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubWest1</span>();        east.goEast(west);        <span class="comment">// 组合2</span>        east = <span class="keyword">new</span> <span class="title class_">SubEast2</span>();        west = <span class="keyword">new</span> <span class="title class_">SubWest2</span>();        east.goEast(west);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">SubWest1 + SubEast1SubWest2 + SubEast2</code></pre></blockquote><p>系统运行时，会首先创建SubWest1和SubEast1对象，然后客户端调用SubEast1的goEast()方法，并将SubWest1对象传入。由于SubEast1对象重写了其超类East的goEast()方法，因此，这个时候就发生了一次动态的单分派。当SubEast1对象接到调用时，会从参数中得到SubWest1对象，所以它就立即调用这个对象的goWest1()方法，并将自己传入。由于SubEast1对象有权选择调用哪一个对象，因此，在此时又进行一次动态的方法分派。</p><p>这个时候SubWest1对象就得到了SubEast1对象。通过调用这个对象myName1()方法，就可以打印出自己的名字和SubEast对象的名字，其时序图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-165652.png" alt="动态双重分派时序图"></p><p>由于这两个名字一个来自East等级结构，另一个来自West等级结构中，因此，它们的组合式是动态决定的。这就是动态双重分派的实现机制。</p><h1 id="二、访问者模式的结构"><a href="#二、访问者模式的结构" class="headerlink" title="二、访问者模式的结构"></a>二、访问者模式的结构</h1><p>访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。访问者模式的简略图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-165944.png" alt="访问者模式结构示意"></p><h2 id="1-案例解析"><a href="#1-案例解析" class="headerlink" title="1. 案例解析"></a>1. 案例解析</h2><p>数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。这样的过程叫做“双重分派”。节点调用访问者，将它自己传入，访问者则将某算法针对此节点执行。访问者模式的示意性类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-170342.png" alt="访问者模式"></p><p>访问者模式涉及到的角色如下：</p><ul><li><strong>抽象访问者(Visitor)角色：</strong>声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。</li><li><strong>具体访问者(ConcreteVisitor)角色：</strong>实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。</li><li><strong>抽象节点(Node)角色：</strong>声明一个接受操作，接受一个访问者对象作为一个参数。</li><li><strong>具体节点(ConcreteNode)角色：</strong>实现了抽象节点所规定的接受操作。</li><li><strong>结构对象(ObjectStructure)角色：</strong>有如下的责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。</li></ul><p><strong>代码实现如下：</strong></p><p>可以看到，抽象访问者角色为每一个具体节点都准备了一个访问操作。由于有两个节点，因此，对应就有两个访问操作。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象访问者对象</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;    <span class="comment">/**</span><span class="comment">     * 对于具体节点NodeA的访问操作</span><span class="comment">     * <span class="doctag">@param</span> nodeA</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeA nodeA)</span>;    <span class="comment">/**</span><span class="comment">     * 对于具体节点NodeB的访问操作</span><span class="comment">     * <span class="doctag">@param</span> nodeB</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeB nodeB)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体的访问者A类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorA</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeA nodeA)</span> &#123;        System.out.println(nodeA.operationA());    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeB nodeB)</span> &#123;        System.out.println(nodeB.operationB());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的访问者B类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorB</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeA nodeA)</span> &#123;        System.out.println(nodeA.operationA());    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeB nodeB)</span> &#123;        System.out.println(nodeB.operationB());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象节点类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;    <span class="comment">/**</span><span class="comment">     * 接受操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体节点类A</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeA</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;    <span class="comment">/**</span><span class="comment">     * 接受操作</span><span class="comment">     * <span class="doctag">@param</span> visitor</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;        visitor.visit(<span class="built_in">this</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * NodeA特有的方法</span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">operationA</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;NodeA&quot;</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体节点类A</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeB</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;    <span class="comment">/**</span><span class="comment">     * 接受操作</span><span class="comment">     * <span class="doctag">@param</span> visitor</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;        visitor.visit(<span class="built_in">this</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * NodeB特有的方法</span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">operationB</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;NodeB&quot;</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 结构对象角色类，</span><span class="comment"> * 这个结构对象角色持有一个聚集，并向外界提供add()方法作为对聚集的管理操作。通过调用这个方法，可以动态地增加一个新的节点。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;    <span class="keyword">private</span> List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 执行方法操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(Visitor visitor)</span> &#123;        <span class="keyword">for</span> (Node node : nodes) &#123;            node.accept(visitor);        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 添加一个新元素</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;        nodes.add(node);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 客户端类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建一个结构对象</span>        <span class="type">ObjectStructure</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStructure</span>();        <span class="comment">//给结构增加一个节点</span>        os.add(<span class="keyword">new</span> <span class="title class_">NodeA</span>());        <span class="comment">//给结构增加一个节点</span>        os.add(<span class="keyword">new</span> <span class="title class_">NodeB</span>());        <span class="type">Visitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VisitorA</span>();        os.action(visitor);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">NodeANodeB</code></pre></blockquote><p>虽然在这个示意性的实现里并没有出现一个复杂的具有多个树枝节点的对象树结构，但是，在实际系统中访问者模式通常是用来处理复杂的对象树结构的，而且访问者模式可以用来处理跨越多个等级结构的树结构问题。这正是访问者模式的功能强大之处。</p><h2 id="2-准备过程时序图"><a href="#2-准备过程时序图" class="headerlink" title="2. 准备过程时序图"></a>2. 准备过程时序图</h2><ul><li>首先，这个示意性的客户端创建了一个结构对象，然后将一个新的NodeA对象和一个新的NodeB对象传入。</li><li>其次，客户端创建了一个VisitorA对象，并将此对象传给结构对象。</li><li>然后，客户端调用结构对象聚集管理方法，将NodeA和NodeB节点加入到结构对象中去。</li><li>最后，客户端调用结构对象的行动方法action()，启动访问过程。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-173733.png" alt="准备过程时序图"></p><h2 id="3-访问过程时序图"><a href="#3-访问过程时序图" class="headerlink" title="3. 访问过程时序图"></a>3. 访问过程时序图</h2><p>结构对象会遍历它自己所保存的聚集中的所有节点，在本系统中就是节点NodeA和NodeB。首先NodeA会被访问到，这个访问是由以下的操作组成的：</p><ul><li>NodeA对象的接受方法accept()被调用，并将VisitorA对象本身传入；</li><li>NodeA对象反过来调用VisitorA对象的访问方法，并将NodeA对象本身传入；</li><li>VisitorA对象调用NodeA对象的特有方法operationA()。</li></ul><p>从而就完成了双重分派过程，接着，NodeB会被访问，这个访问的过程和NodeA被访问的过程是一样的，这里不再叙述。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-173749.png" alt="访问过程时序图"></p><h1 id="三、访问者模式的优缺点"><a href="#三、访问者模式的优缺点" class="headerlink" title="三、访问者模式的优缺点"></a>三、访问者模式的优缺点</h1><p><strong>访问者模式的优点</strong></p><ul><li><p><strong>好的扩展性</strong></p><p>能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p></li><li><p><strong>好的复用性</strong></p><p>可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</p></li><li><p><strong>分离无关行为</strong></p><p>可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</p></li></ul><p><strong>访问者模式的缺点</strong></p><ul><li><p><strong>对象结构变化很困难</strong></p><p>不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。</p></li><li><p><strong>破坏封装</strong></p><p>访问者模式通常需要对象结构开放内部数据给访问者和 ObjectStructrue，这破坏了对象的封装性。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;访问者模式是对象的行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、分派的概念&quot;&gt;&lt;a href=&quot;#一、分派的概念&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>16-命令模式</title>
    <link href="https://georgechan95.github.io/blog/60fd53f.html"/>
    <id>https://georgechan95.github.io/blog/60fd53f.html</id>
    <published>2024-11-23T12:30:00.000Z</published>
    <updated>2024-11-23T07:05:24.708Z</updated>
    
    <content type="html"><![CDATA[<p><strong>命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。</strong></p><p><strong>命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</strong></p><h1 id="一、命令模式的结构"><a href="#一、命令模式的结构" class="headerlink" title="一、命令模式的结构"></a>一、命令模式的结构</h1><p>命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。</p><p>每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p><p>命令允许请求的一方和接收请求的一方能够独立演化，从而具有以下的优点：</p><ul><li><p>命令模式使新的命令很容易地被加入到系统里。</p></li><li><p>允许接收请求的一方决定是否要否决请求。</p></li><li><p>能较容易地设计一个命令队列。</p></li><li><p>可以容易地实现对请求的撤销和恢复。</p></li><li><p>在需要的情况下，可以较容易地将命令记入日志。</p></li></ul><p>下面以一个示意性的系统，说明命令模式的结构。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-140717.png" alt="命令模式UML"></p><p>命令模式涉及到五个角色，它们分别是：</p><ul><li><strong>客户端(Client)角色：</strong>创建一个具体命令(ConcreteCommand)对象并确定其接收者。</li><li><strong>命令(Command)角色：</strong>声明了一个给所有具体命令类的抽象接口。</li><li><strong>具体命令(ConcreteCommand)角色：</strong>定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。</li><li><strong>请求者(Invoker)角色：</strong>负责调用命令对象执行请求，相关的方法叫做行动方法。</li><li><strong>接收者(Receiver)角色：</strong>负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li></ul><p><strong>代码示例</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 命令接收者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;    <span class="comment">/**</span><span class="comment">     * 真正执行命令相应的操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;==命令接收者执行操作==&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象命令角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 聚合命令接收者</span>    <span class="keyword">private</span> Receiver receiver;    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;        <span class="built_in">this</span>.receiver = receiver;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        <span class="comment">// 调用接收者执行具体的方法</span>        receiver.action();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 请求者角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;    <span class="comment">// 聚合抽象命令角色</span>    <span class="keyword">private</span> Command command;    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;        <span class="built_in">this</span>.command = command;    &#125;    <span class="comment">/**</span><span class="comment">     * 行动方法：调用命令对象执行请求</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;        command.execute();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 命令接收者</span>        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();        <span class="comment">// 创建命令对象，将命令接受者设置进去</span>        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(receiver);        <span class="comment">// 创建请求执行者，并将命令对象设置进去</span>        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>(command);        <span class="comment">// 执行命令</span>        invoker.action();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">==命令接收者执行操作==</code></pre></blockquote><h1 id="二、案例：AudioPlayer系统"><a href="#二、案例：AudioPlayer系统" class="headerlink" title="二、案例：AudioPlayer系统"></a>二、案例：AudioPlayer系统</h1><p>小女孩茱丽(Julia)有一个盒式录音机，此录音机有播音(Play)、倒带(Rewind)和停止(Stop)功能，录音机的键盘便是请求者(Invoker)角色；茱丽(Julia)是客户端角色，而录音机便是接收者角色。Command类扮演抽象命令角色，而PlayCommand、StopCommand和RewindCommand便是具体命令类。茱丽(Julia)不需要知道播音(play)、倒带(rewind)和停止(stop)功能是怎么具体执行的，这些命令执行的细节全都由键盘(Keypad)具体实施。茱丽(Julia)只需要在键盘上按下相应的键便可以了。</p><p>录音机是典型的命令模式。录音机按键把客户端与录音机的操作细节分割开来。</p><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-142909.png" alt="命令模式案例：AudioPlayer系统"></p><p><strong>代码如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 接收者角色：录音机</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AudioPlayer</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;录音机播放...&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;录音机倒带...&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;录音机停止...&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 命令角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色：播放命令</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 命令接收者</span>    <span class="keyword">private</span> AudioPlayer audioPlayer;    <span class="keyword">public</span> <span class="title function_">PlayCommand</span><span class="params">(AudioPlayer audioPlayer)</span> &#123;        <span class="built_in">this</span>.audioPlayer = audioPlayer;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        audioPlayer.play();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色：倒带命令</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RewindCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 命令接收者</span>    <span class="keyword">private</span> AudioPlayer audioPlayer;    <span class="keyword">public</span> <span class="title function_">RewindCommand</span><span class="params">(AudioPlayer audioPlayer)</span> &#123;        <span class="built_in">this</span>.audioPlayer = audioPlayer;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        audioPlayer.rewind();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色：停止命令</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 命令接收者</span>    <span class="keyword">private</span> AudioPlayer audioPlayer;    <span class="keyword">public</span> <span class="title function_">StopCommand</span><span class="params">(AudioPlayer audioPlayer)</span> &#123;        <span class="built_in">this</span>.audioPlayer = audioPlayer;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        audioPlayer.stop();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 请求者角色：键盘</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Keypad</span> &#123;    <span class="keyword">private</span> Command playCommand;    <span class="keyword">private</span> Command rewindCommand;    <span class="keyword">private</span> Command stopCommand;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPlayCommand</span><span class="params">(Command playCommand)</span> &#123;        <span class="built_in">this</span>.playCommand = playCommand;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRewindCommand</span><span class="params">(Command rewindCommand)</span> &#123;        <span class="built_in">this</span>.rewindCommand = rewindCommand;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStopCommand</span><span class="params">(Command stopCommand)</span> &#123;        <span class="built_in">this</span>.stopCommand = stopCommand;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行播放方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;        playCommand.execute();    &#125;    <span class="comment">/**</span><span class="comment">     * 执行倒带方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span>&#123;        rewindCommand.execute();    &#125;    <span class="comment">/**</span><span class="comment">     * 执行播放方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;        stopCommand.execute();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Julia</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建接收者对象</span>        <span class="type">AudioPlayer</span> <span class="variable">audioPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AudioPlayer</span>();        <span class="comment">// 创建命令对象</span>        <span class="type">Command</span> <span class="variable">playCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlayCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">rewindCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RewindCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">stopCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopCommand</span>(audioPlayer);        <span class="comment">// 创建请求者对象</span>        <span class="type">Keypad</span> <span class="variable">keypad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Keypad</span>();        keypad.setPlayCommand(playCommand);        keypad.setRewindCommand(rewindCommand);        keypad.setStopCommand(stopCommand);        <span class="comment">// 测试</span>        keypad.play();        keypad.stop();        keypad.rewind();        keypad.stop();        keypad.play();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">录音机播放...录音机停止...录音机倒带...录音机停止...录音机播放...</code></pre></blockquote><h1 id="三、宏命令"><a href="#三、宏命令" class="headerlink" title="三、宏命令"></a>三、宏命令</h1><p>所谓宏命令简单点说就是包含多个命令的命令，是一个命令的组合。</p><p>设想茱丽的录音机有一个记录功能，可以把一个一个的命令记录下来，再在任何需要的时候重新把这些记录下来的命令一次性执行，这就是所谓的宏命令集功能。因此，茱丽的录音机系统现在有四个键，分别为播音、倒带、停止和宏命令功能。此时系统的设计与前面的设计相比有所增强，主要体现在Julia类现在有了一个新方法，用以操作宏命令键。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-144947.png" alt="宏命令"></p><p><strong>代码如下：</strong></p><p>系统需要一个代表宏命令的接口，以定义出具体宏命令所需要的接口。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 系统需要一个代表宏命令的接口，以定义出具体宏命令所需要的接口。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MacroCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;    <span class="comment">/**</span><span class="comment">     * 宏命令聚集的管理方法，可以添加一个成员命令</span><span class="comment">     * <span class="doctag">@param</span> cmd</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Command cmd)</span>;    <span class="comment">/**</span><span class="comment">     * 宏命令聚集的管理方法, 可以删除一个成员命令</span><span class="comment">     * <span class="doctag">@param</span> cmd</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Command cmd)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体的宏命令MacroAudioCommand类负责把个别的命令合成宏命令。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacroAudioCommand</span> <span class="keyword">implements</span> <span class="title class_">MacroCommand</span> &#123;    List&lt;Command&gt; commandList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Command cmd)</span> &#123;        commandList.add(cmd);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Command cmd)</span> &#123;        commandList.remove(cmd);    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        <span class="keyword">for</span> (Command command : commandList) &#123;            command.execute();        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Julia</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建接收者对象</span>        <span class="type">AudioPlayer</span> <span class="variable">audioPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AudioPlayer</span>();        <span class="comment">//创建命令对象</span>        <span class="type">Command</span> <span class="variable">playCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlayCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">rewindCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RewindCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">stopCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopCommand</span>(audioPlayer);        <span class="type">MacroCommand</span> <span class="variable">marco</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacroAudioCommand</span>();        marco.add(playCommand);        marco.add(rewindCommand);        marco.add(stopCommand);        marco.execute();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">录音机播放...录音机倒带...录音机停止..</code></pre></blockquote><h1 id="四、命令模式的优点"><a href="#四、命令模式的优点" class="headerlink" title="四、命令模式的优点"></a>四、命令模式的优点</h1><ul><li><p><strong>更松散的耦合</strong></p><p>命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。</p></li><li><p><strong>更动态的控制</strong></p><p>命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。</p></li><li><p><strong>很自然的复合命令</strong></p><p>命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。</p></li><li><p><strong>更好的扩展性</strong></p><p>由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>15-模板方法模式</title>
    <link href="https://georgechan95.github.io/blog/4930323d.html"/>
    <id>https://georgechan95.github.io/blog/4930323d.html</id>
    <published>2024-11-23T11:40:00.000Z</published>
    <updated>2024-11-23T05:12:39.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是模板方法设计模式"><a href="#一、什么是模板方法设计模式" class="headerlink" title="一、什么是模板方法设计模式"></a>一、什么是模板方法设计模式</h1><p>从字面意义上理解, 模板方法就是定义出来一套方法, 作为模板, 也就是基础。 在这个基础上, 我们可以进行加工，实现个性化的实现。比如：一日餐三. 早餐, 中餐, 晚餐. 每个人都要吃三餐, 但每个人的三餐吃的可能都不一样. 一日三餐定义了模板–早中晚, 每个人的三餐就是模板的具体实现.</p><h2 id="1-模板方法的用途"><a href="#1-模板方法的用途" class="headerlink" title="1. 模板方法的用途"></a>1. 模板方法的用途</h2><ul><li>将不变的行为从子类搬到超类，去除了子类中的重复代码。</li><li>规范子类的结构</li></ul><h2 id="2-模板方法的定义"><a href="#2-模板方法的定义" class="headerlink" title="2. 模板方法的定义"></a>2. 模板方法的定义</h2><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类<strong>行为型模式</strong>。</p><h1 id="二、定义模板方法的步骤"><a href="#二、定义模板方法的步骤" class="headerlink" title="二、定义模板方法的步骤"></a>二、定义模板方法的步骤</h1><blockquote><p>第一步: 定义模板类 </p><p>第二步: 定义具体子类 </p><p>第三步: 客户端调用</p></blockquote><p>下面来了解每一个步骤：</p><h2 id="1-定义模板类"><a href="#1-定义模板类" class="headerlink" title="1. 定义模板类"></a>1. 定义模板类</h2><p>通常模板类是抽象类，负责给出算法的轮廓或者框架。他是有若干个<strong>模板方法</strong>和若干个<strong>基本方法</strong>构成。</p><h3 id="1-1-模板方法"><a href="#1-1-模板方法" class="headerlink" title="1.1 模板方法"></a>1.1 模板方法</h3><p>定义了算法的骨架， 定义了方法调用的顺序， 其中包含一个或者多个基本方法</p><h3 id="1-2-基本方法"><a href="#1-2-基本方法" class="headerlink" title="1.2 基本方法"></a>1.2 基本方法</h3><p>基本方法有三种类型：</p><ul><li>抽象方法：子类必须重写的方法。没有默认实现。</li><li>具体方法：父类定义的默认实现，有实现逻辑，可以被具体的子类继承或重写</li><li>钩子方法：判断的逻辑方法和需要子类重写的空方法两种。</li></ul><h2 id="2-定义具体子类"><a href="#2-定义具体子类" class="headerlink" title="2. 定义具体子类"></a>2. 定义具体子类</h2><p>具体子类，也就是具体的实现类， 实现抽象类中的抽象方法。他们是抽象的模板方法中一个组成部分。</p><h2 id="3-定义客户端调用"><a href="#3-定义客户端调用" class="headerlink" title="3. 定义客户端调用"></a>3. 定义客户端调用</h2><p>客户端调用抽象类， 实例化的时候实例化具体类， 只需要调用抽象类的模板方法就可以了。</p><h2 id="4-实例演示"><a href="#4-实例演示" class="headerlink" title="4. 实例演示"></a>4. 实例演示</h2><p>下面来看一下抽象类和子类之间的UML图和源码实现</p><p><strong>UML类图</strong></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-102632.png" alt="模板方法设计模式" style="zoom: 50%;" /><p>从图中可以看出抽象类的结构可以定义三类方法。 可以有一个也可以有多个。子类必须需要实现抽象类中的抽象方法，可以选择性重写父类的具体方法。子类实现接口的时候，要多思考设计模式的六大原则。</p><p><strong>代码实现</strong></p><ul><li><p>先定义抽象类， 也就是框架。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象类, 定义模板</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;    <span class="comment">/**</span><span class="comment">     * 模板方法</span><span class="comment">     * 规范了流程的框架</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;        <span class="comment">// 先调用具体方法</span>        specificMethod();        <span class="comment">// 在调用抽象方法</span>        abstractMethod();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificMethod</span><span class="params">()</span> &#123;        <span class="comment">// 具体的公共逻辑, 父子类通用</span>        System.out.println(<span class="string">&quot;具体方法---父子类通用逻辑&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 抽象方法</span><span class="comment">     * 抽象方法, 子类必须重写</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;&#125;</code></pre></li><li><p>定义具体的实现类， 实现父类的抽象方法</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 具体实现类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;    <span class="comment">/**</span><span class="comment">     * 重写父类的抽象方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;具体实现类--重写父类的抽象方法&quot;</span>);    &#125;&#125;</code></pre></li><li><p>最后定义客户端调用</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 模板方法客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateClient</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AbstractClass</span> <span class="variable">abstractClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();        abstractClass.templateMethod();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">具体方法---父子类通用逻辑具体实现类--重写父类的抽象方法</code></pre></blockquote></li></ul><p>对照模板方法设计模式，我们来看一个具体的案例。</p><h1 id="三、案例解析"><a href="#三、案例解析" class="headerlink" title="三、案例解析"></a>三、案例解析</h1><h2 id="1-案例1：-一日规划"><a href="#1-案例1：-一日规划" class="headerlink" title="1. 案例1： 一日规划"></a>1. 案例1： 一日规划</h2><p>每个人的一日安排都有三餐， 早餐， 中餐，晚参。 但每个人的三餐食物不尽相同，我们来看看每个人的三餐变化， 以及三餐前后要做的事情。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 一日三餐抽象类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ArrangementAbstract</span> &#123;    <span class="comment">/**</span><span class="comment">     * 模板方法</span><span class="comment">     * 规定了一天的框架</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;一日安排如下: &quot;</span>);        getUp();        breakfast();        lunch();        dinner();        getDown();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUp</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;起床&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDown</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;睡觉&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 早餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">breakfast</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 午餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lunch</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 晚餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">dinner</span><span class="params">()</span>;&#125;</code></pre><p>定义一日三餐抽象类。每个人的日程安排都是，起床，早餐，中餐，晚餐，睡觉。 其中起床和睡觉是每个人都要做的事情，三餐也是，但三餐的食物不同，于是我们将三餐定义为抽象</p><p>一日安排实现类</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 张三的一日三餐安排</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonArrangement</span> <span class="keyword">extends</span> <span class="title class_">ArrangementAbstract</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">PersonArrangement</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="comment">/**</span><span class="comment">     * 早餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breakfast</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot;--早餐吃牛奶面包&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 午餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lunch</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot;--中餐吃食堂&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 晚餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dinner</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot;--晚餐吃水果&quot;</span>);    &#125;&#125;</code></pre><p>客户端调用</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ArrangementAbstract</span> <span class="variable">arrangementAbstract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonArrangement</span>(<span class="string">&quot;张三&quot;</span>);        arrangementAbstract.templateMethod();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">一日安排如下: 起床张三--早餐吃牛奶面包张三--中餐吃食堂张三--晚餐吃水果睡觉</code></pre></blockquote><p>可以看出， 完全按照模板方法的步骤实现。</p><h2 id="2-案例2：-钩子方法"><a href="#2-案例2：-钩子方法" class="headerlink" title="2. 案例2： 钩子方法"></a>2. 案例2： 钩子方法</h2><p>我们上面说了, 模板方法设计模式中, 基本方法包括抽象方法,具体方法和钩子方法. 如果能够使用好钩子方法, 可以在程序中完美实现子类控制父类的行为. 我们来看下面的案例:</p><p>我们在抽象方法中定义一个钩子方法 <code>hookMethod()</code> , 在模板方法 <code>templateMethod()</code> 中,钩子方法控制了代码的流程.</p><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-121856.png" alt="模板方法模式-钩子方法"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象类, 定义模板</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;    <span class="comment">/**</span><span class="comment">     * 定义模板方法</span><span class="comment">     * 规范了流程的框架</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;        <span class="comment">// 调用具体方法</span>        specificMethod();        <span class="comment">// 钩子方法控制下一步骤</span>        <span class="keyword">if</span> (hookMethod()) &#123;            <span class="comment">// 调用抽象方法</span>            abstractMethod();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 具体方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificMethod</span><span class="params">()</span> &#123;        <span class="comment">// 具体的公共逻辑, 父子类通用</span>        System.out.println(<span class="string">&quot;具体方法---父子类通用逻辑&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 抽象方法</span><span class="comment">     *</span><span class="comment">     * 抽象方法, 子类必须重写</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 钩子方法</span><span class="comment">     * 钩子方法是有具体实现的,</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hookMethod</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体实现类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span>&#123;    <span class="comment">/**</span><span class="comment">     * 重写父类的抽象方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;具体实现类--重写父类的抽象方法&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 子类重写钩子方法，非必须</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hookMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;重写了父类的钩子方法, 反向控制父类的行为&quot;</span>);        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateClient</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AbstractClass</span> <span class="variable">abstractClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();        abstractClass.templateMethod();    &#125;&#125;</code></pre><blockquote><p>运行结果</p><pre><code class="highlight shell">具体方法---父子类通用逻辑重写了父类的钩子方法, 反向控制父类的行为</code></pre></blockquote><p>如果子类钩子方法 <code>HookMethod()</code> 的代码改变，则程序的运行结果也会发生改变。</p><h1 id="四、模板方法的优缺点"><a href="#四、模板方法的优缺点" class="headerlink" title="四、模板方法的优缺点"></a>四、模板方法的优缺点</h1><p><strong>优点</strong></p><ul><li>规范了框架, 封装了不变的部分, 扩展了可变的部分. 父类定义框架, 并抽象了公共不变的部分, 子类通过重写扩展完善了框架的实现.</li><li>使用了”开闭原则”, 对扩展开放, 对修改关闭. 子类可以通过重写父类的抽象方法来扩展父类的实现.</li><li>行为集中有父类控制, 规范流程。</li></ul><p><strong>缺点</strong></p><ul><li>每一种实现都需要定义一个具体实现类, 增加类的数量, 系统更加复杂</li><li>继承的缺点, 一旦父类增加一个抽象方法, 所有子类都需要增加. 这一点违背”开闭原则”.</li><li>父类中的抽象方法由子类实现, 子类的执行结果影响父类, 这种”反向控制”结构, 会增加代码的复杂性。</li></ul><h1 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h1><ul><li>算法的整体步骤是固定的，但个别部分容易发生变化时，可以考虑使用模板方法设计模式，将容易发生变化的部分抽象出来，提供给子类去实现。</li><li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li><li>重构时，模板方法模式是一个经常使用到的模式，把相同的代码抽取到父类中，通过钩子函数约束其行为</li></ul><h1 id="六、对设计模式六大原则的应用思考"><a href="#六、对设计模式六大原则的应用思考" class="headerlink" title="六、对设计模式六大原则的应用思考"></a>六、对设计模式六大原则的应用思考</h1><ul><li>单一职责原则: 一个方法只有一个引起变化的原因, 这个不太好看出, 要看子类代码的具体实现</li><li>里式替换原则： 父类出现的地方都可以使用子类替换,并且结果保持一致. 子类重写了父类的方法。 模板方法设计模式可能违背里式替换原则, 不过，这正是能够“反向控制”的原理</li><li>接口隔离原则: 依赖于最小的单一接口, 而不是胖接口. 符合</li><li>依赖倒置原则: 依赖于抽象, 而不是依赖于具体. 符合</li><li>迪米特法则: 最少知识原则. 之和朋友沟通, 减少和朋友的沟通. 这个需要看子类具体实现是否符合</li><li>开闭原则: 违背开闭原则,  一旦父类增加一个抽象方法， 所有子类都需要对应增加</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、什么是模板方法设计模式&quot;&gt;&lt;a href=&quot;#一、什么是模板方法设计模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是模板方法设计模式&quot;&gt;&lt;/a&gt;一、什么是模板方法设计模式&lt;/h1&gt;&lt;p&gt;从字面意义上理解, 模板方法就是定义出来一套方法, </summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>14-代理模式</title>
    <link href="https://georgechan95.github.io/blog/e4235185.html"/>
    <id>https://georgechan95.github.io/blog/e4235185.html</id>
    <published>2024-11-21T15:16:00.000Z</published>
    <updated>2024-11-23T01:52:19.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、代理模式的基本介绍"><a href="#一、代理模式的基本介绍" class="headerlink" title="一、代理模式的基本介绍"></a>一、代理模式的基本介绍</h1><ul><li><p>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处 是:可以在目标对象实现的基础上,增强额外的功能操作, 即扩展目标对象的功能。</p></li><li><p>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象.</p></li><li><p>代理模式有不同的形式,  主要有三种 <strong>静态代理</strong>、<strong>动态代理</strong> (JDK 代理、接口代理)和 <strong>Cglib 代理</strong> (可以在内存 动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴)  。</p></li></ul><p>代理模式示意图</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/21/20241121-231932.png" alt="代理模式"></p><h1 id="二静态代理"><a href="#二静态代理" class="headerlink" title="二静态代理"></a>二静态代理</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类</p><h2 id="2-应用实例"><a href="#2-应用实例" class="headerlink" title="2. 应用实例"></a>2. 应用实例</h2><p><strong>具体要求</strong></p><ul><li>定义一个接口: <code>ITeacherDao</code></li><li>目标对象 <code>TeacherDAO</code> 实现接口 <code>ITeacherDAO</code></li></ul><ol start="3"><li>使用静态代理方式,就需要在代理对象 <code>TeacherDAOProxy</code> 中也实现 <code>ITeacherDAO</code></li><li>调用的时候通过调用代理对象的方法来调用目标对象.</li><li>特别提醒：代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</li></ol><p><strong>思路分析图解(类图)</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/21/20241121-234014.png" alt="静态代理UML图"></p><p><strong>代码实现</strong></p><pre><code class="highlight java"><span class="comment">// 接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>; <span class="comment">// 授课的方法</span>&#125;<span class="comment">// 被代理的类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 老师授课中  。。。。。&quot;</span>);    &#125;&#125;<span class="comment">//代理对象,静态代理</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="keyword">private</span> ITeacherDao target; <span class="comment">// 目标对象，通过接口来聚合</span>    <span class="keyword">public</span> <span class="title function_">TeacherDaoProxy</span><span class="params">(ITeacherDao target)</span> &#123;        <span class="built_in">this</span>.target = target;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.before();        target.teach();        <span class="built_in">this</span>.after();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;准备课程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;结束课程&quot;</span>);    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建目标对象(被代理对象)</span>        <span class="type">TeacherDao</span> <span class="variable">teacherDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();        <span class="comment">//创建代理对象, 同时将被代理对象传递给代理对象</span>        <span class="type">TeacherDaoProxy</span> <span class="variable">teacherDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDaoProxy</span>(teacherDao);        <span class="comment">//通过代理对象，调用到被代理对象的方法</span>        <span class="comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法</span>        teacherDaoProxy.teach();    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">准备课程 老师授课中  。。。。。结束课程</code></pre></blockquote><h2 id="3-静态代理优缺点"><a href="#3-静态代理优缺点" class="headerlink" title="3. 静态代理优缺点"></a>3. 静态代理优缺点</h2><ul><li>优点：在不修改目标对象的功能前提下,  能通过代理对象对目标功能扩展</li><li>缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类</li><li>一旦接口增加方法, 目标对象与代理对象都要维护</li></ul><h1 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a>三、动态代理</h1><h2 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li><li>代理对象的生成，是利用 JDK 的 API ，动态的在内存中构建代理对象</li><li>动态代理也叫做：JDK 代理、接口代理</li></ul><h2 id="2-JDK-中生成代理对象的-API"><a href="#2-JDK-中生成代理对象的-API" class="headerlink" title="2. JDK 中生成代理对象的 API"></a>2. JDK 中生成代理对象的 API</h2><ul><li>代理类所在包: <code>java.lang.reflect.Proxy</code></li><li>JDK 实现代理只需要使用 <code>newProxyInstance</code> 方法,但是该方法需要接收三个参数,完整的写法是: <code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</code></li></ul><h2 id="3-应用实例"><a href="#3-应用实例" class="headerlink" title="3. 应用实例"></a>3. 应用实例</h2><p><strong>应用实例要求</strong></p><p>将前面的静态代理改进成动态代理模式(即：JDK 代理模式)</p><p><strong>思路图解(类图)</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/21/20241121-235947.png" alt="动态代理UML图"></p><p><strong>代码实现</strong></p><pre><code class="highlight java"><span class="comment">// 接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>; <span class="comment">// 授课的方法</span>    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;&#125;<span class="comment">// 被代理的类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 老师授课中  。。。。。&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;        System.out.println(<span class="string">&quot;hello &quot;</span> + name);    &#125;&#125;<span class="comment">// JDK动态代理类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;    <span class="keyword">private</span> ITeacherDao target;    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(ITeacherDao target)</span> &#123;        <span class="built_in">this</span>.target = target;    &#125;    <span class="comment">//说明</span>    <span class="comment">/*</span><span class="comment">     *  public static Object newProxyInstance(ClassLoader loader,</span><span class="comment">                                      Class&lt;?&gt;[] interfaces,</span><span class="comment">                                      InvocationHandler h)</span><span class="comment"></span><span class="comment">        //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span><span class="comment">        //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span><span class="comment">        //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;                System.out.println(<span class="string">&quot;JDK代理开始~&quot;</span>);                <span class="type">Object</span> <span class="variable">resultVal</span> <span class="operator">=</span> method.invoke(target, args);                System.out.println(<span class="string">&quot;JDK代理提交~&quot;</span>);                <span class="keyword">return</span> resultVal;            &#125;        &#125;);    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建目标对象</span>        <span class="type">ITeacherDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();        <span class="comment">// 给目标对象，创建代理对象, 可以转成 ITeacherDao</span>        <span class="type">ITeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (ITeacherDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();        <span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span>        System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());        <span class="comment">//通过代理对象，调用目标对象的方法</span>        proxyInstance.teach();        proxyInstance.sayHello(<span class="string">&quot;George&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">proxyInstance=class com.sun.proxy.$Proxy0JDK代理开始~ 老师授课中  。。。。。JDK代理提交~JDK代理开始~hello GeorgeJDK代理提交~</code></pre></blockquote><h1 id="四、Cglib-代理"><a href="#四、Cglib-代理" class="headerlink" title="四、Cglib 代理"></a>四、Cglib 代理</h1><h2 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li>静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实 现任何的接口,这个时候可使用目标对象子类来实现代理-这就是 <strong>Cglib 代理</strong></li><li>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展,  有些书也将Cglib代 理归属到动态代理。</li><li>Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展java 类与实现java 接口.它广泛的被许多 AOP 的 框架使用,例如 Spring AOP ，实现方法拦截</li><li>在 AOP 编程中如何选择代理模式：<ul><li>目标对象需要实现接口，用 JDK 代理</li><li>目标对象不需要实现接口，用 Cglib 代理</li></ul></li><li>Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类</li></ul><h2 id="2-Cglib-代理模式实现步骤"><a href="#2-Cglib-代理模式实现步骤" class="headerlink" title="2. Cglib 代理模式实现步骤"></a>2. Cglib 代理模式实现步骤</h2><ul><li>需要引入 cglib 的jar 文件<ul><li>asm.jar</li><li>asm-commons.jar</li><li>asm-tree.jar</li><li>cglib-2.2.jar</li></ul></li><li>在内存中动态构建子类，注意<strong>代理的类不能为final</strong> ，否则报错 : java.lang.IllegalArgumentException:</li><li>目标对象的方法<strong>如果为 final&#x2F;static,那么就不会被拦截</strong>, 即不会执行目标对象额外的业务方法.</li></ul><h2 id="3-Cglib-代理模式应用实例"><a href="#3-Cglib-代理模式应用实例" class="headerlink" title="3. Cglib 代理模式应用实例"></a>3. Cglib 代理模式应用实例</h2><p><strong>应用实例要求</strong></p><p>将前面的案例用 Cglib 代理模式实现</p><p><strong>思路图解(类图)</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/22/20241122-002025.png" alt="Cglib 代理UML图"></p><p><strong>代码实现</strong></p><pre><code class="highlight java"><span class="comment">// 目标代理的对象</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> &#123;    <span class="keyword">public</span> String <span class="title function_">teach</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;</span>);        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;    &#125;&#125;<span class="comment">// Cglib代理类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;    <span class="keyword">private</span> TeacherDao target;    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(TeacherDao target)</span> &#123;        <span class="built_in">this</span>.target = target;    &#125;    <span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span>    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;        <span class="comment">// 创建一个工具类</span>        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();        <span class="comment">// 设置父类</span>        enhancer.setSuperclass(target.getClass());        <span class="comment">// 设置回调函数</span>        enhancer.setCallback(<span class="built_in">this</span>);        <span class="comment">//4. 创建子类对象，即代理对象</span>        <span class="keyword">return</span> enhancer.create();    &#125;    <span class="comment">//重写  intercept 方法，会调用目标对象的方法</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);        <span class="type">Object</span> <span class="variable">resultVal</span> <span class="operator">=</span> method.invoke(target, args);        System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);        <span class="keyword">return</span> resultVal;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">TeacherDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();        <span class="type">TeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (TeacherDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();        proxyInstance.teach();    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">Cglib代理模式 ~~ 开始 老师授课中  ， 我是cglib代理，不需要实现接口 Cglib代理模式 ~~ 提交</code></pre></blockquote><h1 id="五、几种常见的代理模式介绍—-几种变体"><a href="#五、几种常见的代理模式介绍—-几种变体" class="headerlink" title="五、几种常见的代理模式介绍— 几种变体"></a>五、几种常见的代理模式介绍— 几种变体</h1><ul><li><p>防火墙代理</p><p>内网通过代理穿透防火墙，实现对公网的访问。</p></li><li><p>缓存代理</p><p>比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据 库取，然后缓存.</p></li><li><p>远程代理</p><p>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</p></li><li><p>同步代理</p><p>主要使用在多线程编程中，完成多线程间同步工作.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、代理模式的基本介绍&quot;&gt;&lt;a href=&quot;#一、代理模式的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;一、代理模式的基本介绍&quot;&gt;&lt;/a&gt;一、代理模式的基本介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代理模式：为一个对象提供一个替身，以控制对这个对象</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>13-享元模式</title>
    <link href="https://georgechan95.github.io/blog/1b225c1f.html"/>
    <id>https://georgechan95.github.io/blog/1b225c1f.html</id>
    <published>2024-11-20T15:10:00.000Z</published>
    <updated>2024-11-20T13:28:40.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、展示网站项目需求"><a href="#一、展示网站项目需求" class="headerlink" title="一、展示网站项目需求"></a>一、展示网站项目需求</h1><p>当前假设有一个项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：</p><ul><li>有客户要求以新闻的形式发布</li><li>有客户人要求以博客的形式发布</li><li>有客户希望以微信公众号的形式发布</li></ul><p><strong>传统方案解决网站展现项目</strong></p><ul><li>直接复制粘贴一份，然后根据客户不同要求，进行定制修改</li><li>给每个网站租用一个空间</li><li>方案设计示意图</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-205250.png" alt="传统方式"></p><p>传统方案解决网站展现项目存在以下问题：</p><ul><li>需要的网站结构相似度很高，而且都不是高问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费。</li><li>解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源。</li><li>对于代码来说，由于是一份实例，维护和扩展都更加容易。</li><li>上面的解决思路就可以使用 <strong>享元模式</strong> 来解决。</li></ul><h1 id="二、享元模式基本介绍"><a href="#二、享元模式基本介绍" class="headerlink" title="二、享元模式基本介绍"></a>二、享元模式基本介绍</h1><ul><li>享元模式（Flyweight Pattern）也叫蝇量模式：运用共享技术有效地支持大量细粒度的对象。</li><li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象 中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。</li><li>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对 象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。</li><li>享元模式经典的应用场景就是池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。</li></ul><h1 id="三、享元模式的原理类图"><a href="#三、享元模式的原理类图" class="headerlink" title="三、享元模式的原理类图"></a>三、享元模式的原理类图</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-205914.png" alt="享元模式原理图"></p><p><strong>对类图的说明</strong></p><p>对原理图的说明-即(模式的角色及职责)</p><ul><li>FlyWeight：是抽象的享元角色,  他是产品的抽象类,   同时定义出对象的<strong>外部状态</strong>和<strong>内部状态</strong>(后面介绍)   的接口或实现</li><li>ConcreteFlyweight：具体的享元角色，是具体的产品类，实现抽象角色定义的相关业务.</li><li>UnsharedConcreteFlyweight：不可共享的角色，一般不会出现在享元工厂中.</li><li>FlyweightFactory：享元工厂类，用于构建一个池容器（集合），同时提供从池中获取对象的方法</li></ul><h1 id="四、内部状态和外部状态"><a href="#四、内部状态和外部状态" class="headerlink" title="四、内部状态和外部状态"></a>四、内部状态和外部状态</h1><p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点。所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同。当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态</p><ul><li>享元模式提出了两个要求：<strong>细粒度</strong> 和 <strong>共享对象</strong>。即将对象的信息分为两个部分：<strong>内部状态</strong> 和 <strong>外部状态</strong></li><li><strong>内部状态</strong>：指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变。</li><li><strong>外部状态</strong>：指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</li></ul><p>举个例子：围模理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生。因为内存空间有限，一台服务器很难支持更多的玩家玩围模游戏。如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题</p><h1 id="五、享元模式解决网站展现项目"><a href="#五、享元模式解决网站展现项目" class="headerlink" title="五、享元模式解决网站展现项目"></a>五、享元模式解决网站展现项目</h1><p><strong>原理类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-210641.png" alt="享元模式"></p><p><strong>UML 类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-210648.png" alt="img"></p><p><strong>代码如下：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    <span class="keyword">private</span> String name;    <span class="comment">// 省略 get/set 构造方法</span>&#125;<span class="comment">// 抽象的享元对象</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span>;&#125;<span class="comment">// 具体的享元角色</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title class_">WebSite</span> &#123;    <span class="comment">// 网站类型，享元模式中的内部状态</span>    <span class="keyword">private</span> String type;    <span class="keyword">public</span> <span class="title function_">ConcreteWebSite</span><span class="params">(String type)</span> &#123;        <span class="built_in">this</span>.type = type;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span> &#123;        System.out.println(<span class="string">&quot;网站的发布形式为:&quot;</span> + type + <span class="string">&quot; 在使用中 .. 使用者是&quot;</span> + user.getName());    &#125;&#125;<span class="comment">// 享元工厂</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSiteFactory</span> &#123;    <span class="comment">// 共享数据池</span>    <span class="keyword">private</span> Map&lt;String, WebSite&gt; pool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">// 根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回</span>    <span class="keyword">public</span> WebSite <span class="title function_">getWebSiteCategory</span><span class="params">(String type)</span> &#123;        <span class="keyword">if</span> (!pool.containsKey(type)) &#123;            <span class="comment">// 创建一个网站，并放入到池中</span>            pool.put(type, <span class="keyword">new</span> <span class="title class_">ConcreteWebSite</span>(type));        &#125;        <span class="keyword">return</span> pool.get(type);    &#125;    <span class="comment">// 获取网站分类的总数 (池中有多少个网站类型)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWebSiteCount</span><span class="params">()</span> &#123;        <span class="keyword">return</span> pool.size();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">WebSiteFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSiteFactory</span>();        <span class="comment">// 新闻形式的网站</span>        <span class="type">WebSite</span> <span class="variable">webSite1</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;新闻&quot;</span>);        webSite1.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));        <span class="comment">// 博客形式的网站</span>        <span class="type">WebSite</span> <span class="variable">webSite2</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);        webSite2.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>));        <span class="type">int</span> <span class="variable">webSiteCount</span> <span class="operator">=</span> factory.getWebSiteCount();        System.out.println(<span class="string">&quot;网站分类数：&quot;</span> + webSiteCount);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">网站的发布形式为:新闻 在使用中 .. 使用者是Tom网站的发布形式为:博客 在使用中 .. 使用者是Jack网站分类数：2</code></pre></blockquote><h1 id="六、享元模式在JDK源码中的应用-Integer类"><a href="#六、享元模式在JDK源码中的应用-Integer类" class="headerlink" title="六、享元模式在JDK源码中的应用-Integer类"></a>六、享元模式在JDK源码中的应用-Integer类</h1><p>首先先看一段代码测试</p><pre><code class="highlight java"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">127</span>);<span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);<span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">127</span>);<span class="type">Integer</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);System.out.println(x.equals(y)); <span class="comment">// true</span>System.out.println(x == y);      <span class="comment">// false</span>System.out.println(x == z);      <span class="comment">// true</span>System.out.println(w == x);      <span class="comment">// false</span>System.out.println(w == y);      <span class="comment">// false</span></code></pre><p>我们知道：<code>equals</code>比较的是对象的内容，<code>==</code>比较的是对象的实例</p><ul><li><p><code>x.equals(y)</code>结果为<code>true</code>：比较的是大小，所以结果为<code>true</code></p></li><li><p><code>x == y</code>、<code>w == x</code>、<code>w == y</code>结果为<code>false</code>：由于 y 是 new 出来的，所以结果为<code>false</code></p></li><li><p><code>x == z</code>结果为<code>true</code>：<strong>这是为什么呢？？？</strong></p></li></ul><p>我们追踪一下<code>Integer</code>对象的<code>valueOf</code>方法，看一下源码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);&#125;</code></pre><p>这里的<code>low</code>和<code>high</code>是多少呢？</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];    <span class="keyword">static</span> &#123;        <span class="comment">// high value may be configured by property</span>        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span>            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;            <span class="keyword">try</span> &#123;                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);                i = Math.max(i, <span class="number">127</span>);                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span>                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span>            &#125;        &#125;        high = h;        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span>        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;    &#125;    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;&#125;</code></pre><p>我们通过<code>IntegerCache</code>中源码大概基本分析出</p><ul><li><p><code>low</code>为<code>-128</code></p></li><li><p><code>high</code>为<code>127</code></p></li></ul><p>所以当<code>Integer</code>在<code>[-128, 127]</code>时，会返回<code>IntegerCache</code>的<code>cache[]</code>数组内容；否则，<code>valueOf</code>方法相当于<code>new Integer</code>了。也就是说，<code>Integer.valueOf(x)</code>方法使用的就是<strong>享元模式</strong>。</p><p>另外，我们也可以分析出：</p><ul><li>当数值范围在<code>[-128, 127]</code>时，使用<code>valueOf</code>方法执行速度比<code>new</code>更快</li></ul><h1 id="七、享元模式的注意事项和细节"><a href="#七、享元模式的注意事项和细节" class="headerlink" title="七、享元模式的注意事项和细节"></a>七、享元模式的注意事项和细节</h1><ul><li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li><li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</li><li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap&#x2F;HashTable 存储</li><li>享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</li><li>享元模式提高了系统的复杂度，需要分离出内部状态和外部状态。而内部状态具有固化特性，不应该随着外部状态的改变而改变，这是我们使用享元模式需要注意的地方</li><li>使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制</li><li>享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、展示网站项目需求&quot;&gt;&lt;a href=&quot;#一、展示网站项目需求&quot; class=&quot;headerlink&quot; title=&quot;一、展示网站项目需求&quot;&gt;&lt;/a&gt;一、展示网站项目需求&lt;/h1&gt;&lt;p&gt;当前假设有一个项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
