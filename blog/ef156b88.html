<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>007-Kubernetes 存储 | George&#39;s Blog</title>
  <meta name="google-site-verification" content="RobLWkyyFziZxPJ4I887QROdX8XrYthcJwWTcuH0wwQ" />
  <meta name="msvalidate.01" content="626D541C48E5D151F52CECC2C6714BD4" />
  <meta name="360-site-verification" content="c838adf8357ca2f614d08ad5235a1717" />
  <meta name="keywords" content=" linux , Docker , Rocky ">
  <meta name="description" content="007-Kubernetes 存储 | George&#39;s Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="一、概述在 Kubernetes 集群中，所有资源都运行在私有网络空间（通常使用 CNI 插件构建 overlay 网络），这带来了以下调试难题：  Pod 使用动态 IP 地址（生命周期短暂） Service 的 ClusterIP 仅在集群内部可达 生产环境通常禁用 NodePort 等暴露方式  针对上述的几种情况，我们就可以使用 kubectl port-forward来满足需求。 1.">
<meta property="og:type" content="article">
<meta property="og:title" content="019-K8S-kubectl端口转发">
<meta property="og:url" content="https://georgechan95.github.io/blog/9bea6e2e.html">
<meta property="og:site_name" content="George&#39;s Blog">
<meta property="og:description" content="一、概述在 Kubernetes 集群中，所有资源都运行在私有网络空间（通常使用 CNI 插件构建 overlay 网络），这带来了以下调试难题：  Pod 使用动态 IP 地址（生命周期短暂） Service 的 ClusterIP 仅在集群内部可达 生产环境通常禁用 NodePort 等暴露方式  针对上述的几种情况，我们就可以使用 kubectl port-forward来满足需求。 1.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/08/10/20250810-120031.png">
<meta property="article:published_time" content="2025-08-04T15:02:00.000Z">
<meta property="article:modified_time" content="2025-08-10T04:05:16.107Z">
<meta property="article:author" content="George">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="Rocky">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/08/10/20250810-120031.png">


<link rel="icon" href="/img/favicon.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="George's Blog" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<script src="/js/image-loader.js"></script>
<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>George</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/GeorgeChan95"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:george_95@126.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(113)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="设计模式">
            
            设计模式
            <small>(24)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Docker">
            
            Docker
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Hexo">
            <i class="fold iconfont icon-right"></i>
            Hexo
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Hexo&lt;---&gt;Typora">
            
            Typora
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JUC">
            
            JUC
            <small>(24)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JVM">
            
            JVM
            <small>(27)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="k8s">
            
            k8s
            <small>(19)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="linux">
            
            linux
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="neo4j">
            
            neo4j
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="UML">
            
            UML
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">关于</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="113">
<input type="hidden" id="yelog_site_word_count" value="562.9k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>插入排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二分法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二进制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>合并有序链表</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>科学上网</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>链表</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>冒泡排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>双亲委派机制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>位运算</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>选择排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github pages</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Harbor</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jenkins</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>juc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jvm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Loki</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>neo4j</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Pod</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Prometheus</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Rocky</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>sitemap</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SpringBoot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>typora</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ubuntu18</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>UML</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 k8s "
           href="/blog/9bea6e2e.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="019-K8S-kubectl端口转发">019-K8S-kubectl端口转发</span>
            <span class="post-date" title="2025-08-04 23:02:00">2025/08/04</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/af9812e0.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="018-K8S-临时容器">018-K8S-临时容器</span>
            <span class="post-date" title="2025-08-03 22:01:00">2025/08/03</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/99657768.html"
           data-tag="linux,Docker,Rocky,Pod"
           data-author="" >
            <span class="post-title" title="017-K8S-网络策略NetworkPolicy">017-K8S-网络策略NetworkPolicy</span>
            <span class="post-date" title="2025-07-28 21:33:00">2025/07/28</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/c9536d9e.html"
           data-tag="linux,Docker,Rocky,Pod"
           data-author="" >
            <span class="post-title" title="016-K8S-固定Pod IP地址，基于Calico插件">016-K8S-固定Pod IP地址，基于Calico插件</span>
            <span class="post-date" title="2025-07-26 13:35:00">2025/07/26</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/e62b8338.html"
           data-tag="linux,Docker,Rocky,Prometheus"
           data-author="" >
            <span class="post-title" title="015-K8S-Prometheus部署及监控告警">015-K8S-Prometheus部署及监控告警</span>
            <span class="post-date" title="2025-07-19 16:39:00">2025/07/19</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/f8cf646f.html"
           data-tag="linux,Docker,Rocky,Loki"
           data-author="" >
            <span class="post-title" title="014-K8S-部署Loki+Promtail+Grafana实现日志监控">014-K8S-部署Loki+Promtail+Grafana实现日志监控</span>
            <span class="post-date" title="2025-07-10 21:00:00">2025/07/10</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/3fee6d19.html"
           data-tag="linux,Docker,Rocky,Harbor"
           data-author="" >
            <span class="post-title" title="013-K8S-使用Helm安装Harbor">013-K8S-使用Helm安装Harbor</span>
            <span class="post-date" title="2025-07-07 22:37:00">2025/07/07</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/b42f2c7b.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="012-新建Node节点添加到K8S集群中">012-新建Node节点添加到K8S集群中</span>
            <span class="post-date" title="2025-07-07 20:32:00">2025/07/07</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/6436eaf1.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="011-Kubernetes Ingress-Nginx">011-Kubernetes Ingress-Nginx</span>
            <span class="post-date" title="2025-06-25 19:42:00">2025/06/25</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/d8e3c7b3.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="010-Kubernetes Helm">010-Kubernetes Helm</span>
            <span class="post-date" title="2025-06-21 14:12:00">2025/06/21</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/424f1119.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="009-Kubernetes 集群安全机制">009-Kubernetes 集群安全机制</span>
            <span class="post-date" title="2025-06-14 09:18:00">2025/06/14</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/f2285a2d.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="008-Kubernetes 调度器">008-Kubernetes 调度器</span>
            <span class="post-date" title="2025-06-02 14:40:00">2025/06/02</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/ef156b88.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="007-Kubernetes 存储">007-Kubernetes 存储</span>
            <span class="post-date" title="2025-05-02 10:26:00">2025/05/02</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/970719d6.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="006-Kubernetes Service">006-Kubernetes Service</span>
            <span class="post-date" title="2025-04-28 22:10:00">2025/04/28</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/c790096a.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="005-Kubernetes控制器">005-Kubernetes控制器</span>
            <span class="post-date" title="2025-04-02 20:12:00">2025/04/02</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/79e06aab.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="004-Pod的生命周期">004-Pod的生命周期</span>
            <span class="post-date" title="2025-03-22 09:05:00">2025/03/22</span>
        </a>
        
        
        <a  class="全部文章 Docker "
           href="/blog/b01d5c62.html"
           data-tag="linux,Docker,科学上网"
           data-author="" >
            <span class="post-title" title="Docker配置网络代理实现外网镜像下载">Docker配置网络代理实现外网镜像下载</span>
            <span class="post-date" title="2025-01-08 23:00:00">2025/01/08</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/7f174b3e.html"
           data-tag="linux,科学上网,Rocky"
           data-author="" >
            <span class="post-title" title="Rocky9安装Shadowsocks实现科学上网">Rocky9安装Shadowsocks实现科学上网</span>
            <span class="post-date" title="2025-01-08 21:09:00">2025/01/08</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/b00f53e9.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="003-基于Rocky9.3系统使用kubeadm安装k8s1.29集群">003-基于Rocky9.3系统使用kubeadm安装k8s1.29集群</span>
            <span class="post-date" title="2025-01-03 22:05:00">2025/01/03</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/3c79d8d9.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="002-Rocky9.3系统初始化设置和Docker安装">002-Rocky9.3系统初始化设置和Docker安装</span>
            <span class="post-date" title="2025-01-02 13:25:00">2025/01/02</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/7e3a5200.html"
           data-tag="linux,Rocky"
           data-author="" >
            <span class="post-title" title="001-ESXi8安装Rocky9.3虚拟机">001-ESXi8安装Rocky9.3虚拟机</span>
            <span class="post-date" title="2025-01-02 09:34:00">2025/01/02</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/77d85f50.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="25-责任链模式">25-责任链模式</span>
            <span class="post-date" title="2024-12-03 21:08:00">2024/12/03</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/fcec839d.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="24-策略模式">24-策略模式</span>
            <span class="post-date" title="2024-12-02 18:16:00">2024/12/02</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/6109865a.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="23-状态模式">23-状态模式</span>
            <span class="post-date" title="2024-11-29 19:30:00">2024/11/29</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/58d4db7.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="22-解释器模式">22-解释器模式</span>
            <span class="post-date" title="2024-11-28 22:00:00">2024/11/28</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/a5cf7eb4.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="21-备忘录模式">21-备忘录模式</span>
            <span class="post-date" title="2024-11-27 21:40:00">2024/11/27</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/3148d6be.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="20-中介者模式">20-中介者模式</span>
            <span class="post-date" title="2024-11-26 20:35:00">2024/11/26</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/f06aea0b.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="19-观察者模式">19-观察者模式</span>
            <span class="post-date" title="2024-11-25 21:07:00">2024/11/25</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/7dbd9149.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="18-迭代器模式">18-迭代器模式</span>
            <span class="post-date" title="2024-11-24 00:02:00">2024/11/24</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/4fdf6e52.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="17-访问者模式">17-访问者模式</span>
            <span class="post-date" title="2024-11-23 21:55:00">2024/11/23</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/60fd53f.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="16-命令模式">16-命令模式</span>
            <span class="post-date" title="2024-11-23 20:30:00">2024/11/23</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/4930323d.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="15-模板方法模式">15-模板方法模式</span>
            <span class="post-date" title="2024-11-23 19:40:00">2024/11/23</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/e4235185.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="14-代理模式">14-代理模式</span>
            <span class="post-date" title="2024-11-21 23:16:00">2024/11/21</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/1b225c1f.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="13-享元模式">13-享元模式</span>
            <span class="post-date" title="2024-11-20 23:10:00">2024/11/20</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/906e9e8b.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="12-外观模式">12-外观模式</span>
            <span class="post-date" title="2024-11-20 22:09:00">2024/11/20</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/c456a66a.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="11-组合模式">11-组合模式</span>
            <span class="post-date" title="2024-11-16 17:00:00">2024/11/16</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/90213fc6.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="10-装饰器模式">10-装饰器模式</span>
            <span class="post-date" title="2024-11-16 14:06:00">2024/11/16</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/c7419cfa.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="09-桥接模式">09-桥接模式</span>
            <span class="post-date" title="2024-11-14 20:51:00">2024/11/14</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/f77fc055.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="08-适配器模式">08-适配器模式</span>
            <span class="post-date" title="2024-11-12 22:55:00">2024/11/12</span>
        </a>
        
        
        <a  class="全部文章 neo4j "
           href="/blog/a3b0b090.html"
           data-tag="SpringBoot,neo4j"
           data-author="" >
            <span class="post-title" title="Spring Boot对Neo4j节点关系的增删改查">Spring Boot对Neo4j节点关系的增删改查</span>
            <span class="post-date" title="2024-11-12 21:00:30">2024/11/12</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/3ab9aa56.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="07-建造者模式">07-建造者模式</span>
            <span class="post-date" title="2024-11-11 21:55:00">2024/11/11</span>
        </a>
        
        
        <a  class="全部文章 neo4j "
           href="/blog/7dc0fcde.html"
           data-tag="SpringBoot,neo4j"
           data-author="" >
            <span class="post-title" title="Spring Boot整合Neo4j实现增删改查">Spring Boot整合Neo4j实现增删改查</span>
            <span class="post-date" title="2024-11-07 19:04:30">2024/11/07</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/564adc33.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="06-原型模式">06-原型模式</span>
            <span class="post-date" title="2024-11-06 19:00:00">2024/11/06</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/effeea78.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="05-工厂模式">05-工厂模式</span>
            <span class="post-date" title="2024-11-04 21:00:00">2024/11/04</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/d7e99843.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="04-单例模式">04-单例模式</span>
            <span class="post-date" title="2024-11-04 19:00:00">2024/11/04</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/90f1850a.html"
           data-tag="设计模式,UML"
           data-author="" >
            <span class="post-title" title="03-UML类图">03-UML类图</span>
            <span class="post-date" title="2024-11-02 14:57:00">2024/11/02</span>
        </a>
        
        
        <a  class="全部文章 UML "
           href="/blog/c13304c1.html"
           data-tag="设计模式,UML"
           data-author="" >
            <span class="post-title" title="02-UML图绘制工具">02-UML图绘制工具</span>
            <span class="post-date" title="2024-11-02 09:57:00">2024/11/02</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/2e826df1.html"
           data-tag="linux,ubuntu18"
           data-author="" >
            <span class="post-title" title="Docker环境下RTSP流转RTMP和HLS">Docker环境下RTSP流转RTMP和HLS</span>
            <span class="post-date" title="2024-11-01 15:17:33">2024/11/01</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/cd625bba.html"
           data-tag="设计模式,java"
           data-author="" >
            <span class="post-title" title="01-设计模式六大原则">01-设计模式六大原则</span>
            <span class="post-date" title="2024-10-31 17:00:00">2024/10/31</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/1a649f4c.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="13-JUC进阶-ReentrantReadWriteLock与StampedLock">13-JUC进阶-ReentrantReadWriteLock与StampedLock</span>
            <span class="post-date" title="2024-10-19 09:26:00">2024/10/19</span>
        </a>
        
        
        <a  class="全部文章 neo4j "
           href="/blog/5c93903a.html"
           data-tag="linux,neo4j"
           data-author="" >
            <span class="post-title" title="Docker部署Neo4j并导入CSV数据">Docker部署Neo4j并导入CSV数据</span>
            <span class="post-date" title="2024-10-17 15:00:30">2024/10/17</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/ad38e6b1.html"
           data-tag="linux,ubuntu18"
           data-author="" >
            <span class="post-title" title="Ubuntu18.04离线源环境搭建">Ubuntu18.04离线源环境搭建</span>
            <span class="post-date" title="2024-10-17 09:47:33">2024/10/17</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3fdbf0f6.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="12-JUC进阶-从ReentrantLock到AQS源码详解">12-JUC进阶-从ReentrantLock到AQS源码详解</span>
            <span class="post-date" title="2024-10-15 19:42:07">2024/10/15</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3e0d7592.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="11-JUC进阶-Synchronized与锁升级">11-JUC进阶-Synchronized与锁升级</span>
            <span class="post-date" title="2024-10-06 09:28:00">2024/10/06</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4502cffa.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="10-JUC进阶-Java对象内存布局和对象头">10-JUC进阶-Java对象内存布局和对象头</span>
            <span class="post-date" title="2024-10-04 09:54:40">2024/10/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4de6a39b.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="09-JUC进阶-ThreadLocal">09-JUC进阶-ThreadLocal</span>
            <span class="post-date" title="2024-10-01 20:39:10">2024/10/01</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/72329cf5.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="08-JUC进阶-常用的原子操作类(18个)">08-JUC进阶-常用的原子操作类(18个)</span>
            <span class="post-date" title="2024-09-28 13:37:09">2024/09/28</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/5e3757c1.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="07-JUC进阶-CAS">07-JUC进阶-CAS</span>
            <span class="post-date" title="2024-09-26 19:37:00">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/546d628d.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="06-JUC进阶-Volatile与Java内存模型">06-JUC进阶-Volatile与Java内存模型</span>
            <span class="post-date" title="2024-09-25 19:01:01">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/1f2e0014.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="05-JUC进阶-Java内存模型-JMM">05-JUC进阶-Java内存模型-JMM</span>
            <span class="post-date" title="2024-09-23 23:01:07">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/19653fb9.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="04-JUC进阶-LockSupport与线程中断">04-JUC进阶-LockSupport与线程中断</span>
            <span class="post-date" title="2024-09-23 20:51:50">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/219e52ea.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="03-JUC进阶-Java中的锁的解析">03-JUC进阶-Java中的锁的解析</span>
            <span class="post-date" title="2024-09-21 14:15:20">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/7e2d78eb.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="02-JUC进阶-CompletableFuture">02-JUC进阶-CompletableFuture</span>
            <span class="post-date" title="2024-09-18 22:50:00">2024/09/18</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3d102971.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="01-JUC进阶-线程基础">01-JUC进阶-线程基础</span>
            <span class="post-date" title="2024-09-18 22:32:00">2024/09/18</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/37d56d14.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="11-CompletableFuture">11-CompletableFuture</span>
            <span class="post-date" title="2024-09-16 16:12:00">2024/09/16</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/31919959.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="10-Fork/Join">10-Fork/Join</span>
            <span class="post-date" title="2024-09-16 13:10:00">2024/09/16</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/a0197c15.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="09-ThreadPool-线程池">09-ThreadPool-线程池</span>
            <span class="post-date" title="2024-09-13 20:10:08">2024/09/13</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/a6760d1f.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="08-阻塞队列BlockingQueue">08-阻塞队列BlockingQueue</span>
            <span class="post-date" title="2024-09-07 17:30:00">2024/09/07</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/838e7581.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore">07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore</span>
            <span class="post-date" title="2024-09-07 13:00:00">2024/09/07</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/f60e37c5.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="06-Callable &amp; Future 接口">06-Callable &amp; Future 接口</span>
            <span class="post-date" title="2024-09-06 22:10:00">2024/09/06</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/f184587f.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="05-公平锁和非公平锁，死锁，可重入锁">05-公平锁和非公平锁，死锁，可重入锁</span>
            <span class="post-date" title="2024-09-05 20:12:00">2024/09/05</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/9a09d992.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="04-集合的线程安全">04-集合的线程安全</span>
            <span class="post-date" title="2024-09-04 21:09:05">2024/09/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/bd2134da.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="03-线程间通信">03-线程间通信</span>
            <span class="post-date" title="2024-09-04 20:06:00">2024/09/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/850dac3c.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="02-Lock接口">02-Lock接口</span>
            <span class="post-date" title="2024-08-30 19:27:00">2024/08/30</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4e6bd685.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="01-多线程的基本概念">01-多线程的基本概念</span>
            <span class="post-date" title="2024-08-30 19:03:01">2024/08/30</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1b0522f4.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十五章-分析GC日志">第二十五章-分析GC日志</span>
            <span class="post-date" title="2024-08-28 21:36:08">2024/08/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/944806143.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十四章-JVM运行时参数">第二十四章-JVM运行时参数</span>
            <span class="post-date" title="2024-08-27 18:30:10">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/490498600.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-使用OQL语言查询对象信息">第二十三章-使用OQL语言查询对象信息</span>
            <span class="post-date" title="2024-08-24 15:02:10">2024/08/24</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1471620196.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-浅堆-深堆-内存泄漏">第二十三章-浅堆-深堆-内存泄漏</span>
            <span class="post-date" title="2024-08-24 13:04:37">2024/08/24</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/971417975.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-JVM监控及诊断工具-GUI篇">第二十三章-JVM监控及诊断工具-GUI篇</span>
            <span class="post-date" title="2024-08-16 21:00:00">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2165702380.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十二章-JVM监控及诊断工具-命令行篇">第二十二章-JVM监控及诊断工具-命令行篇</span>
            <span class="post-date" title="2024-08-12 19:36:32">2024/08/12</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2681163762.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十一章-性能监控与调优概述">第二十一章-性能监控与调优概述</span>
            <span class="post-date" title="2024-08-12 19:13:06">2024/08/12</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3537043756.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十章-再谈类的加载器">第二十章-再谈类的加载器</span>
            <span class="post-date" title="2024-08-10 13:43:10">2024/08/10</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3387211378.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十九章-类的加载过程详解">第十九章-类的加载过程详解</span>
            <span class="post-date" title="2024-08-02 19:33:27">2024/08/02</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1107503247.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十八章-字节码指令集与解析指令">第十八章-字节码指令集与解析指令</span>
            <span class="post-date" title="2024-08-01 01:40:02">2024/08/01</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2772873157.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十七章-使用javap指令解析class文件">第十七章-使用javap指令解析class文件</span>
            <span class="post-date" title="2024-07-22 23:54:00">2024/07/22</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/143162370.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十六章-Class文件结构">第十六章-Class文件结构</span>
            <span class="post-date" title="2024-07-15 19:54:50">2024/07/15</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/309245330.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十五章-GC日志分析">第十五章-GC日志分析</span>
            <span class="post-date" title="2024-07-13 08:34:00">2024/07/13</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1750792302.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十四章-垃圾收集器">第十四章-垃圾收集器</span>
            <span class="post-date" title="2024-07-10 19:27:00">2024/07/10</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/484946532.html"
           data-tag="算法,合并有序链表"
           data-author="" >
            <span class="post-title" title="合并两个有序链表">合并两个有序链表</span>
            <span class="post-date" title="2024-07-06 09:11:00">2024/07/06</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2929260443.html"
           data-tag="算法,链表"
           data-author="" >
            <span class="post-title" title="链表反转">链表反转</span>
            <span class="post-date" title="2024-07-05 19:45:45">2024/07/05</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/1403776474.html"
           data-tag="算法,选择排序,冒泡排序,插入排序"
           data-author="" >
            <span class="post-title" title="选择-冒泡-插入排序">选择-冒泡-插入排序</span>
            <span class="post-date" title="2024-07-03 11:02:16">2024/07/03</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2561891005.html"
           data-tag="算法,二分法"
           data-author="" >
            <span class="post-title" title="二分搜索">二分搜索</span>
            <span class="post-date" title="2024-06-29 10:04:10">2024/06/29</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2224151177.html"
           data-tag="算法,二进制,位运算"
           data-author="" >
            <span class="post-title" title="二进制和位运算">二进制和位运算</span>
            <span class="post-date" title="2024-06-20 08:04:00">2024/06/20</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2105268063.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十三章-垃圾回收相关概念">第十三章-垃圾回收相关概念</span>
            <span class="post-date" title="2024-01-14 14:27:00">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/364508352.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十二章-垃圾回收概述和相关算法">第十二章-垃圾回收概述和相关算法</span>
            <span class="post-date" title="2024-01-06 16:28:00">2024/01/06</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/2050535563.html"
           data-tag="linux,jenkins"
           data-author="" >
            <span class="post-title" title="Jenkins的安装和搭建自动化部署平台">Jenkins的安装和搭建自动化部署平台</span>
            <span class="post-date" title="2024-01-05 16:00:00">2024/01/05</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2388209687.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十一章-StringTable(字符串常量池)">第十一章-StringTable(字符串常量池)</span>
            <span class="post-date" title="2023-12-25 17:27:06">2023/12/25</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3385856233.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十章-执行引擎">第十章-执行引擎</span>
            <span class="post-date" title="2023-12-23 20:03:00">2023/12/23</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/4075763684.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第九章-对象的实例化内存布局与访问定位">第九章-对象的实例化内存布局与访问定位</span>
            <span class="post-date" title="2023-12-21 11:50:00">2023/12/21</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3720767522.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第八章-直接内存">第八章-直接内存</span>
            <span class="post-date" title="2023-12-20 17:03:00">2023/12/20</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/105864584.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第七章-方法区">第七章-方法区</span>
            <span class="post-date" title="2023-12-14 18:24:00">2023/12/14</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/543408063.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第六章-JVM堆">第六章-JVM堆</span>
            <span class="post-date" title="2023-12-02 08:01:00">2023/12/02</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/554039338.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第五章-本地方法接口">第五章-本地方法接口</span>
            <span class="post-date" title="2023-11-30 17:55:00">2023/11/30</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1123461525.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第四章-虚拟机栈">第四章-虚拟机栈</span>
            <span class="post-date" title="2023-11-28 20:55:00">2023/11/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1626061462.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第三章-运行时数据区">第三章-运行时数据区</span>
            <span class="post-date" title="2023-11-28 19:31:00">2023/11/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/222077543.html"
           data-tag="java,jvm,双亲委派机制"
           data-author="" >
            <span class="post-title" title="第二章-JVM类加载子系统">第二章-JVM类加载子系统</span>
            <span class="post-date" title="2023-11-25 14:35:00">2023/11/25</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1897413233.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第一章-JVM和Java体系结构">第一章-JVM和Java体系结构</span>
            <span class="post-date" title="2023-11-25 10:00:00">2023/11/25</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/4179015178.html"
           data-tag="hexo,github pages,sitemap"
           data-author="" >
            <span class="post-title" title="给博客网站添加站点地图-sitemap">给博客网站添加站点地图-sitemap</span>
            <span class="post-date" title="2023-11-21 20:00:00">2023/11/21</span>
        </a>
        
        
        <a  class="全部文章 Hexo Typora "
           href="/blog/877664098.html"
           data-tag="hexo,typora,github"
           data-author="" >
            <span class="post-title" title="Typora设置图片自动上传Github">Typora设置图片自动上传Github</span>
            <span class="post-date" title="2023-11-20 20:30:00">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/3069199997.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="Hexo主题常用配置">Hexo主题常用配置</span>
            <span class="post-date" title="2023-11-20 00:00:01">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/2016918085.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="Hexo博客安装主题">Hexo博客安装主题</span>
            <span class="post-date" title="2023-11-20 00:00:01">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/3070587776.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="基于Hexo和Github Pages搭建个人博客">基于Hexo和Github Pages搭建个人博客</span>
            <span class="post-date" title="2023-11-18 15:40:20">2023/11/18</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-k8s/007-K8S存储" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">007-Kubernetes 存储</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="k8s">k8s</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color1">linux</a>
            
            <a class="color2">Docker</a>
            
            <a class="color1">Rocky</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2025-05-30 17:55:05'>2025-05-02 10:26</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:26.2k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB"><span class="toc-text">一、存储分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E5%90%84%E7%B1%BB%E7%89%B9%E6%80%A7"><span class="toc-text">1. 存储各类特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ConfigMap"><span class="toc-text">二、ConfigMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ConfigMap%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">2. ConfigMap创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%80%9A%E8%BF%87%E7%9B%AE%E5%BD%95%E5%88%9B%E5%BB%BA"><span class="toc-text">2.1 通过目录创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95"><span class="toc-text">2.1.1 文件及目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">2.1.2 文件内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%88%9B%E5%BB%BA-ConfigMap"><span class="toc-text">2.1.3 创建 ConfigMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E6%9F%A5%E7%9C%8B-ConfigMap-%E6%95%B0%E6%8D%AE"><span class="toc-text">2.1.4 查看 ConfigMap 数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA"><span class="toc-text">2.2 通过文件创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">2.2.1 文件内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%88%9B%E5%BB%BA-ConfigMap"><span class="toc-text">2.2.2 创建 ConfigMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%9F%A5%E7%9C%8B-ConfigMap-%E6%95%B0%E6%8D%AE"><span class="toc-text">2.2.3 查看 ConfigMap 数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA"><span class="toc-text">2.3 通过命令行创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%88%9B%E5%BB%BA-ConfigMap"><span class="toc-text">2.3.1 创建 ConfigMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E6%9F%A5%E7%9C%8B-ConfigMap"><span class="toc-text">2.3.2 查看 ConfigMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%80%9A%E8%BF%87yaml%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA"><span class="toc-text">2.4 通过yaml文件创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95"><span class="toc-text">2.4.1 文件及目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">2.4.2 文件内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E5%88%9B%E5%BB%BA-ConfigMap"><span class="toc-text">2.4.3 创建 ConfigMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E6%9F%A5%E7%9C%8B-ConfigMap-%E6%95%B0%E6%8D%AE"><span class="toc-text">2.4.4 查看 ConfigMap 数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Pod%E4%B8%AD%E4%BD%BF%E7%94%A8ConfigMap"><span class="toc-text">3. Pod中使用ConfigMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BD%BF%E7%94%A8ConfigMap%E6%9D%A5%E6%9B%BF%E4%BB%A3%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">3.1 使用ConfigMap来替代环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">3.1.1 定义资源清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E5%88%9B%E5%BB%BAConfigMap-%E3%80%81Pod"><span class="toc-text">3.1.2 创建ConfigMap 、Pod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E6%9F%A5%E7%9C%8BPod%E6%97%A5%E5%BF%97"><span class="toc-text">3.1.3 查看Pod日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-%E8%BF%9B%E5%85%A5Pod%E5%AE%B9%E5%99%A8%E5%86%85%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">3.1.4 进入Pod容器内查看环境变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8-ConfigMap-%E8%AE%BE%E7%BD%AE%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">3.2 使用 ConfigMap 设置命令行参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">3.2.1 定义资源清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%88%9B%E5%BB%BA-ConfigMap-%E3%80%81Pod"><span class="toc-text">3.2.2 创建 ConfigMap 、Pod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%9F%A5%E7%9C%8BPod%E6%97%A5%E5%BF%97"><span class="toc-text">3.2.3 查看Pod日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8ConfigMap%E3%80%90%E6%8E%A8%E8%8D%90%E3%80%91"><span class="toc-text">3.3 通过数据卷插件使用ConfigMap【推荐】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">3.3.1  定义资源清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%88%9B%E5%BB%BA-ConfigMap%E3%80%81Pod"><span class="toc-text">3.3.2 创建 ConfigMap、Pod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E8%BF%9B%E5%85%A5-Pod%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-text">3.3.3 进入 Pod，查看挂载文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-ConfigMap-%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-text">3.4 ConfigMap 热更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E5%88%9B%E5%BB%BA-ConfigMap"><span class="toc-text">3.4.1 创建 ConfigMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">3.4.2 定义资源清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">3.4.3 创建容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-%E7%BC%96%E8%BE%91%E4%BF%AE%E6%94%B9-ConfigMap"><span class="toc-text">3.4.4 编辑修改 ConfigMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-text">3.4.5 手动触发热更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-6-%E7%83%AD%E6%9B%B4%E6%96%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">3.4.6 热更新注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-configmap-%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98"><span class="toc-text">3.5 configmap-不可改变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Secret"><span class="toc-text">三、Secret</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Secret-%E5%AE%9A%E4%B9%89"><span class="toc-text">1. Secret - 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Secret-%E7%89%B9%E6%80%A7"><span class="toc-text">2. Secret - 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Secret-%E7%B1%BB%E5%9E%8B"><span class="toc-text">3. Secret - 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Secret-Opaque"><span class="toc-text">4. Secret-Opaque</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Opaque-%E6%A6%82%E5%BF%B5"><span class="toc-text">4.1 Opaque - 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Opaque-%E5%88%9B%E5%BB%BA"><span class="toc-text">4.2 Opaque - 创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%89%8B%E5%8A%A8%E5%8A%A0%E5%AF%86%EF%BC%8C%E5%9F%BA%E4%BA%8EBase64%E5%8A%A0%E5%AF%86"><span class="toc-text">4.2.1 手动加密，基于Base64加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E4%BD%BF%E7%94%A8-yml-%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA-Opaque"><span class="toc-text">4.2.2 使用 yml 文件创建 Opaque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA-Opaque"><span class="toc-text">4.2.3 使用命令行创建 Opaque</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%9F%A5%E7%9C%8B-Opaque"><span class="toc-text">4.3 查看 Opaque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Opaque-%E7%94%A8%E4%BA%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">4.4 Opaque 用于环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Opaque-%E7%94%A8%E4%BA%8E-Volume-%E5%8D%B7"><span class="toc-text">4.4 Opaque 用于 Volume 卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Opaque-Volume-%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-text">4.5 Opaque - Volume - 热更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Opaque-Volume-%E4%B8%8D%E5%8F%AF%E6%9B%B4%E6%94%B9"><span class="toc-text">4.6 Opaque - Volume - 不可更改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Secret-docker-registry"><span class="toc-text">5. Secret - docker-registry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%90%AD%E5%BB%BA-Harbor-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-text">5.1 搭建 Harbor 镜像仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%85%8D%E7%BD%AE-Docker"><span class="toc-text">5.2 配置 Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%88%9B%E5%BB%BAHarbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-text">5.3 创建Harbor私有仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F%E5%88%B0-Harbor-%E7%A7%81%E6%9C%8D"><span class="toc-text">5.4 上传镜像到 Harbor 私服</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Pod-%E7%9B%B4%E6%8E%A5%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-text">5.5  Pod 直接拉取镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-Pod-%E9%80%9A%E8%BF%87-Secret-%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-text">5.6 Pod 通过 Secret 拉取镜像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Downward-API"><span class="toc-text">四、Downward API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B0%86-Pod-%E5%AD%97%E6%AE%B5%E5%BA%94%E7%94%A8%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD"><span class="toc-text">1. 将 Pod 字段应用到环境变量中</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">1.1 资源清单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%9B%E5%BB%BA-Pod"><span class="toc-text">1.2 创建 Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%9F%A5%E7%9C%8B-Pod-%E7%8A%B6%E6%80%81"><span class="toc-text">1.3 查看 Pod 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%9F%A5%E7%9C%8B-Pod-%E8%BF%90%E8%A1%8C%E6%97%A5%E5%BF%97"><span class="toc-text">1.4 查看 Pod 运行日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E8%BF%9B%E5%85%A5Pod%E5%AE%B9%E5%99%A8%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">1.5 进入Pod容器，查看环境变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%86%E5%AE%B9%E5%99%A8%E5%AD%97%E6%AE%B5%E5%BA%94%E7%94%A8%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD"><span class="toc-text">2. 将容器字段应用到环境变量中</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">2.1 资源清单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%88%9B%E5%BB%BA-Pod"><span class="toc-text">2.2 创建 Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%9F%A5%E7%9C%8B-Pod-%E7%8A%B6%E6%80%81"><span class="toc-text">2.3 查看 Pod 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%9F%A5%E7%9C%8B-Pod-%E8%BF%90%E8%A1%8C%E6%97%A5%E5%BF%97"><span class="toc-text">2.4 查看 Pod 运行日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%BF%9B%E5%85%A5-Pod%E5%AE%B9%E5%99%A8%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">2.5 进入 Pod容器，查看环境变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8C%82%E8%BD%BD-Pod-%E5%AD%97%E6%AE%B5%E5%88%B0-Volume"><span class="toc-text">3. 挂载 Pod 字段到 Volume</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">3.1 资源清单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%88%9B%E5%BB%BA-Pod"><span class="toc-text">3.2 创建 Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%9F%A5%E7%9C%8B-Pod-%E7%8A%B6%E6%80%81"><span class="toc-text">3.3 查看 Pod 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9F%A5%E7%9C%8B-Pod-%E6%8C%82%E8%BD%BD%E7%9B%AE%E5%BD%95"><span class="toc-text">3.4 查看 Pod 挂载目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8C%82%E8%BD%BD%E5%AE%B9%E5%99%A8%E5%AD%97%E6%AE%B5%E5%88%B0-Volume"><span class="toc-text">4. 挂载容器字段到 Volume</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">4.1 资源清单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%88%9B%E5%BB%BA-Pod"><span class="toc-text">4.2 创建 Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%9F%A5%E7%9C%8B-Pod-%E7%8A%B6%E6%80%81"><span class="toc-text">4.3 查看 Pod 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%9F%A5%E7%9C%8B-Pod-%E6%97%A5%E5%BF%97"><span class="toc-text">4.4 查看 Pod 日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E8%BF%9B%E5%85%A5-Pod-%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-text">4.5 进入 Pod 目录，查看挂载文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Downward-API-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">5. Downward API 常用属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-volume-%E7%9B%B8%E8%BE%83%E4%BA%8E-env-%E4%BC%98%E5%8A%BF"><span class="toc-text">6. volume 相较于 env 优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Volume"><span class="toc-text">五、Volume</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Volume%E6%A6%82%E8%BF%B0"><span class="toc-text">1. Volume概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Volume%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. Volume类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-EmptyDir-%E5%8D%B7"><span class="toc-text">3. EmptyDir 卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-emptyDir%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E9%80%94"><span class="toc-text">3.1 emptyDir的一些用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-emptyDir-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">3.2 emptyDir 使用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">3.2.1 资源清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%88%9B%E5%BB%BA-Deployment"><span class="toc-text">3.2.2 创建 Deployment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%9F%A5%E7%9C%8B-Pod-%E8%AF%A6%E6%83%85"><span class="toc-text">3.2.3 查看 Pod 详情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E8%BF%9B%E5%85%A5-nginx-container-%E5%AE%B9%E5%99%A8%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-text">3.2.4 进入 nginx-container 容器查看日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E8%BF%9B%E5%85%A5-busybox-container-%E5%AE%B9%E5%99%A8%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-text">3.2.5 进入 busybox-container 容器查看日志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-HostPath"><span class="toc-text">4. HostPath</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-hostPath-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95"><span class="toc-text">4.1 hostPath 的一些用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%94%AF%E6%8C%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.2 支持类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">4.3 注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-hostPath-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">4.4 hostPath 使用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">4.4.1 资源清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E5%88%9B%E5%BB%BA-Deployment"><span class="toc-text">4.4.2 创建 Deployment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E8%BF%9B%E5%85%A5-busybox-container-%E5%AE%B9%E5%99%A8%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-text">4.4.3 进入 busybox-container 容器查看日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-%E6%9F%A5%E7%9C%8B%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BD%E7%9B%AE%E5%BD%95"><span class="toc-text">4.4.4 查看宿主机挂载目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-NFS"><span class="toc-text">5. NFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%89%E8%A3%85-NFS-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">5.1 安装 NFS 文件服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E5%AE%89%E8%A3%85-NFS-%E6%9C%8D%E5%8A%A1"><span class="toc-text">5.1.1 安装 NFS 服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95"><span class="toc-text">5.1.2 创建共享目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-%E7%BC%96%E8%BE%91%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95%E8%AF%BB%E5%86%99%E9%85%8D%E7%BD%AE"><span class="toc-text">5.1.3 编辑共享目录读写配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-%E5%90%AF%E5%8A%A8NFS%E6%9C%8D%E5%8A%A1"><span class="toc-text">5.1.4 启动NFS服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-5-%E6%B5%8B%E8%AF%95NFS%E6%9C%8D%E5%8A%A1"><span class="toc-text">5.1.5 测试NFS服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-6-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8D%B8%E8%BD%BD-NFS-%E6%8C%82%E8%BD%BD%E7%9B%AE%E5%BD%95"><span class="toc-text">5.1.6 客户端卸载 NFS 挂载目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-7-%E4%BD%BF%E7%94%A8-NFS4-%E6%9C%8D%E5%8A%A1"><span class="toc-text">5.1.7 使用 NFS4 服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BD%BF%E7%94%A8-NFS-%E6%8C%82%E8%BD%BD-Pod-%E7%9B%AE%E5%BD%95"><span class="toc-text">5.2 使用 NFS 挂载 Pod 目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">5.2.1 资源清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E5%88%9B%E5%BB%BA-Deployment"><span class="toc-text">5.2.2 创建 Deployment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E6%9F%A5%E7%9C%8B-NFS-%E6%8C%82%E8%BD%BD%E7%9B%AE%E5%BD%95"><span class="toc-text">5.2.3 查看 NFS 挂载目录</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81PV-PVC"><span class="toc-text">六、PV&#x2F;PVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-PV%E6%A6%82%E8%BF%B0"><span class="toc-text">2. PV概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-PVC%E6%A6%82%E8%BF%B0"><span class="toc-text">3. PVC概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-PV-%E5%92%8C-PVC-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4. PV 和 PVC 的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Persistent-Volume-PV-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4.1 Persistent Volume (PV) 的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Persistent-Volume-Claim-PVC-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4.2 Persistent Volume Claim (PVC) 的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8C%81%E4%B9%85%E5%8C%96%E5%A3%B0%E6%98%8E%E4%BF%9D%E6%8A%A4"><span class="toc-text">5. 持久化声明保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-text">6. 回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Retain-%E4%BF%9D%E7%95%99"><span class="toc-text">6.1 Retain (保留)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Delete-%E5%88%A0%E9%99%A4"><span class="toc-text">6.2 Delete (删除)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Recycle-%E5%9B%9E%E6%94%B6"><span class="toc-text">6.3 Recycle (回收)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Persistent-Volumes-%E7%B1%BB%E5%9E%8B"><span class="toc-text">7. Persistent Volumes 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-PV%E7%A4%BA%E4%BE%8B%E4%B8%8E%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-text">8. PV示例与参数说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-PV%E7%A4%BA%E4%BE%8B"><span class="toc-text">8.1 PV示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-PV%E5%8D%B7%E7%8A%B6%E6%80%81"><span class="toc-text">8.2 PV卷状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-PV-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%94%AF%E6%8C%81%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.3 PV 类型与支持的访问模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-PV-PVC%E7%A4%BA%E4%BE%8B"><span class="toc-text">9. PV-PVC示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF"><span class="toc-text">9.1 主机信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-NFS%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2"><span class="toc-text">9.2 NFS服务部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-PV-%E9%83%A8%E7%BD%B2"><span class="toc-text">9.3 PV 部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-StatefulSet-%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8-PVC"><span class="toc-text">9.4 StatefulSet 创建并使用 PVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="toc-text">9.4.1 资源清单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-%E5%90%AF%E5%8A%A8pod%E5%B9%B6%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81"><span class="toc-text">9.4.2 启动pod并查看状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-3-PV%E5%92%8CPVC%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B"><span class="toc-text">9.4.3 PV和PVC状态信息查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-4-curl%E8%AE%BF%E9%97%AE%E9%AA%8C%E8%AF%81"><span class="toc-text">9.4.4 curl访问验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E5%88%A0%E9%99%A4-StatefulSet-%E5%B9%B6%E5%9B%9E%E6%94%B6-PV"><span class="toc-text">9.5 删除 StatefulSet 并回收 PV</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-1-%E5%88%A0%E9%99%A4-StatefulSet"><span class="toc-text">9.5.1 删除 StatefulSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-2-%E6%9F%A5%E7%9C%8BPVC%E5%92%8CPV%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4PVC"><span class="toc-text">9.5.2 查看PVC和PV，并删除PVC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-3-%E5%9B%9E%E6%94%B6-PV"><span class="toc-text">9.5.3 回收 PV</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-StatefulSet%E7%BD%91%E7%BB%9C%E6%A0%87%E8%AF%86%E4%B8%8EPVC"><span class="toc-text">10. StatefulSet网络标识与PVC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81StorageClass"><span class="toc-text">七、StorageClass</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%90%86%E8%AE%BA"><span class="toc-text">1. 理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-StorageClass"><span class="toc-text">1.1 什么是 StorageClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-StorageClass"><span class="toc-text">1.2 为什么需要 StorageClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">1.3  运行原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-StorageClass-%E8%B5%84%E6%BA%90"><span class="toc-text">2. StorageClass 资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AD%98%E5%82%A8%E5%88%B6%E5%A4%87%E5%99%A8"><span class="toc-text">2.1 存储制备器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-text">2.2 回收策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%85%81%E8%AE%B8%E5%8D%B7%E6%89%A9%E5%B1%95"><span class="toc-text">2.3 允许卷扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%8C%82%E8%BD%BD%E9%80%89%E9%A1%B9"><span class="toc-text">2.4 挂载选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%8D%B7%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.5 卷绑定模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%85%81%E8%AE%B8%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="toc-text">2.6 允许的拓扑结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-text">3. 案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B"><span class="toc-text">3.1 部署流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%90%AD%E5%BB%BA-NFS-%E6%9C%8D%E5%8A%A1"><span class="toc-text">3.2 搭建 NFS 服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">3.3 创建命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%88%9B%E5%BB%BA-Service-Account"><span class="toc-text">3.4 创建 Service Account</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-ServiceAccount"><span class="toc-text">3.4.1 ServiceAccount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-ClusterRole"><span class="toc-text">3.4.2 ClusterRole</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-ClusterRoleBinding"><span class="toc-text">3.4.3 ClusterRoleBinding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-Role"><span class="toc-text">3.4.4 Role</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-RoleBinding"><span class="toc-text">3.4.5 RoleBinding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-6-StorageClass"><span class="toc-text">3.4.6 StorageClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-7-Deployment"><span class="toc-text">3.4.7 Deployment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-8-PersistentVolumeClaim-PVC"><span class="toc-text">3.4.8 PersistentVolumeClaim (PVC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-9-%E6%B5%8B%E8%AF%95-Pod"><span class="toc-text">3.4.9 测试 Pod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-10-%E6%B5%8B%E8%AF%95-Service"><span class="toc-text">3.4.10 测试 Service</span></a></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在K8S中，容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes 引入了 Volume 的概念。</p>
<p>Volume 是 Pod 中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个 Pod 里的多个容器挂载到具体的文件目录下，kubernetes 通过 Volume 实现同一个 Pod 中不同容器之间的数据共享以及数据的持久化存储。Volume 的生命容器不与 Pod 中单个容器的生命周期相关，当容器终止或者重启时，Volume 中的数据也不会丢失。</p>
<h1 id="一、存储分类"><a href="#一、存储分类" class="headerlink" title="一、存储分类"></a>一、存储分类</h1><p>kubernetes 的 Volume 支持多种类型，比较常见的有下面几个：</p>
<ul>
<li>简单存储：EmptyDir、HostPath、NFS</li>
<li>高级存储：PV、PVC</li>
<li>配置存储：ConfigMap、Secret</li>
</ul>
<h2 id="1-存储各类特性"><a href="#1-存储各类特性" class="headerlink" title="1. 存储各类特性"></a>1. 存储各类特性</h2><ul>
<li>元数据<ul>
<li>configMap：用于保存配置数据（明文）</li>
<li>Secret：用于保存敏感性数据（编码）</li>
<li>Downward API：容器在运行时从 Kubernetes API 服务器获取有关它们自身的信息</li>
</ul>
</li>
<li>真实数据<ul>
<li>Volume：用于存储临时或者持久性数据</li>
<li>PersistentVolume：申请制的持久化存储</li>
</ul>
</li>
</ul>
<h1 id="二、ConfigMap"><a href="#二、ConfigMap" class="headerlink" title="二、ConfigMap"></a>二、ConfigMap</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>ConfigMap 是一种 API 对象，用来将非机密性的数据保存到健值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。</p>
<p>ConfigMap 将环境配置信息和容器镜像解耦，便于应用配置的修改。当你需要储存机密信息时可以使用 Secret 对象。</p>
<p><em>备注：ConfigMap 并不提供保密或者加密功能。如果你想存储的数据是机密的，请使用 Secret；或者使用其他第三方工具来保证数据的私密性，而不是用 ConfigMap。</em></p>
<h2 id="2-ConfigMap创建方式"><a href="#2-ConfigMap创建方式" class="headerlink" title="2. ConfigMap创建方式"></a>2. ConfigMap创建方式</h2><h3 id="2-1-通过目录创建"><a href="#2-1-通过目录创建" class="headerlink" title="2.1 通过目录创建"></a>2.1 通过目录创建</h3><h4 id="2-1-1-文件及目录"><a href="#2-1-1-文件及目录" class="headerlink" title="2.1.1 文件及目录"></a>2.1.1 文件及目录</h4><pre><code class="highlight bash"><span class="comment"># 当前目录位置</span>
$ <span class="built_in">pwd</span>
/opt/k8s/07/configMap/dir

<span class="comment"># 目录下的文件</span>
$ ll
total 8
-rw-r--r-- 1 root root 158 May 10 14:40 game.properties
-rw-r--r-- 1 root root  83 May 10 14:41 ui.properties</code></pre>



<h4 id="2-1-2-文件内容"><a href="#2-1-2-文件内容" class="headerlink" title="2.1.2 文件内容"></a>2.1.2 文件内容</h4><p><code>game.properties</code></p>
<pre><code class="highlight properties"><span class="attr">enemies</span>=<span class="string">aliens</span>
<span class="attr">lives</span>=<span class="string">3</span>
<span class="attr">enemies.cheat</span>=<span class="string">true</span>
<span class="attr">enemies.cheat.level</span>=<span class="string">noGoodRotten</span>
<span class="attr">secret.code.passphrase</span>=<span class="string">UUDDLRLRBABAs</span>
<span class="attr">secret.code.allowed</span>=<span class="string">true</span>
<span class="attr">secret.code.lives</span>=<span class="string">30</span></code></pre>



<p><code>ui.properties</code></p>
<pre><code class="highlight properties"><span class="attr">color.good</span>=<span class="string">purple</span>
<span class="attr">color.bad</span>=<span class="string">yellow</span>
<span class="attr">allow.textmode</span>=<span class="string">true</span>
<span class="attr">how.nice.to.look</span>=<span class="string">fairlyNice</span></code></pre>



<h4 id="2-1-3-创建-ConfigMap"><a href="#2-1-3-创建-ConfigMap" class="headerlink" title="2.1.3 创建 ConfigMap"></a>2.1.3 创建 ConfigMap</h4><pre><code class="highlight bash"><span class="comment"># 指定目录创建 ConfigMap</span>
$ kubectl create configmap dir-config --from-file=/opt/k8s/07/configMap/dir/

<span class="comment"># 查看 ConfigMap</span>
$ kubectl get configmap
NAME               DATA   AGE
dir-config         2      24s</code></pre>



<h4 id="2-1-4-查看-ConfigMap-数据"><a href="#2-1-4-查看-ConfigMap-数据" class="headerlink" title="2.1.4 查看 ConfigMap 数据"></a>2.1.4 查看 ConfigMap 数据</h4><p><strong>方式一: 以yaml格式展示</strong></p>
<pre><code class="highlight bash">$ kubectl get configmap dir-config -o yaml
<span class="comment"># 内容如下：</span>
apiVersion: v1
data:
  game.properties: |
    enemies=aliens
    lives=3
    enemies.cheat=<span class="literal">true</span>
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAs
    secret.code.allowed=<span class="literal">true</span>
    secret.code.lives=30
  ui.properties: |
    color.good=purple
    color.bad=yellow
    allow.textmode=<span class="literal">true</span>
    how.nice.to.look=fairlyNice
kind: ConfigMap
metadata:
  creationTimestamp: <span class="string">&quot;2025-05-10T06:46:58Z&quot;</span>
  name: dir-config
  namespace: default
  resourceVersion: <span class="string">&quot;6014969&quot;</span>
  uid: b5283e4e-dfbd-466c-bd4f-b4cc6fe2ef2a</code></pre>



<p><strong>方式二</strong></p>
<pre><code class="highlight bash">$ kubectl describe configmap dir-config
<span class="comment"># 内容如下：</span>
Name:         dir-config
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=<span class="literal">true</span>
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAs
secret.code.allowed=<span class="literal">true</span>
secret.code.lives=30

ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=<span class="literal">true</span>
how.nice.to.look=fairlyNice


BinaryData
====

Events:  &lt;none&gt;</code></pre>





<h3 id="2-2-通过文件创建"><a href="#2-2-通过文件创建" class="headerlink" title="2.2 通过文件创建"></a>2.2 通过文件创建</h3><h4 id="2-2-1-文件内容"><a href="#2-2-1-文件内容" class="headerlink" title="2.2.1 文件内容"></a>2.2.1 文件内容</h4><p>文件路径：<code>/opt/k8s/07/configMap/dir/game.properties</code></p>
<pre><code class="highlight properties"><span class="attr">enemies</span>=<span class="string">aliens</span>
<span class="attr">lives</span>=<span class="string">3</span>
<span class="attr">enemies.cheat</span>=<span class="string">true</span>
<span class="attr">enemies.cheat.level</span>=<span class="string">noGoodRotten</span>
<span class="attr">secret.code.passphrase</span>=<span class="string">UUDDLRLRBABAs</span>
<span class="attr">secret.code.allowed</span>=<span class="string">true</span>
<span class="attr">secret.code.lives</span>=<span class="string">30</span></code></pre>



<h4 id="2-2-2-创建-ConfigMap"><a href="#2-2-2-创建-ConfigMap" class="headerlink" title="2.2.2 创建 ConfigMap"></a>2.2.2 创建 ConfigMap</h4><pre><code class="highlight bash"><span class="comment"># 指定文件创建 ConfigMap</span>
$ kubectl create configmap file-config --from-file=/opt/k8s/07/configMap/dir/game.properties

<span class="comment"># 查看 ConfigMap</span>
$ kubectl get configmap
NAME               DATA   AGE
dir-config         2      11m
file-config        1      13s</code></pre>



<h4 id="2-2-3-查看-ConfigMap-数据"><a href="#2-2-3-查看-ConfigMap-数据" class="headerlink" title="2.2.3 查看 ConfigMap 数据"></a>2.2.3 查看 ConfigMap 数据</h4><p><strong>方式一: 以yaml格式展示</strong></p>
<pre><code class="highlight bash">$ kubectl get configmap file-config -o yaml</code></pre>



<p><strong>方式二</strong></p>
<pre><code class="highlight bash">$ kubectl describe configmap file-config</code></pre>





<h3 id="2-3-通过命令行创建"><a href="#2-3-通过命令行创建" class="headerlink" title="2.3 通过命令行创建"></a>2.3 通过命令行创建</h3><h4 id="2-3-1-创建-ConfigMap"><a href="#2-3-1-创建-ConfigMap" class="headerlink" title="2.3.1 创建 ConfigMap"></a>2.3.1 创建 ConfigMap</h4><pre><code class="highlight bash"><span class="comment"># 通过命令行创建 ConfigMap</span>
$ kubectl create configmap cmd-config --from-literal=special.how=very --from-literal=<span class="string">&quot;special.type=charm&quot;</span>

<span class="comment"># 查看 ConfigMap</span>
$ kubectl get configmap
NAME               DATA   AGE
cmd-config         2      107s
dir-config         2      21m
file-config        1      10m</code></pre>

<p><code>--from-literal=</code> 后面的参数 <code>&quot; &quot;</code> 可加可不加</p>
<h4 id="2-3-2-查看-ConfigMap"><a href="#2-3-2-查看-ConfigMap" class="headerlink" title="2.3.2 查看 ConfigMap"></a>2.3.2 查看 ConfigMap</h4><p><strong>方式一: 以yaml格式展示</strong></p>
<pre><code class="highlight bash">$ kubectl get configmap cmd-config -o yaml
<span class="comment"># 内容如下：</span>
apiVersion: v1
data:
  special.how: very
  special.type: charm
kind: ConfigMap
metadata:
  creationTimestamp: <span class="string">&quot;2025-05-10T07:07:01Z&quot;</span>
  name: cmd-config
  namespace: default
  resourceVersion: <span class="string">&quot;6016743&quot;</span>
  uid: 9cd7d408-d7c1-47f8-99db-ecb4bb33f74f</code></pre>



<p><strong>方式二</strong></p>
<pre><code class="highlight bash">$ kubectl describe configmap cmd-config
<span class="comment"># 内容如下：</span>
Name:         cmd-config
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
special.how:
----
very
special.type:
----
charm

BinaryData
====

Events:  &lt;none&gt;</code></pre>



<h3 id="2-4-通过yaml文件创建"><a href="#2-4-通过yaml文件创建" class="headerlink" title="2.4 通过yaml文件创建"></a>2.4 通过yaml文件创建</h3><h4 id="2-4-1-文件及目录"><a href="#2-4-1-文件及目录" class="headerlink" title="2.4.1 文件及目录"></a>2.4.1 文件及目录</h4><pre><code class="highlight bash">$ <span class="built_in">pwd</span>
/opt/k8s/07/configMap/yaml

$ ll
total 4
-rw-r--r-- 1 root root 487 May 10 15:58 configmap-demo.yaml</code></pre>



<h4 id="2-4-2-文件内容"><a href="#2-4-2-文件内容" class="headerlink" title="2.4.2 文件内容"></a>2.4.2 文件内容</h4><p><code>configmap-demo.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">ConfigMap</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">configmap-demo</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
  <span class="attr">labels:</span>
    <span class="attr">configmap:</span> <span class="string">myconfig</span>
<span class="attr">data:</span>
  <span class="comment"># 类属性键，每个键都映射一个简单的值</span>
  <span class="attr">username:</span> <span class="string">&quot;george&quot;</span>
  <span class="attr">user_file:</span> <span class="string">&#x27;user.properties&#x27;</span>
  <span class="attr">game_file:</span> <span class="string">&#x27;game.properties&#x27;</span>
  <span class="comment"># 类文件键，每个键都对应一个文件，| 下是文件的内容</span>
  <span class="attr">user.properties:</span> <span class="string">|</span>
<span class="string">    age=23</span>
<span class="string">    address=中国</span>
<span class="string"></span>  <span class="attr">game.propertie:</span> <span class="string">|</span>
<span class="string">    enemy.types=aliens,monsters</span>
<span class="string">    player.maximum-lives=5</span></code></pre>



<h4 id="2-4-3-创建-ConfigMap"><a href="#2-4-3-创建-ConfigMap" class="headerlink" title="2.4.3 创建 ConfigMap"></a>2.4.3 创建 ConfigMap</h4><pre><code class="highlight bash"><span class="comment"># 通过 ConfigMap yaml 资源清单创建</span>
$ kubectl apply -f configmap-demo.yaml

<span class="comment"># 查看 ConfigMap</span>
$ kubectl get configmap
NAME               DATA   AGE
configmap-demo     5      20s</code></pre>



<h4 id="2-4-4-查看-ConfigMap-数据"><a href="#2-4-4-查看-ConfigMap-数据" class="headerlink" title="2.4.4 查看 ConfigMap 数据"></a>2.4.4 查看 ConfigMap 数据</h4><p><strong>方式一: 以yaml格式展示</strong></p>
<pre><code class="highlight bash">$ kubectl get configmap configmap-demo -o yaml
<span class="comment"># 内容如下</span>
apiVersion: v1
data:
  game.propertie: |
    enemy.types=aliens,monsters
    player.maximum-lives=5
  game_file: game.properties
  user.properties: |
    age=23
    address=中国
  user_file: user.properties
  username: george
kind: ConfigMap
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      &#123;<span class="string">&quot;apiVersion&quot;</span>:<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;game.propertie&quot;</span>:<span class="string">&quot;enemy.types=aliens,monsters\nplayer.maximum-lives=5\n&quot;</span>,<span class="string">&quot;game_file&quot;</span>:<span class="string">&quot;game.properties&quot;</span>,<span class="string">&quot;user.properties&quot;</span>:<span class="string">&quot;age=23\naddress=中国\n&quot;</span>,<span class="string">&quot;user_file&quot;</span>:<span class="string">&quot;user.properties&quot;</span>,<span class="string">&quot;username&quot;</span>:<span class="string">&quot;george&quot;</span>&#125;,<span class="string">&quot;kind&quot;</span>:<span class="string">&quot;ConfigMap&quot;</span>,<span class="string">&quot;metadata&quot;</span>:&#123;<span class="string">&quot;annotations&quot;</span>:&#123;&#125;,<span class="string">&quot;labels&quot;</span>:&#123;<span class="string">&quot;configmap&quot;</span>:<span class="string">&quot;myconfig&quot;</span>&#125;,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;configmap-demo&quot;</span>,<span class="string">&quot;namespace&quot;</span>:<span class="string">&quot;default&quot;</span>&#125;&#125;
  creationTimestamp: <span class="string">&quot;2025-05-10T07:59:18Z&quot;</span>
  labels:
    configmap: myconfig
  name: configmap-demo
  namespace: default
  resourceVersion: <span class="string">&quot;6021397&quot;</span>
  uid: f3538c6c-4bd6-41e9-9b48-2c040181e2dc</code></pre>



<p><strong>方式二</strong></p>
<pre><code class="highlight bash">$ kubectl describe configmap configmap-demo
Name:         configmap-demo
Namespace:    default
Labels:       configmap=myconfig
Annotations:  &lt;none&gt;

Data
====
game_file:
----
game.properties
user.properties:
----
age=23
address=中国

user_file:
----
user.properties
username:
----
george
game.propertie:
----
enemy.types=aliens,monsters
player.maximum-lives=5


BinaryData
====

Events:  &lt;none&gt;</code></pre>





<h2 id="3-Pod中使用ConfigMap"><a href="#3-Pod中使用ConfigMap" class="headerlink" title="3. Pod中使用ConfigMap"></a>3. Pod中使用ConfigMap</h2><h3 id="3-1-使用ConfigMap来替代环境变量"><a href="#3-1-使用ConfigMap来替代环境变量" class="headerlink" title="3.1 使用ConfigMap来替代环境变量"></a>3.1 使用ConfigMap来替代环境变量</h3><h4 id="3-1-1-定义资源清单"><a href="#3-1-1-定义资源清单" class="headerlink" title="3.1.1 定义资源清单"></a>3.1.1 定义资源清单</h4><p>资源清单：<code>pod_configmap_env.yaml</code>， 定义了 2 个 configMap 和 1个 Pod</p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">ConfigMap</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">configmap-1</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">data:</span>
  <span class="comment"># 类属性键，每个键都映射一个简单的值</span>
  <span class="attr">username:</span> <span class="string">&quot;george&quot;</span>
  <span class="attr">password:</span> <span class="string">&quot;123456&quot;</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">ConfigMap</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">configmap-2</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">data:</span>
  <span class="comment"># 类文件键，每个键都对应一个文件，| 下是文件的内容</span>
  <span class="attr">user.properties:</span> <span class="string">|</span>
<span class="string">    age=23</span>
<span class="string">    address=中国</span>
<span class="string"></span>
<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pod-configmap-env</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">spec:</span>
  <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># Pod 重启策略</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span>
      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>
      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
      <span class="attr">command:</span> <span class="comment"># 打印完环境变量后休眠3600秒</span>
        <span class="bullet">-</span> <span class="string">&quot;/bin/sh&quot;</span>
        <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span>
        <span class="bullet">-</span> <span class="string">&quot;env &amp;&amp; sleep 3600&quot;</span>
      <span class="attr">env:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">USERNAME</span> <span class="comment"># 容器内环境变量的名称</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">configMapKeyRef:</span>
              <span class="attr">name:</span> <span class="string">configmap-1</span> <span class="comment"># configMap名称</span>
              <span class="attr">key:</span> <span class="string">username</span> <span class="comment"># configMap中定义的属性键</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PASSWORD</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">configMapKeyRef:</span>
              <span class="attr">name:</span> <span class="string">configmap-1</span>
              <span class="attr">key:</span> <span class="string">password</span>
      <span class="attr">envFrom:</span>
        <span class="bullet">-</span> <span class="attr">configMapRef:</span>
            <span class="attr">name:</span> <span class="string">configmap-2</span> <span class="comment"># configMap名称</span></code></pre>



<h4 id="3-1-2-创建ConfigMap-、Pod"><a href="#3-1-2-创建ConfigMap-、Pod" class="headerlink" title="3.1.2 创建ConfigMap 、Pod"></a>3.1.2 创建ConfigMap 、Pod</h4><pre><code class="highlight bash">$ kubectl apply -f pod_configmap_env.yaml 
configmap/configmap-1 created
configmap/configmap-2 created
pod/pod-configmap-env created</code></pre>



<p><strong>查看Pod运行状态</strong></p>
<pre><code class="highlight bash">$ kubectl get pods -o wide
NAME                READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES
pod-configmap-env   1/1     Running   0          5s    172.16.58.195   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre>



<h4 id="3-1-3-查看Pod日志"><a href="#3-1-3-查看Pod日志" class="headerlink" title="3.1.3 查看Pod日志"></a>3.1.3 查看Pod日志</h4><pre><code class="highlight bash">$ kubectl logs pod-configmap-env
KUBERNETES_SERVICE_PORT=443
KUBERNETES_PORT=tcp://10.96.0.1:443
HOSTNAME=pod-configmap-env
SHLVL=1
HOME=/root
USERNAME=george
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_SERVICE_HOST=10.96.0.1
PWD=/
user.properties=age=23
address=中国

PASSWORD=123456</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/05/10/20250510-171757.png" alt="打印环境变量"></p>
<h4 id="3-1-4-进入Pod容器内查看环境变量"><a href="#3-1-4-进入Pod容器内查看环境变量" class="headerlink" title="3.1.4 进入Pod容器内查看环境变量"></a>3.1.4 进入Pod容器内查看环境变量</h4><pre><code class="highlight bash"><span class="comment"># 进入 Pod 容器内部</span>
$ kubectl <span class="built_in">exec</span> -it pod-configmap-env /bin/bash

<span class="comment"># 查看环境变量</span>
pod-configmap-env:/<span class="comment"># env</span>
user.properties=age=23
address=中国

KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_SERVICE_PORT=443
CHARSET=UTF-8
HOSTNAME=pod-configmap-env
PWD=/
HOME=/root
USERNAME=george
LANG=C.UTF-8
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
PASSWORD=123456
TERM=xterm
SHLVL=1
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
KUBERNETES_SERVICE_HOST=10.96.0.1
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP_PORT=443
LC_COLLATE=C
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
_=/usr/bin/env
</code></pre>





<h3 id="3-2-使用-ConfigMap-设置命令行参数"><a href="#3-2-使用-ConfigMap-设置命令行参数" class="headerlink" title="3.2 使用 ConfigMap 设置命令行参数"></a>3.2 使用 ConfigMap 设置命令行参数</h3><h4 id="3-2-1-定义资源清单"><a href="#3-2-1-定义资源清单" class="headerlink" title="3.2.1 定义资源清单"></a>3.2.1 定义资源清单</h4><p><code>pod_configmap_cmd.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">ConfigMap</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">configmap-3</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">data:</span>
  <span class="comment"># 类属性键，每个键都映射一个简单的值</span>
  <span class="attr">username:</span> <span class="string">&quot;george&quot;</span>
  <span class="attr">password:</span> <span class="string">&quot;123456&quot;</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pod-configmap-cmd</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">spec:</span>
  <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># Pod 重启策略</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-cmd</span>
      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>
      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
      <span class="attr">command:</span> <span class="comment"># 打印环境变量指定的键值</span>
        <span class="bullet">-</span> <span class="string">&quot;/bin/sh&quot;</span>
        <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span>
        <span class="bullet">-</span> <span class="string">&quot;echo $(USERNAME) $(PASSWORD)&quot;</span>
      <span class="attr">env:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">USERNAME</span> <span class="comment"># 容器内环境变量的名称</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">configMapKeyRef:</span>
              <span class="attr">name:</span> <span class="string">configmap-3</span> <span class="comment"># configMap名称</span>
              <span class="attr">key:</span> <span class="string">username</span> <span class="comment"># configMap中定义的属性键</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PASSWORD</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">configMapKeyRef:</span>
              <span class="attr">name:</span> <span class="string">configmap-3</span>
              <span class="attr">key:</span> <span class="string">password</span></code></pre>



<h4 id="3-2-2-创建-ConfigMap-、Pod"><a href="#3-2-2-创建-ConfigMap-、Pod" class="headerlink" title="3.2.2 创建 ConfigMap 、Pod"></a>3.2.2 创建 ConfigMap 、Pod</h4><pre><code class="highlight bash">$ kubectl apply -f pod_configmap_cmd.yaml 
configmap/configmap-3 created
pod/pod-configmap-cmd created</code></pre>



<p><strong>查看Pod运行状态</strong></p>
<pre><code class="highlight bash">$ kubectl get pod pod-configmap-cmd
NAME                READY   STATUS      RESTARTS   AGE
pod-configmap-cmd   0/1     Completed   0          59s</code></pre>



<h4 id="3-2-3-查看Pod日志"><a href="#3-2-3-查看Pod日志" class="headerlink" title="3.2.3 查看Pod日志"></a>3.2.3 查看Pod日志</h4><pre><code class="highlight bash">$ kubectl logs -f pod-configmap-cmd
george 123456</code></pre>





<h3 id="3-3-通过数据卷插件使用ConfigMap【推荐】"><a href="#3-3-通过数据卷插件使用ConfigMap【推荐】" class="headerlink" title="3.3 通过数据卷插件使用ConfigMap【推荐】"></a>3.3 通过数据卷插件使用ConfigMap【推荐】</h3><p>将 ConfigMap 以文件形式挂载到容器内, 在数据卷里面使用ConfigMap，最基本的就是将文件填入数据卷，在这个文件中，键就是文件名【第一层级的键】，键值就是文件内容。</p>
<h4 id="3-3-1-定义资源清单"><a href="#3-3-1-定义资源清单" class="headerlink" title="3.3.1  定义资源清单"></a>3.3.1  定义资源清单</h4><p><code>pod_configmap_volumn.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">ConfigMap</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">configmap-4</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">data:</span>
  <span class="comment"># 类文件键，每个键都对应一个文件，| 下是文件的内容</span>
  <span class="attr">user.properties:</span> <span class="string">|</span>
<span class="string">    age=23</span>
<span class="string">    address=中国</span>
<span class="string"></span>  <span class="attr">game.propertie:</span> <span class="string">|</span>
<span class="string">    enemy.types=aliens,monsters</span>
<span class="string">    player.maximum-lives=5</span>
<span class="string"></span>
<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">ConfigMap</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">configmap-5</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">data:</span>
  <span class="comment"># 类属性键，每个键都映射一个简单的值</span>
  <span class="attr">username:</span> <span class="string">&quot;george&quot;</span>
  <span class="attr">password:</span> <span class="string">&quot;123456&quot;</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pod-configmap-volumn</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">spec:</span>
  <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># Pod 重启策略</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-volumn</span>
      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>
      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
      <span class="attr">command:</span> <span class="comment"># 打印完环境变量后休眠3600秒</span>
        <span class="bullet">-</span> <span class="string">&quot;/bin/sh&quot;</span>
        <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span>
        <span class="bullet">-</span> <span class="string">&quot;env &amp;&amp; sleep 3600&quot;</span>
      <span class="attr">volumeMounts:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volumn</span> <span class="comment"># 挂载的volumn名称，必须在 volumes 有定义</span>
          <span class="attr">mountPath:</span> <span class="string">/etc/config</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volumn2</span>
          <span class="attr">mountPath:</span> <span class="string">/etc/mydir</span> <span class="comment"># 挂载路径不能重复</span>
  <span class="attr">volumes:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volumn</span> <span class="comment"># volumn 名称</span>
      <span class="attr">configMap:</span>
        <span class="attr">name:</span> <span class="string">configmap-4</span> <span class="comment"># ConfigMap 名称</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volumn2</span>
      <span class="attr">configMap:</span>
        <span class="attr">name:</span> <span class="string">configmap-5</span></code></pre>



<h4 id="3-3-2-创建-ConfigMap、Pod"><a href="#3-3-2-创建-ConfigMap、Pod" class="headerlink" title="3.3.2 创建 ConfigMap、Pod"></a>3.3.2 创建 ConfigMap、Pod</h4><pre><code class="highlight bash">$ kubectl apply -f pod_configmap_volumn.yaml 
configmap/configmap-4 unchanged
configmap/configmap-5 unchanged
pod/pod-configmap-volumn created</code></pre>



<h4 id="3-3-3-进入-Pod，查看挂载文件"><a href="#3-3-3-进入-Pod，查看挂载文件" class="headerlink" title="3.3.3 进入 Pod，查看挂载文件"></a>3.3.3 进入 Pod，查看挂载文件</h4><pre><code class="highlight bash"><span class="comment"># 进入容器</span>
$ kubectl <span class="built_in">exec</span> -it pod-configmap-volumn /bin/bash

<span class="comment"># 查看挂载目录 /etc/config</span>
pod-configmap-volumn:/<span class="comment"># ls -l /etc/config</span>
total 0
lrwxrwxrwx    1 root     root            21 May 10 17:41 game.propertie -&gt; ..data/game.propertie
lrwxrwxrwx    1 root     root            22 May 10 17:41 user.properties -&gt; ..data/user.properties

<span class="comment"># 查看挂载目录 /etc/mydir</span>
pod-configmap-volumn:/<span class="comment"># ls /etc/mydir</span>
password  username

<span class="comment"># 查看文件内容</span>
pod-configmap-volumn:/etc/config<span class="comment"># cat /etc/config/user.properties </span>
age=23
address=中国

<span class="comment"># 查看文件内容</span>
pod-configmap-volumn:/etc/config<span class="comment"># cat /etc/mydir/username </span>
george</code></pre>





<h3 id="3-4-ConfigMap-热更新"><a href="#3-4-ConfigMap-热更新" class="headerlink" title="3.4 ConfigMap 热更新"></a>3.4 ConfigMap 热更新</h3><h4 id="3-4-1-创建-ConfigMap"><a href="#3-4-1-创建-ConfigMap" class="headerlink" title="3.4.1 创建 ConfigMap"></a>3.4.1 创建 ConfigMap</h4><pre><code class="highlight bash"><span class="comment"># 创建配置文件</span>
$ <span class="built_in">cat</span> default.conf 
server &#123;
    listen 80 default_server;
    server_name example.com www.example.com;
    location / &#123;
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    &#125;
&#125;

<span class="comment"># 将文件生成为 ConfigMap</span>
$ kubectl create configmap default-nginx --from-file=default.conf

<span class="comment"># 查看 configmap状态</span>
$ kubectl get cm
NAME               DATA   AGE
default-nginx      1      25s

<span class="comment"># 查看configmap 详情</span>
$ kubectl describe cm default-nginx
Name:         default-nginx
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
default.conf:
----
server &#123;\r
    listen 80 default_server;\r
    server_name example.com www.example.com;\r
    location / &#123;\r
        root   /usr/share/nginx/html;\r
        index  index.html index.htm;\r
    &#125;\r
&#125;

BinaryData
====

Events:  &lt;none&gt;</code></pre>



<h4 id="3-4-2-定义资源清单"><a href="#3-4-2-定义资源清单" class="headerlink" title="3.4.2 定义资源清单"></a>3.4.2 定义资源清单</h4><p><code>hotUpdate-nginx.yml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>
<span class="attr">kind:</span> <span class="string">Deployment</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">hotupdate-deployment</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">spec:</span>
  <span class="attr">replicas:</span> <span class="number">3</span>
  <span class="attr">selector:</span> <span class="comment"># 标签选择器</span>
    <span class="attr">matchLabels:</span>
      <span class="attr">app:</span> <span class="string">hotupdate-deploy</span>
      <span class="attr">version:</span> <span class="string">v1</span>
  <span class="attr">template:</span>
    <span class="attr">metadata:</span>
      <span class="attr">labels:</span>
        <span class="attr">app:</span> <span class="string">hotupdate-deploy</span>
        <span class="attr">version:</span> <span class="string">v1</span>
        <span class="attr">env:</span> <span class="string">test</span>
    <span class="attr">spec:</span>
      <span class="attr">containers:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>
          <span class="attr">image:</span> <span class="string">nginx:1.28.0</span>
          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
          <span class="attr">volumeMounts:</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span> <span class="comment"># 挂载的volumn名称，必须 volumes 中定义存在</span>
              <span class="attr">mountPath:</span> <span class="string">/etc/nginx/conf.d/</span>
      <span class="attr">volumes:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span> <span class="comment"># 挂在卷名称</span>
          <span class="attr">configMap:</span>
            <span class="attr">name:</span> <span class="string">default-nginx</span> <span class="comment"># 创建的configmap名称</span></code></pre>



<h4 id="3-4-3-创建容器"><a href="#3-4-3-创建容器" class="headerlink" title="3.4.3 创建容器"></a>3.4.3 创建容器</h4><pre><code class="highlight bash"><span class="comment"># 创建 Deployment</span>
$ kubectl apply -f hotUpdate-nginx.yml 
deployment.apps/hotupdate-deployment created

<span class="comment"># 查看 Deployment 状态</span>
$ kubectl get deployment -o wide
NAME                   READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES         SELECTOR
hotupdate-deployment   3/3     3            3           3m27s   nginx        nginx:1.28.0   app=hotupdate-deploy,version=v1

<span class="comment"># 查看Pod</span>
$ kubectl get pods -o wide
NAME                                   READY   STATUS    RESTARTS   AGE     IP               NODE         NOMINATED NODE   READINESS GATES
hotupdate-deployment-9ff5b5b8b-27frw   1/1     Running   0          3m46s   192.168.85.225   k8s-node01   &lt;none&gt;           &lt;none&gt;
hotupdate-deployment-9ff5b5b8b-c8k42   1/1     Running   0          3m46s   192.168.58.220   k8s-node02   &lt;none&gt;           &lt;none&gt;
hotupdate-deployment-9ff5b5b8b-cjwlh   1/1     Running   0          3m46s   192.168.58.221   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre>



<p><strong>访问pod</strong></p>
<pre><code class="highlight bash">$ curl http://192.168.85.225:80/index.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;<span class="built_in">head</span>&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
html &#123; color-scheme: light dark; &#125;
body &#123; width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; &#125;
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>Pod 可以正常访问</p>
<h4 id="3-4-4-编辑修改-ConfigMap"><a href="#3-4-4-编辑修改-ConfigMap" class="headerlink" title="3.4.4 编辑修改 ConfigMap"></a>3.4.4 编辑修改 ConfigMap</h4><pre><code class="highlight bash">$ kubectl edit configmap default-nginx

<span class="comment"># 将 default-nginx 内容的端口，从 80 改为 90，然后保存</span></code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/05/11/20250511-113403.png" alt="编辑修改 ConfigMap"></p>
<p><strong>进入 Pod 容器内，查看挂载配置文件是否修改</strong></p>
<pre><code class="highlight bash"><span class="comment"># 进入pod容器内容</span>
$ kubectl <span class="built_in">exec</span> -it hotupdate-deployment-9ff5b5b8b-27frw /bin/bash

<span class="comment"># 查看配置文件（配置已成功修改）</span>
hotupdate-deployment-747786dd9b-72wz8:/<span class="comment"># cat /etc/nginx/conf.d/default.conf </span>
server &#123;
    listen 90 default_server;
    server_name example.com www.example.com;
    location / &#123;
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    &#125;
&#125;</code></pre>



<p><strong>使用 90 端口访问 Pod</strong></p>
<pre><code class="highlight bash">$ curl http://192.168.85.225:90/index.html
curl: (7) Failed to connect to 192.168.85.225 port 90: Connection refused</code></pre>

<p>可以看到，使用 90端口访问失败，Pod依然使用的是80端口，也就是 ConfigMap 没能触发容器的热更新。</p>
<p>这里需要手动触发热更新。</p>
<h4 id="3-4-5-手动触发热更新"><a href="#3-4-5-手动触发热更新" class="headerlink" title="3.4.5 手动触发热更新"></a>3.4.5 手动触发热更新</h4><p>更新 ConfigMap 目前并不会触发相关 Pod 的滚动更新，可以通过修改 pod annotations 的方式强制触发滚动更新</p>
<pre><code class="highlight bash"><span class="comment"># 手动更新 Deployment 的 annotations 版本号，触发Deployment 滚动升级</span>
$ kubectl patch deployment hotupdate-deployment --patch <span class="string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;template&quot;: &#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;: &#123;&quot;version/config&quot;: &quot;123&quot; &#125;&#125;&#125;&#125;&#125;&#x27;</span></code></pre>



<p><strong>访问Pod</strong></p>
<pre><code class="highlight bash"><span class="comment"># 查看 滚动更新后的 Pod</span>
$ kubectl get pods -o wide
NAME                                    READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATES
hotupdate-deployment-76d6c6b684-v5wcl   1/1     Running   0          14s   192.168.58.222   k8s-node02   &lt;none&gt;           &lt;none&gt;
hotupdate-deployment-76d6c6b684-v96hq   1/1     Running   0          16s   192.168.85.226   k8s-node01   &lt;none&gt;           &lt;none&gt;
hotupdate-deployment-76d6c6b684-xgbxb   1/1     Running   0          11s   192.168.58.223   k8s-node02   &lt;none&gt;           &lt;none&gt;


<span class="comment"># 访问Pod</span>
$ curl http://192.168.85.226:90/index.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;<span class="built_in">head</span>&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
html &#123; color-scheme: light dark; &#125;
body &#123; width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; &#125;
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>



<h4 id="3-4-6-热更新注意事项"><a href="#3-4-6-热更新注意事项" class="headerlink" title="3.4.6 热更新注意事项"></a>3.4.6 热更新注意事项</h4><p>更新 ConfigMap 后：</p>
<ul>
<li>使用该 ConfigMap 挂载的 Env 不会同步更新</li>
<li>使用该 ConfigMap 挂载的 Volume 中的数据需要一段时间（实测大概10秒）才能同步更新</li>
</ul>
<h3 id="3-5-configmap-不可改变"><a href="#3-5-configmap-不可改变" class="headerlink" title="3.5 configmap-不可改变"></a>3.5 configmap-不可改变</h3><p>Kubernetes 给不可变的 ConfigMap 和 Secret 提供了一种可选配置， 可以设置各个 Secret 和 ConfigMap 为不可变的。 对于大量使用 configmap 的集群（至少有成千上万各不相同的 configmap 供 Pod 挂载）， 禁止变更它们的数据有下列好处：</p>
<ul>
<li>防止意外（或非预期的）更新导致应用程序中断</li>
<li>通过将 configmap 标记为不可变来关闭 kube-apiserver 对其的监视，从而显著降低 kube-apiserver 的负载，提升集群性能。</li>
</ul>
<pre><code class="highlight bash">$ kubectl explain configmap.immutable
KIND:       ConfigMap
VERSION:    v1

FIELD: immutable &lt;boolean&gt;

DESCRIPTION:
    Immutable, <span class="keyword">if</span> <span class="built_in">set</span> to <span class="literal">true</span>, ensures that data stored <span class="keyword">in</span> the ConfigMap cannot
    be updated (only object metadata can be modified). If not <span class="built_in">set</span> to <span class="literal">true</span>, the
    field can be modified at any time. Defaulted to nil.</code></pre>



<p><strong>添加 immutable 参数</strong></p>
<pre><code class="highlight bash">$ kubectl edit cm default-nginx -o yaml
apiVersion: v1
data:
  default.conf: <span class="string">&quot;server &#123;\r\n    listen 90 default_server;\r\n    server_name example.com</span>
<span class="string">    www.example.com;\r\n    location / &#123;\r\n        root   /usr/share/nginx/html;\r\n</span>
<span class="string">    \       index  index.html index.htm;\r\n    &#125;\r\n&#125;&quot;</span>
immutable: <span class="literal">true</span>
kind: ConfigMap
metadata:
  creationTimestamp: <span class="string">&quot;2025-05-11T13:09:40Z&quot;</span>
  name: default-nginx
  namespace: default
  resourceVersion: <span class="string">&quot;161330&quot;</span>
  uid: a75df079-ef0d-499c-9769-13bbc76606ad</code></pre>

<p>保存后，这个configmap将不能再被修改</p>
<h1 id="三、Secret"><a href="#三、Secret" class="headerlink" title="三、Secret"></a>三、Secret</h1><h2 id="1-Secret-定义"><a href="#1-Secret-定义" class="headerlink" title="1. Secret - 定义"></a>1. Secret - 定义</h2><p>Secret 对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 Pod 的定义或者 容器镜像 中来说更加安全和灵活。</p>
<h2 id="2-Secret-特性"><a href="#2-Secret-特性" class="headerlink" title="2. Secret - 特性"></a>2. Secret - 特性</h2><ul>
<li><p>Kubernetes 通过仅仅将 Secret 分发到需要访问 Secret 的 Pod 所在的机器节点来保障其安全性</p>
</li>
<li><p>Secret 只会存储在节点的内存中，永不写入物理存储，这样从节点删除 secret 时就不需要擦除磁盘数据</p>
</li>
<li><p>从 Kubernetes1.7 版本开始，etcd 会以加密形式存储 Secret，一定程度的保证了 Secret 安全性</p>
</li>
</ul>
<h2 id="3-Secret-类型"><a href="#3-Secret-类型" class="headerlink" title="3. Secret - 类型"></a>3. Secret - 类型</h2><table>
<thead>
<tr>
<th>内置类型</th>
<th>用法</th>
<th>使用示例</th>
</tr>
</thead>
<tbody><tr>
<td>Opaque</td>
<td>base64编码格式的Secret，用来存储密码、秘钥等。</td>
<td>kubectl create secret generic mysecret  –from-literal&#x3D;username&#x3D;admin  –from-literal&#x3D;password&#x3D;123456</td>
</tr>
<tr>
<td>kubernetes.io&#x2F;service-account-token</td>
<td>服务账号令牌，用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的 &#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount 目录中。</td>
<td></td>
</tr>
<tr>
<td>kubernetes.io&#x2F;dockercfg</td>
<td>~&#x2F;.dockercfg 文件序列化形式（老版本Docker），用来存储私有docker registry的认证信息。</td>
<td></td>
</tr>
<tr>
<td>kubernetes.io&#x2F;dockerconfigjson</td>
<td>~&#x2F;.docker&#x2F;config.json 文件序列化形式（新版本Docker），用来存储私有docker registry的认证信息。</td>
<td>kubectl create secret docker-registry myregistry \   –docker-server&#x3D;registry.example.com \   –docker-username&#x3D;admin \   –docker-password&#x3D;123456</td>
</tr>
<tr>
<td>kubernetes.io&#x2F;basic-auth</td>
<td>用于基本身份认证凭据</td>
<td>kubectl create secret generic my-basic-auth  –type&#x3D;kubernetes.io&#x2F;basic-auth  –from-literal&#x3D;username&#x3D;admin  –from-literal&#x3D;password&#x3D;123456</td>
</tr>
<tr>
<td>kubernetes.io&#x2F;ssh-auth</td>
<td>用户SSH身份认证凭据</td>
<td>kubectl create secret generic my-ssh  –type&#x3D;kubernetes.io&#x2F;ssh-auth  –from-file&#x3D;ssh-privatekey&#x3D;~&#x2F;.ssh&#x2F;id_rsa</td>
</tr>
<tr>
<td>kubernetes.io&#x2F;tls</td>
<td>用于TLS客户端或者服务端的数据</td>
<td>kubectl create secret tls my-tls  –cert&#x3D;.&#x2F;tls.crt  –key&#x3D;.&#x2F;tls.key</td>
</tr>
<tr>
<td>bootstrap.kubernetes.io&#x2F;token</td>
<td>启动引导令牌数据</td>
<td></td>
</tr>
</tbody></table>
<p><code>kubernetes.io/service-account-token</code> 类型创建示例</p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Secret</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">example-service-account-token</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
  <span class="attr">annotations:</span>
    <span class="attr">kubernetes.io/service-account.name:</span> <span class="string">example-service-account</span>
    <span class="attr">kubernetes.io/service-account.uid:</span> <span class="string">&quot;12345678-1234-1234-1234-1234567890ab&quot;</span>
<span class="attr">type:</span> <span class="string">kubernetes.io/service-account-token</span>
<span class="attr">data:</span>
  <span class="attr">token:</span> <span class="string">eyJhbGciOiJSUzI1NiIsImtpZCI6InRlc3Qta2V5In0...</span> <span class="comment"># Base64 encoded JWT token</span>
  <span class="attr">ca.crt:</span> <span class="string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0t...</span> <span class="comment"># Base64 encoded CA certificate</span>
  <span class="attr">namespace:</span> <span class="string">ZGVmYXVsdA==</span> <span class="comment"># Base64 encoded namespace</span></code></pre>



<p><code>bootstrap.kubernetes.io/token</code> 类型创建示例</p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Secret</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">bootstrap-token-abcdef</span>
  <span class="attr">namespace:</span> <span class="string">kube-system</span>
<span class="attr">type:</span> <span class="string">bootstrap.kubernetes.io/token</span>
<span class="attr">data:</span>
  <span class="attr">token-id:</span> <span class="string">YWJjZGVm</span> <span class="comment"># Base64 encoded &quot;abcdef&quot;</span>
  <span class="attr">token-secret:</span> <span class="string">MTIzNDU2Nzg5MGFiY2RlZg==</span> <span class="comment"># Base64 encoded &quot;1234567890abcdef&quot;</span>
  <span class="attr">usage-bootstrap-authentication:</span> <span class="string">dHJ1ZQ==</span> <span class="comment"># Base64 encoded &quot;true&quot;</span>
  <span class="attr">usage-bootstrap-signing:</span> <span class="string">dHJ1ZQ==</span> <span class="comment"># Base64 encoded &quot;true&quot;</span>
  <span class="attr">description:</span> <span class="string">dG9rZW4gZm9yIG5vZGUgYm9vdHN0cmFwcGluZw==</span> <span class="comment"># Base64 encoded &quot;token for node bootstrapping&quot;</span>
  <span class="attr">expiration:</span> <span class="string">MjAyNi0wNS0xM1QxMjowMDowMFo=</span> <span class="comment"># Base64 encoded &quot;2026-05-13T12:00:00Z&quot;</span></code></pre>





<h2 id="4-Secret-Opaque"><a href="#4-Secret-Opaque" class="headerlink" title="4. Secret-Opaque"></a>4. Secret-Opaque</h2><h3 id="4-1-Opaque-概念"><a href="#4-1-Opaque-概念" class="headerlink" title="4.1 Opaque - 概念"></a>4.1 Opaque - 概念</h3><p>当 Secret 配置文件中未作显式设定时，默认的 Secret 类型是 Opaque。 当你使用 kubectl 来创建一个 Secret 时，你会使用 generic 子命令来标明要创建的是一个 Opaque 类型 Secret。</p>
<h3 id="4-2-Opaque-创建"><a href="#4-2-Opaque-创建" class="headerlink" title="4.2 Opaque - 创建"></a>4.2 Opaque - 创建</h3><h4 id="4-2-1-手动加密，基于Base64加密"><a href="#4-2-1-手动加密，基于Base64加密" class="headerlink" title="4.2.1 手动加密，基于Base64加密"></a>4.2.1 手动加密，基于Base64加密</h4><pre><code class="highlight bash"><span class="comment"># 对用户名 admin 进行base64编码</span>
$ <span class="built_in">echo</span> -n <span class="string">&#x27;admin&#x27;</span> | <span class="built_in">base64</span>
YWRtaW4=

<span class="comment"># 对密码 abc123456 进行base64编码</span>
$ <span class="built_in">echo</span> -n <span class="string">&#x27;abc123456&#x27;</span> | <span class="built_in">base64</span>
YWJjMTIzNDU2

<span class="comment"># 对base64加密后的用户名进行解密</span>
$ <span class="built_in">echo</span> -n <span class="string">&#x27;YWRtaW4=&#x27;</span> | <span class="built_in">base64</span> -d
admin

<span class="comment"># 对base64加密后的密码进行解密</span>
$ <span class="built_in">echo</span> -n <span class="string">&#x27;YWJjMTIzNDU2&#x27;</span> | <span class="built_in">base64</span> -d
abc123456</code></pre>



<h4 id="4-2-2-使用-yml-文件创建-Opaque"><a href="#4-2-2-使用-yml-文件创建-Opaque" class="headerlink" title="4.2.2 使用 yml 文件创建 Opaque"></a>4.2.2 使用 yml 文件创建 Opaque</h4><p><code>Opaque-Secret.yml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Secret</span> <span class="comment"># 资源类型 Secret</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">mysecret</span> <span class="comment"># 自定义 Secret 名称</span>
<span class="attr">type:</span> <span class="string">Opaque</span> <span class="comment"># Secret类型指定为 Opaque</span>
<span class="attr">data:</span>
  <span class="attr">password:</span> <span class="string">YWJjMTIzNDU2</span> <span class="comment"># base64 编码后的密码</span>
  <span class="attr">username:</span> <span class="string">YWRtaW4=</span> <span class="comment"># base64编码后的用户名</span></code></pre>



<p><strong>执行文件，创建 Opaque</strong></p>
<pre><code class="highlight bash">$ kubectl get Secret mysecret -o yaml</code></pre>



<h4 id="4-2-3-使用命令行创建-Opaque"><a href="#4-2-3-使用命令行创建-Opaque" class="headerlink" title="4.2.3 使用命令行创建 Opaque"></a>4.2.3 使用命令行创建 Opaque</h4><pre><code class="highlight bash"><span class="comment"># generic的默认类型是 Opaque， </span>
<span class="comment"># username=admin 是一个键值对，Secret 会自动进行 Base64 加密</span>
$ kubectl create secret generic db-user-pass --from-literal=username=admin --from-literal=password=abc123456</code></pre>





<h3 id="4-3-查看-Opaque"><a href="#4-3-查看-Opaque" class="headerlink" title="4.3 查看 Opaque"></a>4.3 查看 Opaque</h3><pre><code class="highlight bash"><span class="comment"># 查看方式一：</span>
$ kubectl get Secret mysecret -o yaml
apiVersion: v1
data:
  password: YWJjMTIzNDU2 <span class="comment"># 显示编码后的内容</span>
  username: YWRtaW4=
kind: Secret
metadata:
  creationTimestamp: <span class="string">&quot;2025-05-13T11:30:44Z&quot;</span>
  name: mysecret
  namespace: default
  resourceVersion: <span class="string">&quot;6423295&quot;</span>
  uid: fbdb3db6-e47f-4eb2-863a-e6a8eb11c616
<span class="built_in">type</span>: Opaque

<span class="comment"># 查看方式二：</span>
$ kubectl describe Secret mysecret
Name:         mysecret
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  Opaque

Data
====
password:  9 bytes <span class="comment"># 只显示编码后的字符串的长度</span>
username:  5 bytes</code></pre>



<h3 id="4-4-Opaque-用于环境变量"><a href="#4-4-Opaque-用于环境变量" class="headerlink" title="4.4 Opaque 用于环境变量"></a>4.4 Opaque 用于环境变量</h3><p>资源清单：<code>pod-opaque-env.yml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Secret</span> <span class="comment"># 资源类型 Secret</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">mysecret</span> <span class="comment"># 自定义 Secret 名称</span>
<span class="attr">type:</span> <span class="string">Opaque</span> <span class="comment"># Secret类型指定为 Opaque</span>
<span class="attr">data:</span>
  <span class="attr">password:</span> <span class="string">YWJjMTIzNDU2</span> <span class="comment"># base64 编码后的密码</span>
  <span class="attr">username:</span> <span class="string">YWRtaW4=</span> <span class="comment"># base64编码后的用户名</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pod-opaque-env</span>
<span class="attr">spec:</span>
  <span class="attr">restartPolicy:</span> <span class="string">Never</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span>
      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>
      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
      <span class="attr">env:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SECRET_USERNAME</span> <span class="comment"># 环境变量Key</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">secretKeyRef:</span>
              <span class="attr">key:</span> <span class="string">username</span> <span class="comment"># Secret中定义的key</span>
              <span class="attr">name:</span> <span class="string">mysecret</span> <span class="comment"># Secret名称</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SECRET_PASSWORD</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">secretKeyRef:</span>
              <span class="attr">key:</span> <span class="string">password</span>
              <span class="attr">name:</span> <span class="string">mysecret</span></code></pre>



<p><strong>创建Secret 和 Pod</strong></p>
<pre><code class="highlight bash">$ kubectl apply -f pod-opaque-env.yml 
secret/mysecret created
pod/pod-opaque-env created</code></pre>



<p><strong>查看环境变量</strong></p>
<pre><code class="highlight bash"><span class="comment"># 查看Pod</span>
$ kubectl get pods -o wide
NAME             READY   STATUS    RESTARTS   AGE    IP              NODE         NOMINATED NODE   READINESS GATES
pod-opaque-env   1/1     Running   0          2m1s   172.16.58.220   k8s-node02   &lt;none&gt;           &lt;none&gt;


<span class="comment"># 进入Pod</span>
$ kubectl <span class="built_in">exec</span> -it pod-opaque-env -- /bin/bash


<span class="comment"># 查看环境变量</span>
pod-opaque-env:/<span class="comment"># env</span>
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_SERVICE_PORT=443
CHARSET=UTF-8
HOSTNAME=pod-opaque-env
PWD=/
HOME=/root
LANG=C.UTF-8
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
SECRET_USERNAME=admin <span class="comment"># 用户名被自动base64解密</span>
TERM=xterm
SHLVL=1
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
KUBERNETES_SERVICE_HOST=10.96.0.1
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP_PORT=443
LC_COLLATE=C
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
SECRET_PASSWORD=abc123456 <span class="comment"># 密码被自动 base64 解密</span>
_=/usr/bin/env</code></pre>

<p>由上可见，在pod中的secret信息实际已经被解密。</p>
<h3 id="4-4-Opaque-用于-Volume-卷"><a href="#4-4-Opaque-用于-Volume-卷" class="headerlink" title="4.4 Opaque 用于 Volume 卷"></a>4.4 Opaque 用于 Volume 卷</h3><p><code>pod-opaque-volume.yml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Secret</span> <span class="comment"># 资源类型 Secret</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">mysecret</span> <span class="comment"># 自定义 Secret 名称</span>
<span class="attr">type:</span> <span class="string">Opaque</span> <span class="comment"># Secret类型指定为 Opaque</span>
<span class="attr">data:</span>
  <span class="attr">password:</span> <span class="string">YWJjMTIzNDU2</span> <span class="comment"># base64 编码后的密码</span>
  <span class="attr">username:</span> <span class="string">YWRtaW4=</span> <span class="comment"># base64编码后的用户名</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pod-opaque-env</span>
<span class="attr">spec:</span>
  <span class="attr">restartPolicy:</span> <span class="string">Never</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span>
      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>
      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
      <span class="attr">volumeMounts:</span>
        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/secret</span> <span class="comment"># 挂载到容器内的目录</span>
          <span class="attr">name:</span> <span class="string">secret-volume</span> <span class="comment"># 挂载的 volume 名称</span>
          <span class="attr">readOnly:</span> <span class="literal">true</span> <span class="comment"># 设置容器 /etc/secret 只读</span>
  <span class="attr">volumes:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span> <span class="comment"># 生成的挂在卷名称</span>
      <span class="attr">secret:</span> <span class="comment"># 挂载 Secret</span>
        <span class="attr">secretName:</span> <span class="string">mysecret</span> <span class="comment"># Secret名称</span></code></pre>



<p><strong>创建Secret 和 Pod</strong></p>
<pre><code class="highlight bash">$ kubectl apply -f pod-opaque-volume.yml 
secret/mysecret created
pod/pod-opaque-env created</code></pre>



<p><strong>查看Pod挂载的目录</strong></p>
<pre><code class="highlight bash"><span class="comment"># 查看 Pod</span>
$ kubectl get pods
NAME             READY   STATUS    RESTARTS   AGE
pod-opaque-env   1/1     Running   0          85s

<span class="comment"># 进入 Pod 容器</span>
$ kubectl <span class="built_in">exec</span> -it pod-opaque-env -- /bin/bash

<span class="comment"># 查看挂载目录</span>
<span class="comment"># ls -l /etc/secret</span>
total 0
lrwxrwxrwx    1 root     root            15 May 13 20:07 password -&gt; ..data/password
lrwxrwxrwx    1 root     root            15 May 13 20:07 username -&gt; ..data/username

<span class="comment"># 查看username</span>
<span class="comment"># cat /etc/secret/username </span>
admin

<span class="comment"># 查看password</span>
<span class="comment"># cat /etc/secret/password</span>
abc123456</code></pre>

<p>Pod 内 Secret 自动使用 Base64 解密。</p>
<p><strong>Volume 特殊挂载方式</strong></p>
<pre><code class="highlight yaml"><span class="comment"># 方式一：设置文件权限，</span>
<span class="attr">volumes:</span>
<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volumes12</span>
  <span class="attr">secret:</span>
    <span class="attr">secretName:</span> <span class="string">mysecret</span>
    <span class="attr">defaultMode:</span> <span class="number">256</span> <span class="comment"># 256的8进制是 400， 表示挂载的文件权限为 400</span>
    
<span class="comment"># 方式二：只挂载 Secret 的部分字段，比如下面，只用了 Secret 的 username 字段</span>
<span class="attr">volumes:</span>
<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volumes12</span>
  <span class="attr">secret:</span>
    <span class="attr">secretName:</span> <span class="string">mysecret</span>
    <span class="attr">items:</span>
    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">username</span>
      <span class="attr">path:</span> <span class="string">my-group/my-username</span></code></pre>



<h3 id="4-5-Opaque-Volume-热更新"><a href="#4-5-Opaque-Volume-热更新" class="headerlink" title="4.5 Opaque - Volume - 热更新"></a>4.5 Opaque - Volume - 热更新</h3><p>当已经存储于卷中被使用的 Secret 被更新时，被映射的键也将终将被更新。 组件 kubelet 在周期性同步时检查被挂载的 Secret 是不是最新的。 但是，它会使用其本地缓存的数值作为 Secret 的当前值。使用 Secret 作为子路径卷挂载的容器不会收到 Secret 更新。</p>
<ul>
<li>当Opaque 挂载为 Volume 时支持热更新（编辑Secret 保存后，需要过大约1分钟），pod内挂载的目录内容会更新，无需手动重启Pod</li>
</ul>
<p>作为子路径挂载容器不支持热更新，示例如下：</p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">my-pod</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">spec:</span>
  <span class="attr">containers:</span>
  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-app</span>
    <span class="attr">image:</span> <span class="string">nginx</span>
    <span class="attr">volumeMounts:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span>
      <span class="attr">mountPath:</span> <span class="string">/etc/secret/username</span>
      <span class="attr">subPath:</span> <span class="string">username</span>
      <span class="attr">readOnly:</span> <span class="literal">true</span>
  <span class="attr">volumes:</span>
  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secret-volume</span>
    <span class="attr">secret:</span>
      <span class="attr">secretName:</span> <span class="string">my-secret</span></code></pre>

<p><code>subPath: username</code>，使用 subPath 只挂载 username，将不会触发热更新。</p>
<h3 id="4-6-Opaque-Volume-不可更改"><a href="#4-6-Opaque-Volume-不可更改" class="headerlink" title="4.6 Opaque - Volume - 不可更改"></a>4.6 Opaque - Volume - 不可更改</h3><p>Kubernetes 给不可变的 Secret 和 ConfigMap 提供了一种可选配置， 可以设置各个 Secret 和 ConfigMap 为不可变的。 对于大量使用 Secret 的集群（至少有成千上万各不相同的 Secret 供 Pod 挂载）， 禁止变更它们的数据有下列好处：</p>
<ul>
<li>防止意外（或非预期的）更新导致应用程序中断</li>
<li>通过将 Secret 标记为不可变来关闭 kube-apiserver 对其的监视，从而显著降低 kube-apiserver 的负载，提升集群性能</li>
</ul>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Secret</span> <span class="comment"># 资源类型 Secret</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">mysecret</span> <span class="comment"># 自定义 Secret 名称</span>
<span class="attr">type:</span> <span class="string">Opaque</span> <span class="comment"># Secret类型指定为 Opaque</span>
<span class="attr">data:</span>
  <span class="attr">password:</span> <span class="string">YWJjMTIzNDU2</span> <span class="comment"># base64 编码后的密码</span>
  <span class="attr">username:</span> <span class="string">YWRtaW4=</span> <span class="comment"># base64编码后的用户名</span>
<span class="attr">immutable:</span> <span class="literal">true</span></code></pre>





<h2 id="5-Secret-docker-registry"><a href="#5-Secret-docker-registry" class="headerlink" title="5. Secret - docker-registry"></a>5. Secret - docker-registry</h2><p>存储私有docker registry的认证信息</p>
<h3 id="5-1-搭建-Harbor-镜像仓库"><a href="#5-1-搭建-Harbor-镜像仓库" class="headerlink" title="5.1 搭建 Harbor 镜像仓库"></a>5.1 搭建 Harbor 镜像仓库</h3><p>搭建过程参考：<a target="_blank" rel="noopener" href="https://note.youdao.com/s/3YcLzcM1">Harbor企业级部署</a></p>
<p><strong>Harbor 部分配置文件信息</strong></p>
<pre><code class="highlight bash">$ vim harbor.yml

hostname: 192.168.6.201
http:
  <span class="comment"># port for http, default is 80. If https enabled, this port will redirect to https port</span>
  port: 5000

<span class="comment"># https related config</span>
https:
  <span class="comment"># https port for harbor, default is 443</span>
  <span class="comment">#port: 443</span>
  <span class="comment"># The path of cert and key files for nginx</span>
  <span class="comment">#certificate: /your/certificate/path</span>
  <span class="comment">#private_key: /your/private/key/path</span>
harbor_admin_password: Harbor12345

<span class="comment"># Harbor DB configuration</span>
database:
  password: root123
  max_idle_conns: 100
  max_open_conns: 900
  conn_max_lifetime: 5m
  conn_max_idle_time: 0

<span class="comment"># The default data volume</span>
data_volume: /data/harbor
trivy:
  <span class="comment"># ignoreUnfixed The flag to display only fixed vulnerabilities</span>
  ignore_unfixed: <span class="literal">false</span>
  skip_update: <span class="literal">false</span>
  offline_scan: <span class="literal">false</span>
  <span class="comment">#</span>
  <span class="comment"># Comma-separated list of what security issues to detect. Possible values are `vuln`, `config` and `secret`. Defaults to `vuln`.</span>
  security_check: vuln
  insecure: <span class="literal">false</span>
jobservice:
  <span class="comment"># Maximum number of job workers in job service</span>
  max_job_workers: 10

notification:
  <span class="comment"># Maximum retry count for webhook job</span>
  webhook_job_max_retry: 10

chart:
  <span class="comment"># Change the value of absolute_url to enabled can enable absolute url in chart</span>
  absolute_url: disabled

<span class="comment"># Log configurations</span>
<span class="built_in">log</span>:
  <span class="comment"># options are debug, info, warning, error, fatal</span>
  level: info
  <span class="comment"># configs for logs in local storage</span>
  <span class="built_in">local</span>:
    rotate_count: 50
    <span class="comment"># are all valid.</span>
    rotate_size: 200M
    <span class="comment"># The directory on your host that store log</span>
    location: /var/log/harbor

<span class="comment">#This attribute is for migrator to detect the version of the .cfg file, DO NOT MODIFY!</span>
_version: 2.7.0

<span class="comment"># uaa:</span>
<span class="comment">#   ca_file: /path/to/ca</span>
proxy:
  http_proxy:
  https_proxy:
  no_proxy:
  components:
    - core
    - jobservice
    - trivy

<span class="comment"># enable purge _upload directories</span>
upload_purging:
  enabled: <span class="literal">true</span>
  <span class="comment"># remove files in _upload directories which exist for a period of time, default is one week.</span>
  age: 168h
  <span class="comment"># the interval of the purge operations</span>
  interval: 24h
  dryrun: <span class="literal">false</span>
cache:
  <span class="comment"># not enabled by default</span>
  enabled: <span class="literal">false</span>
  <span class="comment"># keep cache for one day by default</span>
  expire_hours: 24</code></pre>



<h3 id="5-2-配置-Docker"><a href="#5-2-配置-Docker" class="headerlink" title="5.2 配置 Docker"></a>5.2 配置 Docker</h3><p><strong>集群内所有服务器都需要配置</strong></p>
<pre><code class="highlight bash">$ vim /etc/docker/daemon.json
&#123;
  <span class="string">&quot;log-driver&quot;</span>: <span class="string">&quot;json-file&quot;</span>,
  <span class="string">&quot;log-opts&quot;</span>: &#123;
        <span class="string">&quot;max-size&quot;</span>: <span class="string">&quot;100m&quot;</span>,
        <span class="string">&quot;max-file&quot;</span>: <span class="string">&quot;10&quot;</span>
  &#125;,
  <span class="string">&quot;data-root&quot;</span>:<span class="string">&quot;/data/docker&quot;</span>,
  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],
  <span class="string">&quot;registry-mirrors&quot;</span>: [
   <span class="string">&quot;https://kfp63jaj.mirror.aliyuncs.com&quot;</span>,
    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>,
    <span class="string">&quot;https://mirror.baidubce.com&quot;</span>
  ],
  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.6.201:5000&quot;</span>]
&#125;</code></pre>

<p><code>192.168.6.201:5000</code> 是harbor服务内网IP和端口</p>
<h3 id="5-3-创建Harbor私有仓库"><a href="#5-3-创建Harbor私有仓库" class="headerlink" title="5.3 创建Harbor私有仓库"></a>5.3 创建Harbor私有仓库</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/05/14/20250514-084700.png" alt="创建Harbor私有仓库"></p>
<p><strong>重启集群内的Docker服务</strong></p>
<p>集群内所有机器，在配置完：<code>/etc/docker/daemon.json</code> 都需要重启Docker服务才能生效</p>
<pre><code class="highlight bash">$ systemctl restart docker</code></pre>



<h3 id="5-4-上传镜像到-Harbor-私服"><a href="#5-4-上传镜像到-Harbor-私服" class="headerlink" title="5.4 上传镜像到 Harbor 私服"></a>5.4 上传镜像到 Harbor 私服</h3><pre><code class="highlight bash"><span class="comment"># 拉取镜像（需要科学上网，参考：https://georgechan95.github.io/blog/b01d5c62.html）</span>
$ docker pull wangyanglinux/myapp:v1.0

<span class="comment"># 给镜像打标签</span>
$ docker tag wangyanglinux/myapp:v1.0 192.168.6.201:5000/k8s-secret/myapp:v1

<span class="comment"># 登录Harbor</span>
$ docker login 192.168.6.201:5000 -u admin -p Harbor12345

<span class="comment"># 将镜像推送到Harbor中</span>
$ docker push 192.168.6.201:5000/k8s-secret/myapp:v1</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/05/14/20250514-090615.png" alt="上传镜像到 Harbor 私服"></p>
<p><strong>退出Harbor登录</strong></p>
<p>这里退出登录，目的是为了演示使用Secret完成Harbor登录</p>
<pre><code class="highlight bash"><span class="comment"># 退出登录 Harbor</span>
$ docker <span class="built_in">logout</span> 192.168.6.201:5000
Removing login credentials <span class="keyword">for</span> 192.168.6.201:5000

<span class="comment"># 从Harbor中拉取镜像权限异常</span>
$ docker pull 192.168.6.201:5000/k8s-secret/myapp:v1</code></pre>





<h3 id="5-5-Pod-直接拉取镜像"><a href="#5-5-Pod-直接拉取镜像" class="headerlink" title="5.5  Pod 直接拉取镜像"></a>5.5  Pod 直接拉取镜像</h3><p>资源清单：<code>pod-secret-registry.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pod-secret-registry</span>
<span class="attr">spec:</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span>
      <span class="attr">image:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.201</span><span class="string">:5000/k8s-secret/myapp:v1</span></code></pre>



<p><strong>启动Pod并查看状态</strong></p>
<pre><code class="highlight bash"><span class="comment"># 启动Pod</span>
$ kubectl apply -f pod-secret-registry.yaml 
pod/pod-secret-registry created

<span class="comment"># 查看Pod状态</span>
$ kubectl get pods
NAME                  READY   STATUS             RESTARTS   AGE
pod-secret-registry   0/1     ImagePullBackOff   0          16s

<span class="comment"># 查看Pod详情</span>
$ kubectl describe pod pod-secret-registry
Name:             pod-secret-registry
Events:
  Type     Reason     Age                 From               Message
  ----     ------     ----                ----               -------
  Normal   Scheduled  2m5s                default-scheduler  Successfully assigned default/pod-secret-registry to k8s-node02
  Normal   Pulling    43s (x4 over 2m4s)  kubelet            Pulling image <span class="string">&quot;192.168.6.201:5000/k8s-secret/myapp:v1&quot;</span>
  Warning  Failed     43s (x4 over 2m4s)  kubelet            Failed to pull image <span class="string">&quot;192.168.6.201:5000/k8s-secret/myapp:v1&quot;</span>: Error response from daemon: unauthorized: unauthorized to access repository: k8s-secret/myapp, action: pull: unauthorized to access repository: k8s-secret/myapp, action: pull
  Warning  Failed     43s (x4 over 2m4s)  kubelet            Error: ErrImagePull
  Warning  Failed     29s (x6 over 2m4s)  kubelet            Error: ImagePullBackOff
  Normal   BackOff    14s (x7 over 2m4s)  kubelet            Back-off pulling image <span class="string">&quot;192.168.6.201:5000/k8s-secret/myapp:v1&quot;</span></code></pre>

<p>镜像拉取失败，未登录Harbor私服，没有拉取权限</p>
<h3 id="5-6-Pod-通过-Secret-拉取镜像"><a href="#5-6-Pod-通过-Secret-拉取镜像" class="headerlink" title="5.6 Pod 通过 Secret 拉取镜像"></a>5.6 Pod 通过 Secret 拉取镜像</h3><p>资源清单：<code>pod-secret-registry.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Secret</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">harbor-secret</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">type:</span> <span class="string">kubernetes.io/dockerconfigjson</span>
<span class="attr">stringData:</span> <span class="comment"># stringData 会自动对内容进行base64编码，并存储在data 字段中</span>
  <span class="string">.dockerconfigjson:</span> <span class="string">|</span>
<span class="string">    &#123;</span>
<span class="string">      &quot;auths&quot;: &#123;</span>
<span class="string">        &quot;192.168.6.201:5000&quot;: &#123;</span>
<span class="string">            &quot;username&quot;: &quot;admin&quot;,</span>
<span class="string">            &quot;password&quot;: &quot;Harbor12345&quot;</span>
<span class="string">        &#125;</span>
<span class="string">      &#125;</span>
<span class="string">    &#125;</span>
<span class="string"></span>
<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pod-secret-registry</span>
<span class="attr">spec:</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span>
      <span class="attr">image:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.201</span><span class="string">:5000/k8s-secret/myapp:v1</span>
  <span class="attr">imagePullSecrets:</span> <span class="comment"># 镜像拉取密钥</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">harbor-secret</span> <span class="comment"># Secret 名称</span></code></pre>



<p><strong>补充：手动创建 kubernetes.io&#x2F;dockerconfigjson 类型的 Secret 方式</strong></p>
<pre><code class="highlight bash">kubectl create secret docker-registry harbor-secret --docker-server=<span class="string">&#x27;192.168.6.201:5000&#x27;</span> --docker-username=<span class="string">&#x27;admin&#x27;</span> --docker-password=<span class="string">&#x27;Harbor12345&#x27;</span></code></pre>



<p><strong>启动 Pod</strong></p>
<pre><code class="highlight bash">$ kubectl apply -f pod-secret-registry.yaml 
secret/harbor-secret created
pod/pod-secret-registry created</code></pre>



<p><strong>查看Secret</strong></p>
<pre><code class="highlight bash"><span class="comment"># 查看方式1</span>
$ kubectl describe secret harbor-secret
Name:         harbor-secret
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  kubernetes.io/dockerconfigjson

Data
====
.dockerconfigjson:  118 bytes


<span class="comment"># 查看方式2</span>
$ kubectl get secret harbor-secret -o yaml
apiVersion: v1
data:
  .dockerconfigjson: ewogICJhdXRocyI6IHsKICAgICIxOTIuMTY4LjYuMjAxOjUwMDAiOiB7CiAgICAgICAgInVzZXJuYW1lIjogImFkbWluIiwKICAgICAgICAicGFzc3dvcmQiOiAiSGFyYm9yMTIzNDUiCiAgICB9CiAgfQp9Cg==
kind: Secret
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      &#123;<span class="string">&quot;apiVersion&quot;</span>:<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;kind&quot;</span>:<span class="string">&quot;Secret&quot;</span>,<span class="string">&quot;metadata&quot;</span>:&#123;<span class="string">&quot;annotations&quot;</span>:&#123;&#125;,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;harbor-secret&quot;</span>,<span class="string">&quot;namespace&quot;</span>:<span class="string">&quot;default&quot;</span>&#125;,<span class="string">&quot;stringData&quot;</span>:&#123;<span class="string">&quot;.dockerconfigjson&quot;</span>:<span class="string">&quot;&#123;\n  \&quot;auths\&quot;: &#123;\n    \&quot;192.168.6.201:5000\&quot;: &#123;\n        \&quot;username\&quot;: \&quot;admin\&quot;,\n        \&quot;password\&quot;: \&quot;Harbor12345\&quot;\n    &#125;\n  &#125;\n&#125;\n&quot;</span>&#125;,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;kubernetes.io/dockerconfigjson&quot;</span>&#125;
  creationTimestamp: <span class="string">&quot;2025-05-14T01:41:01Z&quot;</span>
  name: harbor-secret
  namespace: default
  resourceVersion: <span class="string">&quot;6500261&quot;</span>
  uid: 8d70288d-5a40-413a-94dc-4dcc6e5c405e
<span class="built_in">type</span>: kubernetes.io/dockerconfigjson</code></pre>



<p><strong>查看Pod状态</strong></p>
<pre><code class="highlight bash"><span class="comment"># 查看Pod状态</span>
$ kubectl get pods -o wide
NAME                  READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES
pod-secret-registry   1/1     Running   0          20s   172.16.58.244   k8s-node02   &lt;none&gt;           &lt;none&gt;


<span class="comment"># 查看Pod详情</span>
$ kubectl describe pod pod-secret-registry
Name:             pod-secret-registry
Namespace:        default
......
Events:
  Type    Reason     Age    From               Message
  ----    ------     ----   ----               -------
  Normal  Scheduled  8m26s  default-scheduler  Successfully assigned default/pod-secret-registry to k8s-node02
  Normal  Pulling    8m26s  kubelet            Pulling image <span class="string">&quot;192.168.6.201:5000/k8s-secret/myapp:v1&quot;</span>
  Normal  Pulled     8m25s  kubelet            Successfully pulled image <span class="string">&quot;192.168.6.201:5000/k8s-secret/myapp:v1&quot;</span> <span class="keyword">in</span> 94ms (94ms including waiting)
  Normal  Created    8m25s  kubelet            Created container: myapp
  Normal  Started    8m25s  kubelet            Started container myapp</code></pre>

<p>从 Harbor 私服中成功拉取镜像并运行了容器。</p>
<h1 id="四、Downward-API"><a href="#四、Downward-API" class="headerlink" title="四、Downward API"></a>四、Downward API</h1><p>Downward API 是 Kubernetes 中的一个功能，它允许容器在运行时从 Kubernetes API 服务器获取有关它们自身的信息。这些信息可以作为容器内部的环境变量或文件注入到容器中，以便容器可以获取有关其运行环境的各种信息，如 Pod 名称、命名空间、标签等。</p>
<p>对于容器来说，有时候拥有自己的信息是很有用的，可避免与Kubernetes过度耦合。Downward API使得容器使用自己或者集群的信息，而不必通过Kubernetes客户端或API服务器。</p>
<p>举个例子：有一个现有的应用假定要用一个非常熟悉的环境变量来保存一个唯一标识。一种可能是给应用增加处理层，但这样是冗余和易出错的，而且它违反了低耦合的目标。更好的选择是使用Pod名称作为标识，把Pod名称注入这个环境变量中。</p>
<p><strong>主要作用</strong></p>
<ul>
<li>提供容器元数据</li>
<li>动态配置</li>
<li>与 Kubernetes 环境集成</li>
</ul>
<h2 id="1-将-Pod-字段应用到环境变量中"><a href="#1-将-Pod-字段应用到环境变量中" class="headerlink" title="1. 将 Pod 字段应用到环境变量中"></a>1. 将 Pod 字段应用到环境变量中</h2><h3 id="1-1-资源清单"><a href="#1-1-资源清单" class="headerlink" title="1.1 资源清单"></a>1.1 资源清单</h3><p>资源清单：<code>dapi-pod-env.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">dapi-pod-env</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">spec:</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span>
      <span class="attr">image:</span> <span class="string">busybox:latest</span>
      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>] <span class="comment"># 容器启动后，每 10秒打印一次环境变量</span>
      <span class="attr">args:</span>
        <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span>
            <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span>
            <span class="string">printenv</span> <span class="string">MY_NODE_NAME</span> <span class="string">MY_POD_NAMESPACE</span> <span class="string">MY_POD_NAME;</span>
            <span class="string">printenv</span> <span class="string">MY_POD_IP</span> <span class="string">MY_POD_SERVICE_ACCOUNT;</span>
            <span class="string">sleep</span> <span class="number">10</span><span class="string">;</span>
          <span class="string">done;</span>
      <span class="attr">env:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_NODE_NAME</span> <span class="comment"># 环境变量，获取服务器节点名称</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">fieldRef:</span>
              <span class="attr">fieldPath:</span> <span class="string">spec.nodeName</span> <span class="comment"># Pod 所在服务器节点的名称，例如：k8s-node01、k8s-node02</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_NAME</span> <span class="comment"># 环境变量，获取 Pod 名称</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">fieldRef:</span>
              <span class="attr">fieldPath:</span> <span class="string">metadata.name</span> <span class="comment"># 读取 Pod 名称属性</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_NAMESPACE</span> <span class="comment"># 环境变量，获取 POD 所在的名称空间</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">fieldRef:</span>
              <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span> <span class="comment"># 读取名称空间属性</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_IP</span> <span class="comment"># 读取Pod Ip</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">fieldRef:</span>
              <span class="attr">fieldPath:</span> <span class="string">status.podIP</span> <span class="comment"># 读取当前 Pod ip，由于IP是Pod运行后才生成的，属于状态信息，从 status 字段读取</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_POD_SERVICE_ACCOUNT</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">fieldRef:</span>
              <span class="attr">fieldPath:</span> <span class="string">spec.serviceAccountName</span> <span class="comment"># Pod 服务账户</span>
  <span class="attr">restartPolicy:</span> <span class="string">Never</span></code></pre>

<p>这个配置文件中，你可以看到五个环境变量。<code>env</code>字段是一个<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/resources-reference/v1.18/#envvar-v1-core">EnvVars</a>类型的数组。 数组中第一个元素指定<code>MY_NODE_NAME</code>这个环境变量从Pod的<code>spec.nodeName</code>字段获取变量值。同样，其它环境变量也是从Pod的字段获取它们的变量值。</p>
<h3 id="1-2-创建-Pod"><a href="#1-2-创建-Pod" class="headerlink" title="1.2 创建 Pod"></a>1.2 创建 Pod</h3><pre><code class="highlight bash">$ kubectl apply -f dapi-pod-env.yaml</code></pre>



<h3 id="1-3-查看-Pod-状态"><a href="#1-3-查看-Pod-状态" class="headerlink" title="1.3 查看 Pod 状态"></a>1.3 查看 Pod 状态</h3><pre><code class="highlight bash"><span class="comment"># 查看 Pod 状态</span>
$ kubectl get pods -o wide 
NAME           READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES
dapi-pod-env   1/1     Running   0          7s    172.16.58.205   k8s-node02   &lt;none&gt;           &lt;none&gt;

<span class="comment"># 查看 Pod 详情</span>
$ kubectl get pod dapi-pod-env -o yaml
apiVersion: v1
kind: Pod
metadata:
  ......
  name: dapi-pod-env
  namespace: default
  resourceVersion: <span class="string">&quot;6534780&quot;</span>
  uid: e8856c8b-340f-4080-823c-89c0353e05e6
spec:
  containers:
  - args:
    - <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> <span class="built_in">echo</span> -en <span class="string">&#x27;\n&#x27;</span>; <span class="built_in">printenv</span> MY_NODE_NAME MY_POD_NAMESPACE MY_POD_NAME;
      <span class="built_in">printenv</span> MY_POD_IP MY_POD_SERVICE_ACCOUNT; <span class="built_in">sleep</span> 10; <span class="keyword">done</span>;
    <span class="built_in">command</span>:
    - sh
    - -c
    <span class="built_in">env</span>:
    - name: MY_NODE_NAME
      valueFrom:
        fieldRef:
          apiVersion: v1
          fieldPath: spec.nodeName
    - name: MY_POD_NAME
      valueFrom:
        fieldRef:
          apiVersion: v1
          fieldPath: metadata.name
    - name: MY_POD_NAMESPACE
      valueFrom:
        fieldRef:
          apiVersion: v1
          fieldPath: metadata.namespace
    - name: MY_POD_IP
      valueFrom:
        fieldRef:
          apiVersion: v1
          fieldPath: status.podIP
    - name: MY_POD_SERVICE_ACCOUNT
      valueFrom:
        fieldRef:
          apiVersion: v1
          fieldPath: spec.serviceAccountName
    image: busybox:latest
    imagePullPolicy: IfNotPresent
    name: busybox-container
    ......
  dnsPolicy: ClusterFirst
  enableServiceLinks: <span class="literal">true</span>
  nodeName: k8s-node02
  ......
  serviceAccount: default
  serviceAccountName: default
  ......
  volumes:
  - name: kube-api-access-wknrw
    ......
status:
  conditions:
  - lastProbeTime: null
    ......
  containerStatuses:
  - containerID: docker://d8efb6784802d645e67bfaa2fc3708a42b06a15b2356c346786876ed9119538f
    ......
  hostIP: 192.168.6.141
  hostIPs:
  - ip: 192.168.6.141
  phase: Running
  podIP: 172.16.58.205
  podIPs:
  - ip: 172.16.58.205
  qosClass: BestEffort
  startTime: <span class="string">&quot;2025-05-14T08:03:58Z&quot;</span></code></pre>



<h3 id="1-4-查看-Pod-运行日志"><a href="#1-4-查看-Pod-运行日志" class="headerlink" title="1.4 查看 Pod 运行日志"></a>1.4 查看 Pod 运行日志</h3><pre><code class="highlight bash">$ kubectl logs -f --<span class="built_in">tail</span>=100 dapi-pod-env busybox-container
<span class="comment"># 打印结果：</span>
k8s-node02 <span class="comment"># Pod 所在服务器节点名称</span>
default <span class="comment"># Pod 所在名称空间</span>
dapi-pod-env <span class="comment"># Pod名称</span>
172.16.58.205 <span class="comment"># Pod启动后分配的IP</span>
default <span class="comment"># Pod 的服务账户</span>

k8s-node02
default
dapi-pod-env
172.16.58.205
default

......</code></pre>



<h3 id="1-5-进入Pod容器，查看环境变量"><a href="#1-5-进入Pod容器，查看环境变量" class="headerlink" title="1.5 进入Pod容器，查看环境变量"></a>1.5 进入Pod容器，查看环境变量</h3><pre><code class="highlight bash"><span class="comment"># 进入 Pod 容器</span>
$ kubectl <span class="built_in">exec</span> -it dapi-pod-env -c busybox-container -- sh

<span class="comment"># 打印环境变量</span>
/ <span class="comment"># env</span>
MY_POD_SERVICE_ACCOUNT=default
KUBERNETES_SERVICE_PORT=443
KUBERNETES_PORT=tcp://10.96.0.1:443
HOSTNAME=dapi-pod-env
SHLVL=1
HOME=/root
MY_POD_NAMESPACE=default
TERM=xterm
MY_POD_IP=172.16.58.205
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP_PROTO=tcp
MY_NODE_NAME=k8s-node02
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_SERVICE_HOST=10.96.0.1
PWD=/
MY_POD_NAME=dapi-pod-env</code></pre>



<p><strong>结论：通过 Downward API 可以将Pod的属性、状态信息设置为容器的环境变量</strong></p>
<h2 id="2-将容器字段应用到环境变量中"><a href="#2-将容器字段应用到环境变量中" class="headerlink" title="2. 将容器字段应用到环境变量中"></a>2. 将容器字段应用到环境变量中</h2><h3 id="2-1-资源清单"><a href="#2-1-资源清单" class="headerlink" title="2.1 资源清单"></a>2.1 资源清单</h3><p><code>dapi-container-env.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">dapi-container-env</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">spec:</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span>
      <span class="attr">image:</span> <span class="string">busybox:latest</span>
      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>] <span class="comment"># 容器启动后，每 10秒打印一次环境变量</span>
      <span class="attr">args:</span>
        <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span>
            <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span>
            <span class="string">printenv</span> <span class="string">MY_CPU_REQUEST</span> <span class="string">MY_CPU_LIMIT;</span>
            <span class="string">printenv</span> <span class="string">MY_MEMORY_REQUEST</span> <span class="string">MY_MEMORY_LIMIT;</span>
            <span class="string">sleep</span> <span class="number">10</span><span class="string">;</span>
          <span class="string">done;</span>
      <span class="attr">resources:</span> <span class="comment"># 定义容器使用的资源</span>
        <span class="attr">requests:</span>
          <span class="attr">memory:</span> <span class="string">&quot;32Mi&quot;</span> <span class="comment"># 请求 32 MiB 内存，保证 Pod 调度时节点有足够内存。</span>
          <span class="attr">cpu:</span> <span class="string">&quot;125m&quot;</span> <span class="comment"># 请求 125 毫核（0.125 CPU 核心），保证 CPU 资源</span>
        <span class="attr">limits:</span>
          <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span> <span class="comment"># 限制内存使用不超过 64 MiB，防止过度消耗</span>
          <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span> <span class="comment"># 限制 CPU 使用不超过 250 毫核（0.25 核心）</span>
      <span class="attr">env:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_CPU_REQUEST</span> <span class="comment"># 容器请求的CPU资源大小</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">resourceFieldRef:</span>
              <span class="attr">containerName:</span> <span class="string">busybox-container</span> <span class="comment"># 指定容器</span>
              <span class="attr">resource:</span> <span class="string">requests.cpu</span>
              <span class="attr">divisor:</span> <span class="string">1m</span> <span class="comment"># 指定资源值的单位转换因子，用于将 Kubernetes 内部的资源值（如 CPU 或内存）转换为用户期望的单位，并在注入到文件或环境变量时以该单位表示。支持如 1、1m（毫）、1Mi（Mebibyte）、1k（千）等单位</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_CPU_LIMIT</span> <span class="comment"># 容器请求的CPU资源上限</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">resourceFieldRef:</span>
              <span class="attr">containerName:</span> <span class="string">busybox-container</span>
              <span class="attr">resource:</span> <span class="string">limits.cpu</span>
              <span class="attr">divisor:</span> <span class="string">1m</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_MEMORY_REQUEST</span> <span class="comment"># 容器请求的内存资源大小</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">resourceFieldRef:</span>
              <span class="attr">containerName:</span> <span class="string">busybox-container</span>
              <span class="attr">resource:</span> <span class="string">requests.memory</span>
              <span class="attr">divisor:</span> <span class="string">1Mi</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_MEMORY_LIMIT</span> <span class="comment"># 容器请求的内存资源上限</span>
          <span class="attr">valueFrom:</span>
            <span class="attr">resourceFieldRef:</span>
              <span class="attr">containerName:</span> <span class="string">busybox-container</span>
              <span class="attr">resource:</span> <span class="string">limits.memory</span>
              <span class="attr">divisor:</span> <span class="string">1Mi</span>
  <span class="attr">restartPolicy:</span> <span class="string">Never</span></code></pre>

<p>这个配置文件中，你可以看到四个环境变量。<code>env</code>字段是一个 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/resources-reference/v1.18/#envvar-v1-core">EnvVars</a> 类型的数组。数组中第一个元素指定<code>MY_CPU_REQUEST</code>这个环境变量从容器的<code>requests.cpu</code>字段获取变量值。同样，其它环境变量也是从容器的字段获取它们的变量值。</p>
<h3 id="2-2-创建-Pod"><a href="#2-2-创建-Pod" class="headerlink" title="2.2 创建 Pod"></a>2.2 创建 Pod</h3><pre><code class="highlight bash">$ kubectl apply -f dapi-container-env.yaml</code></pre>



<h3 id="2-3-查看-Pod-状态"><a href="#2-3-查看-Pod-状态" class="headerlink" title="2.3 查看 Pod 状态"></a>2.3 查看 Pod 状态</h3><pre><code class="highlight bash">$ kubectl get pods -o wide
NAME                 READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES
dapi-container-env   1/1     Running   0          11s   172.16.58.241   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre>



<h3 id="2-4-查看-Pod-运行日志"><a href="#2-4-查看-Pod-运行日志" class="headerlink" title="2.4 查看 Pod 运行日志"></a>2.4 查看 Pod 运行日志</h3><pre><code class="highlight bash">$ kubectl logs -f --<span class="built_in">tail</span>=100 dapi-container-env 

125
250
32
64

125
250
32
64</code></pre>

<p>注意，<code>divisor</code> 显式指定 CPU 和内存的单位，如果不添加此参数，日志显示会有异常。</p>
<h3 id="2-5-进入-Pod容器，查看环境变量"><a href="#2-5-进入-Pod容器，查看环境变量" class="headerlink" title="2.5 进入 Pod容器，查看环境变量"></a>2.5 进入 Pod容器，查看环境变量</h3><pre><code class="highlight bash">$ kubectl <span class="built_in">exec</span> -it dapi-container-env -c busybox-container -- <span class="built_in">env</span>
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=dapi-container-env
TERM=xterm
MY_CPU_REQUEST=125
MY_CPU_LIMIT=250
MY_MEMORY_REQUEST=32
MY_MEMORY_LIMIT=64
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
KUBERNETES_SERVICE_HOST=10.96.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP_PROTO=tcp
HOME=/root</code></pre>





<h2 id="3-挂载-Pod-字段到-Volume"><a href="#3-挂载-Pod-字段到-Volume" class="headerlink" title="3. 挂载 Pod 字段到 Volume"></a>3. 挂载 Pod 字段到 Volume</h2><h3 id="3-1-资源清单"><a href="#3-1-资源清单" class="headerlink" title="3.1 资源清单"></a>3.1 资源清单</h3><p><code>dapi-pod-volume.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">dapi-pod-volume</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
  <span class="attr">labels:</span>
    <span class="attr">zone:</span> <span class="string">us-est-coast</span>
    <span class="attr">cluster:</span> <span class="string">test-cluster1</span>
    <span class="attr">env:</span> <span class="string">test</span>
  <span class="attr">annotations:</span>
    <span class="attr">build:</span> <span class="string">two</span>
    <span class="attr">builder:</span> <span class="string">George</span>
<span class="attr">spec:</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span>
      <span class="attr">image:</span> <span class="string">busybox:latest</span>
      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
      <span class="attr">command:</span> [ <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span> ] <span class="comment"># 容器启动后，每 10秒打印一次环境变量</span>
      <span class="attr">args:</span>
        <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span>
            <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/podinfo/labels</span> ]]<span class="string">;</span> <span class="string">then</span>
              <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/labels;</span> <span class="string">fi;</span>
            <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/podinfo/annotations</span> ]]<span class="string">;</span> <span class="string">then</span>
              <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/annotations;</span> <span class="string">fi;</span>
            <span class="string">sleep</span> <span class="number">5</span><span class="string">;</span>
          <span class="string">done;</span>
      <span class="attr">volumeMounts:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podinfo</span>
          <span class="attr">mountPath:</span> <span class="string">/etc/podinfo</span>
  <span class="attr">volumes:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podinfo</span>
      <span class="attr">downwardAPI:</span>
        <span class="attr">items:</span>
          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;labels&quot;</span>
            <span class="attr">fieldRef:</span>
              <span class="attr">fieldPath:</span> <span class="string">metadata.labels</span>
          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;annotations&quot;</span>
            <span class="attr">fieldRef:</span>
              <span class="attr">fieldPath:</span> <span class="string">metadata.annotations</span></code></pre>

<p>Pod有一个<code>downwardAPI</code>类型的Volume，并且挂载到容器中的<code>/etc/podinfo</code> 目录下</p>
<p>查看<code>downwardAPI</code>下面的<code>items</code>数组。每个数组元素都是一个 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/resources-reference/v1.18/#downwardapivolumefile-v1-core">DownwardAPIVolumeFile</a>。 第一个元素指示Pod的<code>metadata.labels</code>字段的值保存在名为<code>labels</code>的文件中。 第二个元素指示Pod的<code>annotations</code>字段的值保存在名为<code>annotations</code>的文件中。</p>
<h3 id="3-2-创建-Pod"><a href="#3-2-创建-Pod" class="headerlink" title="3.2 创建 Pod"></a>3.2 创建 Pod</h3><pre><code class="highlight bash">$ kubectl apply -f dapi-pod-volume.yaml</code></pre>



<h3 id="3-3-查看-Pod-状态"><a href="#3-3-查看-Pod-状态" class="headerlink" title="3.3 查看 Pod 状态"></a>3.3 查看 Pod 状态</h3><pre><code class="highlight bash">$ kubectl get pods
NAME              READY   STATUS    RESTARTS   AGE
dapi-pod-volume   1/1     Running   0          59s</code></pre>



<h3 id="3-4-查看-Pod-挂载目录"><a href="#3-4-查看-Pod-挂载目录" class="headerlink" title="3.4 查看 Pod 挂载目录"></a>3.4 查看 Pod 挂载目录</h3><pre><code class="highlight bash"><span class="comment"># 进入Pod容器</span>
$ kubectl <span class="built_in">exec</span> -it dapi-pod-volume -- sh

<span class="comment"># 进入挂载目录</span>
/ <span class="comment"># cd /etc/podinfo/</span>

<span class="comment"># 挂载目录下有两个文件，正是 volume 挂载的路径</span>
/etc/podinfo <span class="comment"># ls</span>
annotations  labels

<span class="comment"># 查看 labes 文件</span>
/etc/podinfo <span class="comment"># cat labels </span>
cluster=<span class="string">&quot;test-cluster1&quot;</span>
<span class="built_in">env</span>=<span class="string">&quot;test&quot;</span>

<span class="comment"># 查看 annotations 文件</span>
/etc/podinfo <span class="comment"># cat annotations</span>
build=<span class="string">&quot;two&quot;</span>
builder=<span class="string">&quot;George&quot;</span>
cni.projectcalico.org/containerID=<span class="string">&quot;31eef5f93dca9ee1b124d4974e8522c31d291fabf43178009b9c4ccb8fb2ebd6&quot;</span>
cni.projectcalico.org/podIP=<span class="string">&quot;172.16.58.255/32&quot;</span>
cni.projectcalico.org/podIPs=<span class="string">&quot;172.16.58.255/32&quot;</span>
kubectl.kubernetes.io/last-applied-configuration=<span class="string">&quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;kind\&quot;:\&quot;Pod\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;\&quot;build\&quot;:\&quot;two\&quot;,\&quot;builder\&quot;:\&quot;George\&quot;&#125;,\&quot;labels\&quot;:&#123;\&quot;cluster\&quot;:\&quot;test-cluster1\&quot;,\&quot;env\&quot;:\&quot;test\&quot;,\&quot;zone\&quot;:\&quot;us-est-coast\&quot;&#125;,\&quot;name\&quot;:\&quot;dapi-pod-volume\&quot;,\&quot;namespace\&quot;:\&quot;default\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;containers\&quot;:[&#123;\&quot;args\&quot;:[\&quot;while true; do if [[ -e /etc/podinfo/labels ]]; then echo -en &#x27;\\\\n\\\\n&#x27;; cat /etc/podinfo/labels; fi; if [[ -e /etc/podinfo/annotations ]]; then echo -en &#x27;\\\\n\\\\n&#x27;; cat /etc/podinfo/annotations; fi; sleep 5; done;\&quot;],\&quot;command\&quot;:[\&quot;sh\&quot;,\&quot;-c\&quot;],\&quot;image\&quot;:\&quot;busybox:latest\&quot;,\&quot;imagePullPolicy\&quot;:\&quot;IfNotPresent\&quot;,\&quot;name\&quot;:\&quot;busybox-container\&quot;,\&quot;volumeMounts\&quot;:[&#123;\&quot;mountPath\&quot;:\&quot;/etc/podinfo\&quot;,\&quot;name\&quot;:\&quot;podinfo\&quot;&#125;]&#125;],\&quot;volumes\&quot;:[&#123;\&quot;downwardAPI\&quot;:&#123;\&quot;items\&quot;:[&#123;\&quot;fieldRef\&quot;:&#123;\&quot;fieldPath\&quot;:\&quot;metadata.labels\&quot;&#125;,\&quot;path\&quot;:\&quot;labels\&quot;&#125;,&#123;\&quot;fieldRef\&quot;:&#123;\&quot;fieldPath\&quot;:\&quot;metadata.annotations\&quot;&#125;,\&quot;path\&quot;:\&quot;annotations\&quot;&#125;]&#125;,\&quot;name\&quot;:\&quot;podinfo\&quot;&#125;]&#125;&#125;\n&quot;</span>
kubernetes.io/config.seen=<span class="string">&quot;2025-05-15T09:15:54.979291949+08:00&quot;</span>
kubernetes.io/config.source=<span class="string">&quot;api&quot;</span>/etc/podinfo <span class="comment">#</span></code></pre>

<p>​	</p>
<p><strong>查看<code>/etc</code>目录下的文件：</strong></p>
<pre><code class="highlight plaintext">ls -laR /etc
/etc:
total 32
drwxrwxrwt    3 root     root           120 May 15 01:15 podinfo
-rw-r--r--    1 root     root           103 May 15 01:15 resolv.conf
-rw-------    1 root     root           136 Sep 26  2024 shadow

/etc/podinfo:
drwxr-xr-x    2 root     root            80 May 15 01:15 ..2025_05_15_01_15_56.854842629
lrwxrwxrwx    1 root     root            31 May 15 01:15 ..data -&gt; ..2025_05_15_01_15_56.854842629
lrwxrwxrwx    1 root     root            18 May 15 01:15 annotations -&gt; ..data/annotations
lrwxrwxrwx    1 root     root            13 May 15 01:15 labels -&gt; ..data/labels

/etc/podinfo/..2025_05_15_01_15_56.854842629:
-rw-r--r--    1 root     root          1313 May 15 01:15 annotations
-rw-r--r--    1 root     root            54 May 15 01:15 labels</code></pre>

<p>在输出中可以看到，<code>labels</code> 和 <code>annotations</code>文件都在一个临时子目录中：这个例子，<code>..2025_05_15_01_15_56.854842629</code>。在<code>/etc</code>目录中，<code>..data</code>是一个指向临时子目录 的符号链接。<code>/etc</code>目录中，<code>labels</code> 和 <code>annotations</code>也是符号链接。</p>
<p>用符号链接可实现元数据的动态原子刷新；更新将写入一个新的临时目录，然后<code>..data</code>符号链接完成原子更新，通过使用<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/rename.2.html">rename(2)</a>。</p>
<p><strong>查看临时子目录</strong></p>
<pre><code class="highlight bash"><span class="built_in">cat</span> /etc/podinfo/..2025_05_15_01_15_56.854842629/labels 
<span class="comment"># 内容如下：</span>
cluster=<span class="string">&quot;test-cluster1&quot;</span>
<span class="built_in">env</span>=<span class="string">&quot;test&quot;</span></code></pre>





<h2 id="4-挂载容器字段到-Volume"><a href="#4-挂载容器字段到-Volume" class="headerlink" title="4. 挂载容器字段到 Volume"></a>4. 挂载容器字段到 Volume</h2><h3 id="4-1-资源清单"><a href="#4-1-资源清单" class="headerlink" title="4.1 资源清单"></a>4.1 资源清单</h3><p><code>dapi-container-volume.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">dapi-container-volume</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">spec:</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span>
      <span class="attr">image:</span> <span class="string">busybox:latest</span>
      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>] <span class="comment"># 容器启动后，每 10秒打印一次环境变量</span>
      <span class="attr">args:</span>
        <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span>
            <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span>
            <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/container/cpu_limit</span> ]]<span class="string">;</span> <span class="string">then</span>
              <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/container/cpu_limit;</span> <span class="string">fi;</span>
            <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/container/cpu_request</span> ]]<span class="string">;</span> <span class="string">then</span>
              <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/container/cpu_request;</span> <span class="string">fi;</span>
            <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/container/memory_limit</span> ]]<span class="string">;</span> <span class="string">then</span>
              <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/container/memory_limit;</span> <span class="string">fi;</span>
            <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/container/memory_request</span> ]]<span class="string">;</span> <span class="string">then</span>
              <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/container/memory_request;</span> <span class="string">fi;</span>
            <span class="string">sleep</span> <span class="number">5</span><span class="string">;</span>
          <span class="string">done;</span>
      <span class="attr">resources:</span> <span class="comment"># 定义容器使用的资源</span>
        <span class="attr">requests:</span>
          <span class="attr">memory:</span> <span class="string">&quot;32Mi&quot;</span> <span class="comment"># 请求 32 MiB 内存，保证 Pod 调度时节点有足够内存。</span>
          <span class="attr">cpu:</span> <span class="string">&quot;125m&quot;</span> <span class="comment"># 请求 125 毫核（0.125 CPU 核心），保证 CPU 资源</span>
        <span class="attr">limits:</span>
          <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span> <span class="comment"># 限制内存使用不超过 64 MiB，防止过度消耗</span>
          <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span> <span class="comment"># 限制 CPU 使用不超过 250 毫核（0.25 核心）</span>
      <span class="attr">volumeMounts:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">container-volume</span>
          <span class="attr">mountPath:</span> <span class="string">/etc/container</span>
  <span class="attr">volumes:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">container-volume</span>
      <span class="attr">downwardAPI:</span>
        <span class="attr">items:</span>
          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;cpu_request&quot;</span>
            <span class="attr">resourceFieldRef:</span>
              <span class="attr">containerName:</span> <span class="string">busybox-container</span>
              <span class="attr">resource:</span> <span class="string">requests.cpu</span>
              <span class="attr">divisor:</span> <span class="string">1m</span> <span class="comment"># 指定资源值的单位转换因子，用于将 Kubernetes 内部的资源值（如 CPU 或内存）转换为用户期望的单位，并在注入到文件或环境变量时以该单位表示。支持如 1、1m（毫）、1Mi（Mebibyte）、1k（千）等单位</span>
          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;cpu_limit&quot;</span>
            <span class="attr">resourceFieldRef:</span>
              <span class="attr">containerName:</span> <span class="string">busybox-container</span>
              <span class="attr">resource:</span> <span class="string">limits.cpu</span>
              <span class="attr">divisor:</span> <span class="string">1m</span>
          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;memory_request&quot;</span>
            <span class="attr">resourceFieldRef:</span>
              <span class="attr">containerName:</span> <span class="string">busybox-container</span>
              <span class="attr">resource:</span> <span class="string">requests.memory</span>
              <span class="attr">divisor:</span> <span class="string">1Mi</span>
          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;memory_limit&quot;</span>
            <span class="attr">resourceFieldRef:</span>
              <span class="attr">containerName:</span> <span class="string">busybox-container</span>
              <span class="attr">resource:</span> <span class="string">limits.memory</span>
              <span class="attr">divisor:</span> <span class="string">1Mi</span>
  <span class="attr">restartPolicy:</span> <span class="string">Never</span></code></pre>



<h3 id="4-2-创建-Pod"><a href="#4-2-创建-Pod" class="headerlink" title="4.2 创建 Pod"></a>4.2 创建 Pod</h3><pre><code class="highlight bash">$ kubectl apply -f dapi-container-volume.yaml</code></pre>



<h3 id="4-3-查看-Pod-状态"><a href="#4-3-查看-Pod-状态" class="headerlink" title="4.3 查看 Pod 状态"></a>4.3 查看 Pod 状态</h3><pre><code class="highlight bash">$ kubectl get pods
NAME                    READY   STATUS    RESTARTS   AGE
dapi-container-volume   1/1     Running   0          4s</code></pre>



<h3 id="4-4-查看-Pod-日志"><a href="#4-4-查看-Pod-日志" class="headerlink" title="4.4 查看 Pod 日志"></a>4.4 查看 Pod 日志</h3><pre><code class="highlight bash">$ kubectl logs -f --<span class="built_in">tail</span>=100 dapi-container-volume

250 <span class="comment"># limits.cpu</span>
125 <span class="comment"># requests.cpu</span>
64  <span class="comment"># limits.memory</span>
32  <span class="comment"># requests.memory</span>

250
125
64
32</code></pre>



<h3 id="4-5-进入-Pod-目录，查看挂载文件"><a href="#4-5-进入-Pod-目录，查看挂载文件" class="headerlink" title="4.5 进入 Pod 目录，查看挂载文件"></a>4.5 进入 Pod 目录，查看挂载文件</h3><pre><code class="highlight bash"><span class="comment"># 进入 Pod 容器</span>
$ kubectl <span class="built_in">exec</span> -it dapi-container-volume -- sh
/ 

<span class="comment"># 进入就挂载目录</span>
<span class="comment"># cd /etc/container/</span>

<span class="comment"># 查看挂载文件</span>
/etc/container <span class="comment"># ls</span>
cpu_limit       cpu_request     memory_limit    memory_request

<span class="comment"># 查看 cpu_limit </span>
/etc/container <span class="comment"># cat cpu_limit </span>
250</code></pre>



<h2 id="5-Downward-API-常用属性"><a href="#5-Downward-API-常用属性" class="headerlink" title="5. Downward API 常用属性"></a>5. Downward API 常用属性</h2><p>下面这些信息可以通过环境变量和DownwardAPIVolumeFiles提供给容器：</p>
<p><strong>能通过<code>fieldRef</code>获得的：</strong></p>
<ul>
<li><code>metadata.name</code> - Pod名称</li>
<li><code>metadata.namespace</code> - Pod名字空间</li>
<li><code>metadata.uid</code> - Pod的UID, 版本要求 v1.8.0-alpha.2</li>
<li><code>metadata.labels[&#39;&lt;KEY&gt;&#39;]</code> - 单个 pod 标签值 <code>&lt;KEY&gt;</code> (例如, <code>metadata.labels[&#39;mylabel&#39;]</code>); 版本要求 Kubernetes 1.9+</li>
<li><code>metadata.annotations[&#39;&lt;KEY&gt;&#39;]</code> - 单个 pod 的标注值 <code>&lt;KEY&gt;</code> (例如, <code>metadata.annotations[&#39;myannotation&#39;]</code>); 版本要求 Kubernetes 1.9+</li>
<li><code>status.podIP</code> - 节点IP</li>
<li><code>spec.serviceAccountName</code> - Pod服务帐号名称, 版本要求 v1.4.0-alpha.3</li>
<li><code>spec.nodeName</code> - 节点名称, 版本要求 v1.4.0-alpha.3</li>
<li><code>status.hostIP</code> - 节点IP, 版本要求 v1.7.0-alpha.1</li>
</ul>
<p><em>说明： 如果容器未指定CPU和memory limits，则Downward API默认为节点可分配值。</em></p>
<p><strong>能通过<code>resourceFieldRef</code>获得的：</strong></p>
<ul>
<li>容器的CPU约束值</li>
<li>容器的CPU请求值</li>
<li>容器的内存约束值</li>
<li>容器的内存请求值</li>
<li>容器的临时存储约束值, 版本要求 v1.8.0-beta.0</li>
<li>容器的临时存储请求值, 版本要求 v1.8.0-beta.0</li>
</ul>
<h2 id="6-volume-相较于-env-优势"><a href="#6-volume-相较于-env-优势" class="headerlink" title="6. volume 相较于 env 优势"></a>6. volume 相较于 env 优势</h2><ul>
<li>会保持热更新的特性</li>
<li>传递一个容器的资源字段到另一个容器中</li>
</ul>
<h1 id="五、Volume"><a href="#五、Volume" class="headerlink" title="五、Volume"></a>五、Volume</h1><h2 id="1-Volume概述"><a href="#1-Volume概述" class="headerlink" title="1. Volume概述"></a>1. Volume概述</h2><p>在容器中的文件在磁盘上是临时存放的，当容器关闭时这些临时文件也会被一并清除。这给容器中运行的特殊应用程序带来一些问题。首先，当容器崩溃时，kubelet 将重新启动容器，容器中的文件将会丢失——因为容器会以干净的状态重建。其次，当在一个 Pod 中同时运行多个容器时，常常需要在这些容器之间共享文件。</p>
<p>Kubernetes 抽象出 Volume 对象来解决这两个问题。</p>
<p>Kubernetes <strong>Volume卷具有明确的生命周期——与包裹它的 Pod 相同</strong>。 因此，Volume比 Pod 中运行的任何容器的存活期都长，在容器重新启动时数据也会得到保留。 当然，<strong>当一个 Pod 不再存在时，Volume也将不再存在</strong>。更重要的是，Kubernetes 可以支持许多类型的Volume卷，Pod 也能同时使用任意数量的Volume卷。</p>
<p>使用卷时，Pod 声明中需要提供卷的类型 (.spec.volumes 字段)和卷挂载的位置 (.spec.containers.volumeMounts 字段).</p>
<h2 id="2-Volume类型"><a href="#2-Volume类型" class="headerlink" title="2. Volume类型"></a>2. Volume类型</h2><p>Kubernetes 支持下列类型的卷：</p>
<ul>
<li>awsElasticBlockStore</li>
<li>azureDisk</li>
<li>azureFile</li>
<li>cephfs</li>
<li>cinder</li>
<li>configMap</li>
<li>csi</li>
<li>downwardAPI</li>
<li>emptyDir</li>
<li>fc (fibre channel)</li>
<li>flexVolume</li>
<li>flocker</li>
<li>gcePersistentDisk</li>
<li>gitRepo (deprecated)</li>
<li>glusterfs</li>
<li>hostPath</li>
<li>iscsi</li>
<li>local</li>
<li>nfs</li>
<li>persistentVolumeClaim</li>
<li>projected</li>
<li>portworxVolume</li>
<li>quobyte</li>
<li>rbd</li>
<li>scaleIO</li>
<li>secret</li>
<li>storageos</li>
<li>vsphereVolume</li>
</ul>
<p>其中 Secret、ConfigMap 前面已经介绍过了，这里再介绍三种，分别是：emptyDir、hostPath、nfs</p>
<h2 id="3-EmptyDir-卷"><a href="#3-EmptyDir-卷" class="headerlink" title="3. EmptyDir 卷"></a>3. EmptyDir 卷</h2><p>当 Pod 指定到某个节点上时，首先创建的是一个 emptyDir 卷，并且只要 Pod 在该节点上运行，卷就一直存在。就像它的名称表示的那样，卷最初是空的。</p>
<p>尽管 <strong>Pod 中每个容器挂载 emptyDir 卷的路径可能相同也可能不同，但是这些容器都可以读写 emptyDir 卷中相同的文件</strong>。</p>
<p>如果Pod中有多个容器，其中某个容器重启，不会影响emptyDir 卷中的数据。当 Pod 因为某些原因被删除时，emptyDir 卷中的数据也会永久删除。</p>
<p><strong>注意：容器崩溃并不会导致 Pod 被从节点上移除，因此容器崩溃时 emptyDir 卷中的数据是安全的。</strong></p>
<h3 id="3-1-emptyDir的一些用途"><a href="#3-1-emptyDir的一些用途" class="headerlink" title="3.1 emptyDir的一些用途"></a>3.1 emptyDir的一些用途</h3><ul>
<li>缓存空间，例如基于磁盘的归并排序</li>
<li>为耗时较长的计算任务提供检查点，以便任务能方便地从崩溃前状态恢复执行</li>
<li>在 Web 服务器容器服务数据时，保存内容管理器容器获取的文件</li>
</ul>
<h3 id="3-2-emptyDir-使用案例"><a href="#3-2-emptyDir-使用案例" class="headerlink" title="3.2 emptyDir 使用案例"></a>3.2 emptyDir 使用案例</h3><h4 id="3-2-1-资源清单"><a href="#3-2-1-资源清单" class="headerlink" title="3.2.1 资源清单"></a>3.2.1 资源清单</h4><p><code>001-volume-emptydir-01.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>
<span class="attr">kind:</span> <span class="string">Deployment</span>
<span class="attr">metadata:</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
  <span class="attr">name:</span> <span class="string">emptydir-deployment</span>
  <span class="attr">labels:</span>
    <span class="attr">name:</span> <span class="string">volumn-dep</span>
<span class="attr">spec:</span>
  <span class="attr">replicas:</span> <span class="number">1</span>
  <span class="attr">selector:</span>
    <span class="attr">matchLabels:</span> <span class="comment"># Deployment控制器管理具有如下标签的Pod</span>
      <span class="attr">type:</span> <span class="string">emptydir</span>
  <span class="attr">template:</span>
    <span class="attr">metadata:</span>
      <span class="attr">labels:</span> <span class="comment"># Pod模板设定生成的Pod有这些标签项</span>
        <span class="attr">app:</span> <span class="string">myapp</span>
        <span class="attr">type:</span> <span class="string">emptydir</span>
    <span class="attr">spec:</span>
      <span class="attr">containers:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span> <span class="comment"># Pod1，nginx</span>
          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>
          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
          <span class="attr">ports:</span>
            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>
          <span class="attr">volumeMounts:</span> <span class="comment"># 设置 pod 挂载的容器卷</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-volume</span>
              <span class="attr">mountPath:</span> <span class="string">/usr/local/nginx/logs</span> <span class="comment"># 镜像日志输出目录，必须存在</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span> <span class="comment"># Pod2，busybox</span>
          <span class="attr">image:</span> <span class="string">busybox:latest</span>
          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
          <span class="attr">volumeMounts:</span> <span class="comment"># 设置 pod 挂载的容器卷</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-volume</span>
              <span class="attr">mountPath:</span> <span class="string">/logs</span>
          <span class="attr">command:</span>
            <span class="bullet">-</span> <span class="string">&#x27;/bin/sh&#x27;</span>
            <span class="bullet">-</span> <span class="string">&#x27;-c&#x27;</span>
            <span class="bullet">-</span> <span class="string">&#x27;tail -f /logs/access.log&#x27;</span>
      <span class="attr">volumes:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-volume</span> <span class="comment"># 设置自定义容器卷的名称</span>
          <span class="attr">emptyDir:</span> &#123;&#125; <span class="comment"># 容器卷类型：emptyDir</span></code></pre>



<h4 id="3-2-2-创建-Deployment"><a href="#3-2-2-创建-Deployment" class="headerlink" title="3.2.2 创建 Deployment"></a>3.2.2 创建 Deployment</h4><pre><code class="highlight bash"><span class="comment"># 使用资源清单创建 Deployment</span>
$ kubectl apply -f 001-volume-emptydir-01.yaml

<span class="comment"># 查看 Pod</span>
$ kubectl get pods -o wide 
NAME                                   READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES
emptydir-deployment-6cf749f46f-fb8ww   2/2     Running   0          6s    172.16.58.197   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre>

<p>成功创建Pod，两个容器已就绪。</p>
<p>**访问 nginx-container **</p>
<pre><code class="highlight bash">$ curl 172.16.58.197
www.xinxianghf.com | hello MyAPP | version v1.0</code></pre>



<h4 id="3-2-3-查看-Pod-详情"><a href="#3-2-3-查看-Pod-详情" class="headerlink" title="3.2.3 查看 Pod 详情"></a>3.2.3 查看 Pod 详情</h4><pre><code class="highlight bash">$ kubectl describe pod emptydir-deployment-6cf749f46f-fb8ww
Name:             emptydir-deployment-6cf749f46f-fb8ww
Namespace:        default
Containers:
  nginx-container:
    Container ID:   docker://56c2112d34006320b474374d8e385c61b9d4a0402d1d5ad89d83d83d5a256ba0
	......
    Mounts:
      /usr/local/nginx/logs from log-volume (rw)
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-lp4hs (ro)
  busybox-container:
    Container ID:  docker://7f0a784a4e5cd47cc1efe0bc16749e29b38bfababa33f6be3cbda676d38f53c8
    Command:
      /bin/sh
      -c
      <span class="built_in">tail</span> -f /logs/access.log
    ......
    Mounts:
      /logs from log-volume (rw)
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-lp4hs (ro)</code></pre>

<p>两个容器内不同的目录挂载了同一个 Volume （log-volume）</p>
<h4 id="3-2-4-进入-nginx-container-容器查看日志"><a href="#3-2-4-进入-nginx-container-容器查看日志" class="headerlink" title="3.2.4 进入 nginx-container 容器查看日志"></a>3.2.4 进入 nginx-container 容器查看日志</h4><pre><code class="highlight bash">$ kubectl <span class="built_in">exec</span> -it emptydir-deployment-6cf749f46f-fb8ww -c nginx-container -- <span class="built_in">tail</span> -f /usr/local/nginx/logs/access.log
172.16.167.128 - - [15/May/2025:15:00:13 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span>
172.16.167.128 - - [15/May/2025:15:01:50 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span></code></pre>



<h4 id="3-2-5-进入-busybox-container-容器查看日志"><a href="#3-2-5-进入-busybox-container-容器查看日志" class="headerlink" title="3.2.5 进入 busybox-container 容器查看日志"></a>3.2.5 进入 busybox-container 容器查看日志</h4><pre><code class="highlight bash">$ kubectl <span class="built_in">exec</span> -it emptydir-deployment-6cf749f46f-fb8ww -c busybox-container -- <span class="built_in">tail</span> -f /logs/access.log
172.16.167.128 - - [15/May/2025:15:00:13 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span>
172.16.167.128 - - [15/May/2025:15:01:50 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span></code></pre>



<p>总结：通过 emptyDir 可以实现在一个 Pod 内，多个容器挂载到同一个 Volume，共享挂载文件。且容器可以将 Volume 挂载到不同的路径下。</p>
<h2 id="4-HostPath"><a href="#4-HostPath" class="headerlink" title="4. HostPath"></a>4. HostPath</h2><p>EmptyDir 中数据不会被持久化，它会随着 Pod 的结束而销毁，如果想简单的将数据持久化到主机中，可以选择 HostPath。</p>
<p>HostPath 就是将 Node 主机中一个实际目录挂在到 Pod 中，以供容器使用，这样的设计就可以保证 Pod 销毁了，但是数据依据可以存在于 Node 主机上。</p>
<h3 id="4-1-hostPath-的一些用法"><a href="#4-1-hostPath-的一些用法" class="headerlink" title="4.1 hostPath 的一些用法"></a>4.1 hostPath 的一些用法</h3><ul>
<li>运行一个需要访问 Docker 引擎内部机制的容器；请使用 hostPath 挂载 &#x2F;var&#x2F;lib&#x2F;docker 路径。</li>
<li>在容器中运行 cAdvisor 时，以 hostPath 方式挂载 &#x2F;sys。</li>
<li>允许 Pod 指定给定的 hostPath 在运行 Pod 之前是否应该存在，是否应该创建以及应该以什么方式存在。</li>
</ul>
<h3 id="4-2-支持类型"><a href="#4-2-支持类型" class="headerlink" title="4.2 支持类型"></a>4.2 支持类型</h3><p>除了必需的 path 属性之外，用户可以选择性地为 hostPath 卷指定 type。支持的 type 值如下：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空字符串（默认）用于向后兼容，这意味着在安装 hostPath 卷之前不会执行任何检查</td>
</tr>
<tr>
<td>DirectoryOrCreate</td>
<td>如果指定的路径不存在，那么将根据需要创建空目录，权限设置为 0755，具有与 Kubelet 相同的组和所有权</td>
</tr>
<tr>
<td>Directory</td>
<td>给定的路径必须存在</td>
</tr>
<tr>
<td>FileOrCreate</td>
<td>如果给定路径的文件不存在，那么将在那里根据需要创建空文件，权限设置为 0644，具有与 Kubelet 相同的组和所有权【前提：文件所在目录必须存在；目录不存在则不能创建文件】</td>
</tr>
<tr>
<td>File</td>
<td>给定路径上的文件必须存在</td>
</tr>
<tr>
<td>Socket</td>
<td>在给定路径上必须存在的 UNIX 套接字</td>
</tr>
<tr>
<td>CharDevice</td>
<td>在给定路径上必须存在的字符设备</td>
</tr>
<tr>
<td>BlockDevice</td>
<td>在给定路径上必须存在的块设备</td>
</tr>
</tbody></table>
<h3 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h3><p>当使用这种类型的卷时要小心，因为：</p>
<ul>
<li>具有相同配置（例如从 podTemplate 创建）的多个 Pod 会由于节点上文件的不同而在不同节点上有不同的行为。</li>
<li>当 Kubernetes 按照计划添加资源感知的调度时，这类调度机制将无法考虑由 hostPath 卷使用的资源。</li>
<li>基础主机上创建的文件或目录只能由 root 用户写入。需要在 特权容器 中以 root 身份运行进程，或者修改主机上的文件权限以便容器能够写入 hostPath 卷。</li>
</ul>
<h3 id="4-4-hostPath-使用案例"><a href="#4-4-hostPath-使用案例" class="headerlink" title="4.4 hostPath 使用案例"></a>4.4 hostPath 使用案例</h3><h4 id="4-4-1-资源清单"><a href="#4-4-1-资源清单" class="headerlink" title="4.4.1 资源清单"></a>4.4.1 资源清单</h4><p><code>002-volume-hostpath-01.yaml</code></p>
<pre><code class="highlight bash">apiVersion: apps/v1
kind: Deployment
metadata:
  namespace: default
  name: hostpath-deployment
  labels:
    name: volumn-dep
spec:
  replicas: 1
  selector:
    matchLabels: <span class="comment"># Deployment控制器管理具有如下标签的Pod</span>
      <span class="built_in">type</span>: hostpath
  template:
    metadata:
      labels: <span class="comment"># Pod模板设定生成的Pod有这些标签项</span>
        app: myapp
        <span class="built_in">type</span>: hostpath
    spec:
      containers:
        - name: nginx-container <span class="comment"># Pod1，nginx</span>
          image: wangyanglinux/myapp:v1.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 80
          volumeMounts: <span class="comment"># 设置 pod 挂载的容器卷</span>
            - name: log-volume
              mountPath: /usr/local/nginx/logs <span class="comment"># 镜像日志输出目录，必须存在</span>
        - name: busybox-container <span class="comment"># Pod2，busybox</span>
          image: busybox:latest
          imagePullPolicy: IfNotPresent
          volumeMounts: <span class="comment"># 设置 pod 挂载的容器卷</span>
            - name: log-volume
              mountPath: /logs
          <span class="built_in">command</span>:
            - <span class="string">&#x27;/bin/sh&#x27;</span>
            - <span class="string">&#x27;-c&#x27;</span>
            - <span class="string">&#x27;tail -f /logs/access.log&#x27;</span>
      volumes:
        - name: log-volume <span class="comment"># 设置自定义容器卷的名称</span>
          hostPath: <span class="comment"># 容器卷类型：hostPath</span>
            path: /root/logs
            <span class="built_in">type</span>: DirectoryOrCreate <span class="comment"># 目录存在就使用，不存在就先创建后使用</span></code></pre>



<h4 id="4-4-2-创建-Deployment"><a href="#4-4-2-创建-Deployment" class="headerlink" title="4.4.2 创建 Deployment"></a>4.4.2 创建 Deployment</h4><pre><code class="highlight bash"><span class="comment"># 加载资源清单，创建 Deployment</span>
$ kubectl apply -f 002-volume-hostpath-01.yaml --record

<span class="comment"># 查看 Pod 状态</span>
$ kubectl get pods -o wide
NAME                                   READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES
hostpath-deployment-774b569d9f-ntpqp   2/2     Running   0          41s   172.16.58.247   k8s-node02   &lt;none&gt;           &lt;none&gt;

<span class="comment"># 访问 nginx 容器</span>
$ curl 172.16.58.247
www.xinxianghf.com | hello MyAPP | version v1.0</code></pre>



<h4 id="4-4-3-进入-busybox-container-容器查看日志"><a href="#4-4-3-进入-busybox-container-容器查看日志" class="headerlink" title="4.4.3 进入 busybox-container 容器查看日志"></a>4.4.3 进入 busybox-container 容器查看日志</h4><pre><code class="highlight bash">$ kubectl <span class="built_in">exec</span> -it hostpath-deployment-774b569d9f-ntpqp -c busybox-container -- <span class="built_in">tail</span> -f /logs/access.log
172.16.167.128 - - [30/Apr/2025:14:17:15 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span>
172.16.167.128 - - [30/Apr/2025:14:17:20 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span></code></pre>



<h4 id="4-4-4-查看宿主机挂载目录"><a href="#4-4-4-查看宿主机挂载目录" class="headerlink" title="4.4.4 查看宿主机挂载目录"></a>4.4.4 查看宿主机挂载目录</h4><p>当前 Pod 运行在 k8s-node02 节点上，挂载目录为 &#x2F;root&#x2F;logs （资源清单配置挂载目录）</p>
<pre><code class="highlight bash">[root@k8s-node02 /]$ <span class="built_in">tail</span> -f /root/logs/access.log 
172.16.167.128 - - [30/Apr/2025:14:17:15 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span>
172.16.167.128 - - [30/Apr/2025:14:17:20 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span></code></pre>





<h2 id="5-NFS"><a href="#5-NFS" class="headerlink" title="5. NFS"></a>5. NFS</h2><p>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。</p>
<p>NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/05/15/20250515-154921.png" alt="NFS文件存储"></p>
<h3 id="5-1-安装-NFS-文件服务器"><a href="#5-1-安装-NFS-文件服务器" class="headerlink" title="5.1 安装 NFS 文件服务器"></a>5.1 安装 NFS 文件服务器</h3><p>NFS 文件服务器与 FTP 类似，都有服务端和客户端。这里为了简单，以 Master 节点作为 NFS 服务端，其它 Node 节点作为 NFS 客户端。</p>
<h4 id="5-1-1-安装-NFS-服务"><a href="#5-1-1-安装-NFS-服务" class="headerlink" title="5.1.1 安装 NFS 服务"></a>5.1.1 安装 NFS 服务</h4><p><strong>在所有节点都要执行</strong></p>
<pre><code class="highlight bash">$ yum install -y nfs-utils rpcbind</code></pre>



<h4 id="5-1-2-创建共享目录"><a href="#5-1-2-创建共享目录" class="headerlink" title="5.1.2 创建共享目录"></a>5.1.2 创建共享目录</h4><p>仅在 Master 节点执行</p>
<pre><code class="highlight bash"><span class="comment"># 创建 共享目录</span>
$ <span class="built_in">mkdir</span> -p /root/data/nfs/

<span class="comment"># 目录提权</span>
<span class="built_in">chmod</span> 777 /root/data/nfs/

<span class="comment"># 变更用户组</span>
<span class="built_in">chown</span> nobody /root/data/nfs/</code></pre>



<h4 id="5-1-3-编辑共享目录读写配置"><a href="#5-1-3-编辑共享目录读写配置" class="headerlink" title="5.1.3 编辑共享目录读写配置"></a>5.1.3 编辑共享目录读写配置</h4><p>仅在 NFS 服务端节点操作</p>
<pre><code class="highlight bash">$ vim /etc/exports

<span class="comment"># 内容如下：</span>
/root/data/nfs     192.168.6.0/24(rw,no_root_squash,no_all_squash,<span class="built_in">sync</span>)</code></pre>

<p>表示 192.168.6. 网段的ip 都可以与 nfs 主服务器共享  <code>/root/data/nfs</code> 目录内容</p>
<p><strong>参数说明：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ro</td>
<td>只读访问</td>
</tr>
<tr>
<td>rw</td>
<td>读写访问</td>
</tr>
<tr>
<td>sync</td>
<td>所有数据在请求时写入共享目录</td>
</tr>
<tr>
<td>async</td>
<td>nfs 在写入大数据时可以回应请求</td>
</tr>
<tr>
<td>secure</td>
<td>nfs 通过 1024 以下的安全 TCP&#x2F;IP 端口发送</td>
</tr>
<tr>
<td>insecure</td>
<td>nfs 通过 1024 以上的端口发送</td>
</tr>
<tr>
<td>wdelay</td>
<td>如果多个用户要写入 nfs 目录，则归组写入（默认）</td>
</tr>
<tr>
<td>no_wdelay</td>
<td>如果多个用户要写入 nfs 目录，则立即写入，当使用 async 时，无需此设置</td>
</tr>
<tr>
<td>hide</td>
<td>在 nfs 共享目录中不共享其子目录</td>
</tr>
<tr>
<td>no_hide</td>
<td>共享 nfs 目录的子目录</td>
</tr>
<tr>
<td>subtree_check</td>
<td>如果共享子目录如 &#x2F;usr&#x2F;bin 之类子目录，则强制检查子目录的权限（默认）</td>
</tr>
<tr>
<td>no_subtree_check</td>
<td>不检查子目录权限</td>
</tr>
<tr>
<td>all_squash</td>
<td>共享文件的 UID 和 GID 映射匿名用户 anonymous，通常会用匿名用户</td>
</tr>
<tr>
<td>no_all_squash</td>
<td>保留共享文件的 UID 和 GID（默认）</td>
</tr>
<tr>
<td>root_squash</td>
<td>root 用户的所有请求映射成 anonymous 用户一样的权限（默认）</td>
</tr>
<tr>
<td>no_root_squash</td>
<td>root 用户具有根目录的完全管理访问权限</td>
</tr>
<tr>
<td>anonuid&#x3D;xxx</td>
<td>指定 nfs 服务器 &#x2F;etc&#x2F;passwd 文件中匿名用户的 UID</td>
</tr>
<tr>
<td>anongid&#x3D;xxx</td>
<td>指定 nfs 服务器 &#x2F;etc&#x2F;passwd 文件中匿名用户的 GID</td>
</tr>
</tbody></table>
<h4 id="5-1-4-启动NFS服务"><a href="#5-1-4-启动NFS服务" class="headerlink" title="5.1.4 启动NFS服务"></a>5.1.4 启动NFS服务</h4><p>在集群内所有节点操作</p>
<pre><code class="highlight bash"> <span class="comment"># 启动服务</span>
$ systemctl start rpcbind
$ systemctl restart nfs-server.service

<span class="comment"># 设置开机自启</span>
$ systemctl <span class="built_in">enable</span> rpcbind
$ systemctl <span class="built_in">enable</span> nfs-server.service</code></pre>



<h4 id="5-1-5-测试NFS服务"><a href="#5-1-5-测试NFS服务" class="headerlink" title="5.1.5 测试NFS服务"></a>5.1.5 测试NFS服务</h4><pre><code class="highlight bash"><span class="comment"># 在Node01节点测试一下，是否能够正确挂载:</span>
root@k8s-node01 ~]$ showmount -e 192.168.6.139
Export list <span class="keyword">for</span> 192.168.6.139:
/root/data/nfs 192.168.6.0/24

<span class="comment"># 在客户端创建挂在目录</span>
[root@k8s-node01 ~]$ <span class="built_in">mkdir</span> /data/testnfs

<span class="comment"># 挂载远端目录到本地 /data/testnfs 目录</span>
[root@k8s-node01 ~]<span class="comment"># mount 192.168.6.139:/root/data/nfs /data/testnfs</span>

<span class="comment"># NFS服务端写入</span>
[root@k8s-master01 ~]<span class="comment"># echo &quot;This is NFS server.&quot; &gt; /root/data/nfs/nfs.txt</span>

<span class="comment"># 客户端读取</span>
[root@k8s-node01 ~]<span class="comment"># cat /data/testnfs/nfs.txt</span>
This is NFS server.

<span class="comment"># 客户端写入</span>
[root@k8s-node01 ~]<span class="comment"># echo &quot;This is NFS client.&quot; &gt;&gt; /data/testnfs/nfs.txt</span>

<span class="comment"># 服务端读取</span>
[root@k8s-master01 ~]<span class="comment"># cat /root/data/nfs/nfs.txt</span>
This is NFS server.
This is NFS client.

都是没问题的，这是因为上边设置了 NFS 远端目录权限为 rw 拥有读写权限，如果设置为 ro，那么
客户端只能读取，不能写入，根据实际应用场景合理配置，这里就不在演示了。这里提一下，NFS 默认
使用 UDP 协议来进行挂载，为了提高 NFS 的稳定性，可以使用 TCP 协议挂载，那么客户端挂载命
令可使用如下命令
mount 192.168.6.139:/root/data/nfs /data/testnfs -o proto=tcp -o nolock</code></pre>



<h4 id="5-1-6-客户端卸载-NFS-挂载目录"><a href="#5-1-6-客户端卸载-NFS-挂载目录" class="headerlink" title="5.1.6 客户端卸载 NFS 挂载目录"></a>5.1.6 客户端卸载 NFS 挂载目录</h4><pre><code class="highlight bash">umount /data/testnfs

<span class="comment"># 强制卸载</span>
umount -l /data/testnfs</code></pre>



<h4 id="5-1-7-使用-NFS4-服务"><a href="#5-1-7-使用-NFS4-服务" class="headerlink" title="5.1.7 使用 NFS4 服务"></a>5.1.7 使用 NFS4 服务</h4><p>相较于 NFS v2 v3 版本更新安全和高效</p>
<ul>
<li><p>修改 NFS 服务端配置</p>
<pre><code class="highlight bash">$ vim /etc/exports
/root/data/nfs     192.168.6.0/24(rw,fsid=0,no_root_squash)</code></pre>

<p>配置 &#x2F;etc&#x2F;exports 使用 NFSv4 伪文件系统（fsid&#x3D;0）</p>
</li>
<li><p>客户端使用 NFS4 挂载</p>
<pre><code class="highlight bash"><span class="comment"># 在客户端创建挂在目录</span>
[root@k8s-node01 ~]$ <span class="built_in">mkdir</span> /data/testnfs

<span class="comment"># 挂载远端目录到本地 /data/testnfs 目录</span>
[root@k8s-node01 ~]<span class="comment"># mount -t nfs4 192.168.6.139:/root/data/nfs /data/testnfs</span></code></pre></li>
</ul>
<h3 id="5-2-使用-NFS-挂载-Pod-目录"><a href="#5-2-使用-NFS-挂载-Pod-目录" class="headerlink" title="5.2 使用 NFS 挂载 Pod 目录"></a>5.2 使用 NFS 挂载 Pod 目录</h3><h4 id="5-2-1-资源清单"><a href="#5-2-1-资源清单" class="headerlink" title="5.2.1 资源清单"></a>5.2.1 资源清单</h4><p><code>003-volume-nfs-01.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>
<span class="attr">kind:</span> <span class="string">Deployment</span>
<span class="attr">metadata:</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
  <span class="attr">name:</span> <span class="string">nfs-deployment</span>
  <span class="attr">labels:</span>
    <span class="attr">name:</span> <span class="string">volumn-dep</span>
<span class="attr">spec:</span>
  <span class="attr">replicas:</span> <span class="number">1</span>
  <span class="attr">selector:</span>
    <span class="attr">matchLabels:</span> <span class="comment"># Deployment控制器管理具有如下标签的Pod</span>
      <span class="attr">type:</span> <span class="string">nfs</span>
  <span class="attr">template:</span>
    <span class="attr">metadata:</span>
      <span class="attr">labels:</span> <span class="comment"># Pod模板设定生成的Pod有这些标签项</span>
        <span class="attr">app:</span> <span class="string">myapp</span>
        <span class="attr">type:</span> <span class="string">nfs</span>
    <span class="attr">spec:</span>
      <span class="attr">containers:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span> <span class="comment"># Pod1，nginx</span>
          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>
          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
          <span class="attr">ports:</span>
            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>
          <span class="attr">volumeMounts:</span> <span class="comment"># 设置 pod 挂载的容器卷</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-volume</span>
              <span class="attr">mountPath:</span> <span class="string">/usr/local/nginx/logs</span> <span class="comment"># 镜像日志输出目录，必须存在</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox-container</span> <span class="comment"># Pod2，busybox</span>
          <span class="attr">image:</span> <span class="string">busybox:latest</span>
          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
          <span class="attr">volumeMounts:</span> <span class="comment"># 设置 pod 挂载的容器卷</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-volume</span>
              <span class="attr">mountPath:</span> <span class="string">/logs</span>
          <span class="attr">command:</span>
            <span class="bullet">-</span> <span class="string">&#x27;/bin/sh&#x27;</span>
            <span class="bullet">-</span> <span class="string">&#x27;-c&#x27;</span>
            <span class="bullet">-</span> <span class="string">&#x27;tail -f /logs/access.log&#x27;</span>
      <span class="attr">volumes:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-volume</span> <span class="comment"># 设置自定义容器卷的名称</span>
          <span class="attr">nfs:</span> <span class="comment"># 容器卷类型：hostPath</span>
            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.139</span> <span class="comment"># NFS 服务端</span>
            <span class="attr">path:</span> <span class="string">/root/data/nfs</span></code></pre>



<h4 id="5-2-2-创建-Deployment"><a href="#5-2-2-创建-Deployment" class="headerlink" title="5.2.2 创建 Deployment"></a>5.2.2 创建 Deployment</h4><pre><code class="highlight bash"><span class="comment"># 加载资源清单，创建 Deployment</span>
$ kubectl apply -f 003-volume-nfs-01.yaml

<span class="comment"># 查看 Pod 状态</span>
$ kubectl get pods -o wide
NAME                                   READY   STATUS    RESTARTS   AGE    IP              NODE         NOMINATED NODE   READINESS GATES
nfs-deployment-5c6b9ccfd-c2szn         2/2     Running   0          2m6s   172.16.85.201   k8s-node01   &lt;none&gt;           &lt;none&gt;

<span class="comment"># 访问 nginx 容器</span>
$ curl 172.16.85.201
www.xinxianghf.com | hello MyAPP | version v1.0</code></pre>



<h4 id="5-2-3-查看-NFS-挂载目录"><a href="#5-2-3-查看-NFS-挂载目录" class="headerlink" title="5.2.3 查看 NFS 挂载目录"></a>5.2.3 查看 NFS 挂载目录</h4><pre><code class="highlight bash">[root@k8s-master01 ~]$ <span class="built_in">cat</span> /root/data/nfs/access.log 
172.16.167.128 - - [15/May/2025:17:01:59 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span>
172.16.167.128 - - [15/May/2025:17:02:01 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span>
172.16.167.128 - - [15/May/2025:17:02:01 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 48 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.76.1&quot;</span></code></pre>

<p>pod 容器日志，通过 NFS 挂载到了 宿主机 Master 节点上，即便Pod删除，数据也不会丢失。</p>
<h1 id="六、PV-PVC"><a href="#六、PV-PVC" class="headerlink" title="六、PV&#x2F;PVC"></a>六、PV&#x2F;PVC</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>与管理计算实例相比，管理存储是一个明显的问题。PersistentVolume 子系统为用户和管理员提供了一个API，该API从如何使用存储中，抽象出如何提供存储的详细信息。为此，我们引入了两个新的API资源：PersistentVolume 和 PersistentVolumeClaim。</p>
<h2 id="2-PV概述"><a href="#2-PV概述" class="headerlink" title="2. PV概述"></a>2. PV概述</h2><p>PersistentVolume (PV) 是集群中由管理员提供或使用存储类动态提供的一块存储。它是集群中的资源，就像节点是集群资源一样。</p>
<p>PV 是与 Volumes 类似的卷插件，<strong>但其生命周期与使用PV的任何单个Pod无关</strong>。此API对象捕获存储实现的详细信息，包括NFS，<code>iSCSI</code>或特定于云提供程序的存储系统。</p>
<h2 id="3-PVC概述"><a href="#3-PVC概述" class="headerlink" title="3. PVC概述"></a>3. PVC概述</h2><p>PersistentVolumeClaim (PVC) 是用户对存储的请求。它类似于Pod；Pods消耗节点资源，而PVC消耗PV资源。Pods可以请求特定级别的资源(CPU和内存)。Claim可以请求特定的存储大小和访问模式(例如，它们可以挂载一次读写或多次只读)。</p>
<p>但是通过 PVC 请求到一定的存储空间也很有可能不足以满足应用对于存储设备的各种需求，而且不同的应用程序对于存储性能的要求可能也不尽相同，比如读写速度、并发性能等，为了解决这一问题，Kubernetes 又为我们引入了一个新的资源对象：<code>StorageClass</code>，通过 StorageClass 的定义，管理员可以将存储资源定义为某种类型的资源，比如快速存储、慢速存储等，用户根据 StorageClass 的描述就可以非常直观的知道各种存储资源的具体特性了，这样就可以根据应用的特性去申请合适的存储资源了。</p>
<h2 id="4-PV-和-PVC-的生命周期"><a href="#4-PV-和-PVC-的生命周期" class="headerlink" title="4. PV 和 PVC 的生命周期"></a>4. PV 和 PVC 的生命周期</h2><p>在 Kubernetes 中，Persistent Volume (PV) 和 Persistent Volume Claim (PVC) 是管理持久存储的核心组件。它们的生命周期与存储的分配、使用和释放密切相关。</p>
<h3 id="4-1-Persistent-Volume-PV-的生命周期"><a href="#4-1-Persistent-Volume-PV-的生命周期" class="headerlink" title="4.1 Persistent Volume (PV) 的生命周期"></a>4.1 Persistent Volume (PV) 的生命周期</h3><p>PV 是一个集群级别的存储资源，表示一块具体的存储（如 NFS、云存储卷等）。其生命周期包括以下阶段：</p>
<p><strong>1. 创建（Provisioning）</strong></p>
<ul>
<li><p>静态分配：管理员手动创建 PV，定义容量、访问模式（如 ReadWriteOnce、ReadOnlyMany）、存储类型等。</p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">PersistentVolume</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">my-pv</span>
<span class="attr">spec:</span>
  <span class="attr">capacity:</span>
    <span class="attr">storage:</span> <span class="string">1Gi</span>
  <span class="attr">accessModes:</span>
    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>
  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span>
  <span class="attr">storageClassName:</span> <span class="string">standard</span>
  <span class="attr">hostPath:</span>
    <span class="attr">path:</span> <span class="string">/mnt/data</span></code></pre>
</li>
<li><p><strong>动态分配</strong>：通过 PVC 和 StorageClass 自动创建 PV，无需管理员手动干预。</p>
</li>
</ul>
<p><strong>2. 绑定（Binding）</strong></p>
<ul>
<li>PV 与符合其条件的 PVC 绑定（匹配容量、访问模式、StorageClass 等）。</li>
<li>绑定后，PV 状态变为 Bound，并记录绑定的 PVC 信息。</li>
<li>如果没有合适的 PVC，PV 保持 Available 状态。</li>
</ul>
<p><strong>3. 使用（Usage）</strong></p>
<ul>
<li>绑定的 PV 被 Pod 通过 PVC 引用，挂载到容器中的指定路径。</li>
<li>Pod 运行期间，容器可以读写 PV 提供的存储。</li>
<li>PV 的底层存储（如云卷、NFS）决定数据的持久性和性能。</li>
</ul>
<p><strong>4. 释放（Releasing）</strong></p>
<ul>
<li><p>当绑定的 PVC 被删除时，PV 进入释放阶段。</p>
</li>
<li><p>PV 的回收策略（persistentVolumeReclaimPolicy）决定后续行为：</p>
<ul>
<li><strong>Retain</strong>：PV 保留，数据和元数据不删除，需手动清理	。</li>
<li><strong>Delete</strong>：PV 和底层存储资源自动删除（常见于云存储）。</li>
<li><strong>Recycle</strong>（已弃用）：数据被擦除，PV 可被复用。（只有NFS、HostPath支持回收）</li>
</ul>
</li>
</ul>
<p><strong>5. 删除（Deletion）</strong></p>
<ul>
<li>如果回收策略为 Delete，PV 和底层存储被销毁。</li>
<li>如果为 Retain，管理员需手动删除 PV 或重新绑定到新 PVC。</li>
</ul>
<h3 id="4-2-Persistent-Volume-Claim-PVC-的生命周期"><a href="#4-2-Persistent-Volume-Claim-PVC-的生命周期" class="headerlink" title="4.2 Persistent Volume Claim (PVC) 的生命周期"></a>4.2 Persistent Volume Claim (PVC) 的生命周期</h3><p>PVC 是命名空间级别的存储请求，充当 Pod 和 PV 之间的抽象层。其生命周期包括以下阶段：</p>
<p><strong>1. 创建（Request）</strong></p>
<ul>
<li><p>用户创建 PVC，指定存储需求（如容量、访问模式、StorageClass）</p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">my-pvc</span>
  <span class="attr">namespace:</span> <span class="string">default</span>
<span class="attr">spec:</span>
  <span class="attr">accessModes:</span>
    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>
  <span class="attr">resources:</span>
    <span class="attr">requests:</span>
      <span class="attr">storage:</span> <span class="string">1Gi</span>
  <span class="attr">storageClassName:</span> <span class="string">standard</span></code></pre>
</li>
<li><p>PVC 进入 Pending 状态，等待绑定。</p>
</li>
</ul>
<p><strong>2. 绑定（Binding）</strong></p>
<ul>
<li>Kubernetes 控制器寻找匹配的 PV（容量、访问模式等）。</li>
<li><strong>静态分配</strong>：绑定到现有的 PV。</li>
<li><strong>动态分配</strong>：通过 StorageClass 自动创建 PV 并绑定。</li>
<li>绑定成功后，PVC 状态变为 Bound，记录绑定的 PV 名称。</li>
</ul>
<p><strong>3. 使用（Usage）</strong></p>
<ul>
<li><p>Pod 通过 PVC 引用存储，配置在 spec.volumes 和 spec.containers.volumeMounts 中。</p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">my-pod</span>
<span class="attr">spec:</span>
  <span class="attr">containers:</span>
  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-container</span>
    <span class="attr">image:</span> <span class="string">nginx</span>
    <span class="attr">volumeMounts:</span>
    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&quot;/data&quot;</span>
      <span class="attr">name:</span> <span class="string">my-volume</span>
  <span class="attr">volumes:</span>
  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-volume</span>
    <span class="attr">persistentVolumeClaim:</span>
      <span class="attr">claimName:</span> <span class="string">my-pvc</span></code></pre>
</li>
<li><p>PVC 提供与底层 PV 无关的接口，Pod 直接访问存储。</p>
</li>
</ul>
<p><strong>4. 释放（Releasing）</strong></p>
<ul>
<li>当用户删除 PVC 时，Kubernetes 解除 PVC 与 PV 的绑定。</li>
<li>PV 根据回收策略（Retain、Delete）进入相应处理流程。</li>
</ul>
<p><strong>5. 删除（Deletion）</strong></p>
<ul>
<li>PVC 删除后，其资源被销毁。</li>
<li>如果 PV 的回收策略为 Delete，底层存储可能被销毁；如果为 Retain，PV 可重新绑定到新 PVC。</li>
</ul>
<h2 id="5-持久化声明保护"><a href="#5-持久化声明保护" class="headerlink" title="5. 持久化声明保护"></a>5. 持久化声明保护</h2><p>“使用中的存储对象保护” ：该功能的目的是确保在Pod活动时使用的PersistentVolumeClaims (PVC)和绑定到PVC的PersistentVolume (PV)不会从系统中删除，因为这可能会导致数据丢失。</p>
<p><strong>如果用户删除了Pod正在使用的PVC，则不会立即删除该PVC；PVC的清除被推迟，直到任何Pod不再主动使用PVC。另外，如果管理员删除绑定到PVC的PV，则不会立即删除该PV；PV的去除被推迟，直到PV不再与PVC结合。</strong></p>
<h2 id="6-回收策略"><a href="#6-回收策略" class="headerlink" title="6. 回收策略"></a>6. 回收策略</h2><p>当用户处理完他们的卷时，他们可以从允许回收资源的API中删除PVC对象。PersistentVolume 的回收策略告诉集群在释放卷的声明后该如何处理它。目前，卷可以被保留、回收或删除。</p>
<h3 id="6-1-Retain-保留"><a href="#6-1-Retain-保留" class="headerlink" title="6.1 Retain (保留)"></a>6.1 Retain (保留)</h3><p>保留回收策略允许手动回收资源。当 PersistentVolumeClaim 被删除时，PersistentVolume 仍然存在，并且该卷被认为是“释放”的。但是，由于之前声明的数据仍然存在，因此另一个声明尚无法得到。管理员可以手动回收卷。</p>
<h3 id="6-2-Delete-删除"><a href="#6-2-Delete-删除" class="headerlink" title="6.2 Delete (删除)"></a>6.2 Delete (删除)</h3><p>对于支持 Delete 回收策略的卷插件，删除操作会同时从 Kubernetes 中删除 PersistentVolume 对象以及外部基础架构中的关联存储资产，例如 AWS EBS，GCE PD，Azure Disk 或 Cinder 卷。动态配置的卷将继承其 StorageClass 的回收策略，默认为 Delete。管理员应根据用户的期望配置 StorageClass。</p>
<h3 id="6-3-Recycle-回收"><a href="#6-3-Recycle-回收" class="headerlink" title="6.3 Recycle (回收)"></a>6.3 Recycle (回收)</h3><p>如果基础卷插件支持，Recycle 回收策略将 <code>rm -rf /thevolume/*</code> 对该卷执行基本的擦除并使其可用于新的声明。</p>
<h2 id="7-Persistent-Volumes-类型"><a href="#7-Persistent-Volumes-类型" class="headerlink" title="7. Persistent Volumes 类型"></a>7. Persistent Volumes 类型</h2><p>PersistentVolume类型作为插件实现。Kubernetes当前支持以下插件：</p>
<ul>
<li>GCEPersistentDisk</li>
<li>AWSElasticBlockStore</li>
<li>AzureFile</li>
<li>AzureDisk</li>
<li>CSI</li>
<li>FC (Fibre Channel)</li>
<li>FlexVolume</li>
<li>Flocker</li>
<li>NFS</li>
<li>iSCSI</li>
<li>RBD (Ceph Block Device)</li>
<li>CephFS</li>
<li>Cinder (OpenStack block storage)</li>
<li>Glusterfs</li>
<li>VsphereVolume</li>
<li>Quobyte Volumes</li>
<li>HostPath (仅用于单节点测试——本地存储不受任何方式的支持，也不能在多节点集群中工作)</li>
<li>Portworx Volumes</li>
<li>ScaleIO Volumes</li>
<li>StorageOS</li>
</ul>
<h2 id="8-PV示例与参数说明"><a href="#8-PV示例与参数说明" class="headerlink" title="8. PV示例与参数说明"></a>8. PV示例与参数说明</h2><h3 id="8-1-PV示例"><a href="#8-1-PV示例" class="headerlink" title="8.1 PV示例"></a>8.1 PV示例</h3><pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">PersistentVolume</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pv-demo1</span>
<span class="attr">spec:</span>
  <span class="attr">capacity:</span>
    <span class="attr">storage:</span> <span class="string">5Gi</span> <span class="comment"># PV的容量大小 5G</span>
  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span>
  <span class="attr">accessModes:</span> <span class="comment"># PV 访问模式</span>
    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>
  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Delete</span> <span class="comment"># 回收策略</span>
  <span class="attr">storageClassName:</span> <span class="string">slow</span>
  <span class="attr">mountOptions:</span>
    <span class="bullet">-</span> <span class="string">hard</span> <span class="comment"># 指定挂载选项为 hard，表示 NFS 挂载是硬挂载，客户端会在连接中断时不断重试。</span>
    <span class="bullet">-</span> <span class="string">nfsvers=4.1</span> <span class="comment"># 指定使用 NFS 协议版本 4.1。</span>
  <span class="attr">nfs:</span>
    <span class="attr">path:</span> <span class="string">/root/data/nfs/</span>
    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.142</span><span class="number">.199</span></code></pre>



<p><strong>Capacity：</strong>通常，PV将具有特定的存储容量设置。当前，存储大小是可以设置或请求的唯一资源。将来的属性可能包括IOPS，吞吐量等。</p>
<p><strong>volumeMode：</strong>可选参数，为Filesystem或Block。Filesystem是volumeMode省略参数时使用的默认模式。</p>
<p><strong>accessModes：</strong>PersistentVolume可以通过资源提供者支持的任何方式安装在主机上。如下文表中所示，提供商将具有不同的功能，并且每个PV的访问模式都将设置为该特定卷支持的特定模式。例如，NFS可以支持多个读&#x2F;写客户端，但是特定的NFS PV可能以只读方式在服务器上导出。每个PV都有自己的一组访问模式，用于描述该特定PV的功能。</p>
<p><strong>访问方式为：</strong></p>
<ul>
<li>ReadWriteOnce-该卷可以被单个节点以读写方式挂载</li>
<li>ReadOnlyMany-该卷可以被许多节点以只读方式挂载</li>
<li>ReadWriteMany-该卷可以被多个节点以读写方式挂载</li>
</ul>
<p>在CLI命令行中，访问模式缩写为：</p>
<ul>
<li>RWO-ReadWriteOnce</li>
<li>ROX-ReadOnlyMany</li>
<li>RWX-ReadWriteMany</li>
</ul>
<p><strong>说明：一个卷一次只能使用一种访问模式挂载，即使它支持多种访问模式。</strong></p>
<p><strong>storageClassName：</strong>PV可以有一个类，通过将 storageClassName 属性设置为一个 StorageClass 的名称来指定这个类。特定类的 PV只能绑定到请求该类的 PVC。没有 storageClassName 的 PV 没有类，只能绑定到不请求特定类的PVC。</p>
<p><strong>persistentVolumeReclaimPolicy：</strong>当前的回收政策是：Retain (保留)-手动回收、Recycle (回收)-基本擦除（rm -rf &#x2F;thevolume&#x2F;*）、Delete (删除)-删除相关的存储资产 (例如 AWS EBS，GCE PD，Azure Disk 或 OpenStack Cinder 卷)。</p>
<p><strong>备注：当前，仅NFS和HostPath支持回收。AWS EBS，GCE PD，Azure Disk和Cinder卷支持删除。</strong></p>
<h3 id="8-2-PV卷状态"><a href="#8-2-PV卷状态" class="headerlink" title="8.2 PV卷状态"></a>8.2 PV卷状态</h3><p>卷将处于以下某种状态：</p>
<ul>
<li>Available：尚未绑定到声明(claim)的空闲资源</li>
<li>Bound：卷已被声明绑定</li>
<li>Released：声明已被删除，但群集尚未回收该资源</li>
<li>Failed：该卷自动回收失败</li>
</ul>
<p>CLI 将显示绑定到 PV 的 PVC 的名称。</p>
<h3 id="8-3-PV-类型与支持的访问模式"><a href="#8-3-PV-类型与支持的访问模式" class="headerlink" title="8.3 PV 类型与支持的访问模式"></a>8.3 PV 类型与支持的访问模式</h3><table>
<thead>
<tr>
<th>Volume Plugin</th>
<th>ReadWriteOnce</th>
<th>ReadOnlyMany</th>
<th>ReadWriteMany</th>
</tr>
</thead>
<tbody><tr>
<td>AWSElasticBlockStore</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>AzureFile</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>AzureDisk</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>CephFS</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Cinder</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>CSI</td>
<td>depends on the driver</td>
<td>depends on the driver</td>
<td>depends on the driver</td>
</tr>
<tr>
<td>FC</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>FlexVolume</td>
<td>✓</td>
<td>✓</td>
<td>depends on the driver</td>
</tr>
<tr>
<td>Flocker</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>GCEPersistentDisk</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Glusterfs</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>HostPath</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>iSCSI</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Quobyte</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>NFS</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>RBD</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>VsphereVolume</td>
<td>✓</td>
<td>-</td>
<td>- (works when Pods are collocated)</td>
</tr>
<tr>
<td>PortworxVolume</td>
<td>✓</td>
<td>-</td>
<td>✓</td>
</tr>
<tr>
<td>ScaleIO</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>StorageOS</td>
<td>✓</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="9-PV-PVC示例"><a href="#9-PV-PVC示例" class="headerlink" title="9. PV-PVC示例"></a>9. PV-PVC示例</h2><h3 id="9-1-主机信息"><a href="#9-1-主机信息" class="headerlink" title="9.1 主机信息"></a>9.1 主机信息</h3><table>
<thead>
<tr>
<th>服务器名称(hostname)</th>
<th>系统版本</th>
<th>配置</th>
<th>内网IP</th>
<th>部署模块</th>
</tr>
</thead>
<tbody><tr>
<td>k8s-master</td>
<td>Rocky 9.3</td>
<td>2C&#x2F;4G&#x2F;100G</td>
<td>192.168.204.199</td>
<td>k8s-master,NFS</td>
</tr>
<tr>
<td>k8s-node01</td>
<td>Rocky 9.3</td>
<td>2C&#x2F;4G&#x2F;100G</td>
<td>192.168.204.201</td>
<td>k8s-node</td>
</tr>
<tr>
<td>k8s-node02</td>
<td>Rocky 9.3</td>
<td>2C&#x2F;4G&#x2F;100G</td>
<td>192.168.204.202</td>
<td>k8s-node</td>
</tr>
</tbody></table>
<h3 id="9-2-NFS服务部署"><a href="#9-2-NFS服务部署" class="headerlink" title="9.2 NFS服务部署"></a>9.2 NFS服务部署</h3><p>部署及测试过程，参考上一段。</p>
<p><strong>创建共享目录</strong></p>
<pre><code class="highlight bash"><span class="comment"># 创建共享目录</span>
[root@k8s-master01 ~]$ <span class="built_in">mkdir</span> -p /root/data/nfs&#123;1..6&#125;
<span class="comment"># 给目录授权</span>
[root@k8s-master01 ~]$ <span class="built_in">chown</span> -R nobody:nobody /root/data/
<span class="comment"># 查看目录权限</span>
[root@k8s-master01 ~]$ ll /root/data/
total 0
drwxr-xr-x 2 nobody nobody 6 May 20 22:48 nfs1
drwxr-xr-x 2 nobody nobody 6 May 20 22:48 nfs2
drwxr-xr-x 2 nobody nobody 6 May 20 22:48 nfs3
drwxr-xr-x 2 nobody nobody 6 May 20 22:48 nfs4
drwxr-xr-x 2 nobody nobody 6 May 20 22:48 nfs5
drwxr-xr-x 2 nobody nobody 6 May 20 22:48 nfs6


<span class="comment"># 编辑 NFS 配置文件</span>
[root@k8s-master01 ~]$ vim /etc/exports
<span class="comment"># 添加如下内容</span>
/root/data     192.168.142.0/24(rw,fsid=0,no_root_squash)
/root/data/nfs1     192.168.142.0/24(rw,no_root_squash,no_all_squash,<span class="built_in">sync</span>)
/root/data/nfs2     192.168.142.0/24(rw,no_root_squash,no_all_squash,<span class="built_in">sync</span>)
/root/data/nfs3     192.168.142.0/24(rw,no_root_squash,no_all_squash,<span class="built_in">sync</span>)
/root/data/nfs4     192.168.142.0/24(rw,no_root_squash,no_all_squash,<span class="built_in">sync</span>)
/root/data/nfs5     192.168.142.0/24(rw,no_root_squash,no_all_squash,<span class="built_in">sync</span>)
/root/data/nfs6     192.168.142.0/24(rw,no_root_squash,no_all_squash,<span class="built_in">sync</span>)

<span class="comment"># 重启 NFS 服务</span>
[root@k8s-master01 ~]$ systemctl restart rpcbind.service
[root@k8s-master01 ~]$ systemctl restart nfs-server

<span class="comment"># 检查NFS服务 ， 其中 192.168.142.199 为服务端IP</span>
[root@k8s-master01 ~]$ showmount -e 192.168.142.199
Export list <span class="keyword">for</span> 192.168.142.199:
/root/data/nfs6 192.168.142.0/24
/root/data/nfs5 192.168.142.0/24
/root/data/nfs4 192.168.142.0/24
/root/data/nfs3 192.168.142.0/24
/root/data/nfs2 192.168.142.0/24
/root/data/nfs1 192.168.142.0/24
/root/data      192.168.142.0/24</code></pre>



<p><strong>NFS客户端验证</strong></p>
<p>在k8s-node02机器验证</p>
<pre><code class="highlight bash"><span class="comment"># 查看rpcbind服务，默认是启动的，如果没有启动则启动并加入开机自启动</span>
 [root@k8s-node02 ~]$ systemctl status rpcbind.service
 
 <span class="comment"># 查看NFS服务信息</span>
 [root@k8s-node02 ~]$ showmount -e 192.168.142.199
Export list <span class="keyword">for</span> 192.168.142.199:
/root/data/nfs6 192.168.142.0/24
/root/data/nfs5 192.168.142.0/24
/root/data/nfs4 192.168.142.0/24
/root/data/nfs3 192.168.142.0/24
/root/data/nfs2 192.168.142.0/24
/root/data/nfs1 192.168.142.0/24
/root/data      192.168.142.0/24

<span class="comment"># 挂载，并进行读写验证</span>
[root@k8s-node02 ~]$ mount -t nfs 192.168.142.199:/root/data/nfs1 /mnt/

<span class="comment"># 验证完毕，去掉NFS挂载</span>
[root@k8s-node02 ~]$ umount -lf 192.168.142.199:/root/data/nfs1</code></pre>





<h3 id="9-3-PV-部署"><a href="#9-3-PV-部署" class="headerlink" title="9.3 PV 部署"></a>9.3 PV 部署</h3><p>资源清单：<code>pv.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">PersistentVolume</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pv-nfs1</span>
<span class="attr">spec:</span>
  <span class="attr">capacity:</span>
    <span class="attr">storage:</span> <span class="string">1Gi</span> <span class="comment"># 1G磁盘容量</span>
  <span class="attr">accessModes:</span>
    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>
  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span> <span class="comment"># 自动回收的策略</span>
  <span class="attr">storageClassName:</span> <span class="string">nfs</span> <span class="comment"># 使用NFS</span>
  <span class="attr">nfs:</span>
    <span class="attr">path:</span> <span class="string">/root/data/nfs1</span>
    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.142</span><span class="number">.199</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">PersistentVolume</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pv-nfs2</span>
<span class="attr">spec:</span>
  <span class="attr">capacity:</span>
    <span class="attr">storage:</span> <span class="string">3Gi</span>
  <span class="attr">accessModes:</span>
    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>
  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span> <span class="comment"># 自动回收的策略</span>
  <span class="attr">storageClassName:</span> <span class="string">nfs</span> <span class="comment"># 使用NFS</span>
  <span class="attr">nfs:</span>
    <span class="attr">path:</span> <span class="string">/root/data/nfs2</span>
    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.142</span><span class="number">.199</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">PersistentVolume</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pv-nfs3</span>
<span class="attr">spec:</span>
  <span class="attr">capacity:</span>
    <span class="attr">storage:</span> <span class="string">5Gi</span>
  <span class="attr">accessModes:</span>
    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>
  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span> <span class="comment"># 自动回收的策略</span>
  <span class="attr">storageClassName:</span> <span class="string">nfs</span> <span class="comment"># 使用NFS</span>
  <span class="attr">nfs:</span>
    <span class="attr">path:</span> <span class="string">/root/data/nfs3</span>
    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.142</span><span class="number">.199</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">PersistentVolume</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pv-nfs4</span>
<span class="attr">spec:</span>
  <span class="attr">capacity:</span>
    <span class="attr">storage:</span> <span class="string">10Gi</span>
  <span class="attr">accessModes:</span>
    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>
  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span> <span class="comment"># 自动回收的策略</span>
  <span class="attr">storageClassName:</span> <span class="string">nfs</span> <span class="comment"># 使用NFS</span>
  <span class="attr">nfs:</span>
    <span class="attr">path:</span> <span class="string">/root/data/nfs4</span>
    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.142</span><span class="number">.199</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">PersistentVolume</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pv-nfs5</span>
<span class="attr">spec:</span>
  <span class="attr">capacity:</span>
    <span class="attr">storage:</span> <span class="string">5Gi</span>
  <span class="attr">accessModes:</span>
    <span class="bullet">-</span> <span class="string">ReadWriteMany</span>
  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span> <span class="comment"># 自动回收的策略</span>
  <span class="attr">storageClassName:</span> <span class="string">nfs</span> <span class="comment"># 使用NFS</span>
  <span class="attr">nfs:</span>
    <span class="attr">path:</span> <span class="string">/root/data/nfs5</span>
    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.142</span><span class="number">.199</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">PersistentVolume</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">pv-nfs6</span>
<span class="attr">spec:</span>
  <span class="attr">capacity:</span>
    <span class="attr">storage:</span> <span class="string">5Gi</span>
  <span class="attr">accessModes:</span>
    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>
  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span> <span class="comment"># 自动回收的策略</span>
  <span class="attr">storageClassName:</span> <span class="string">nfs</span> <span class="comment"># 使用NFS</span>
  <span class="attr">nfs:</span>
    <span class="attr">path:</span> <span class="string">/root/data/nfs6</span>
    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.142</span><span class="number">.199</span></code></pre>



<p>启动PV，并查看状态</p>
<pre><code class="highlight bash"><span class="comment"># 创建PV</span>
$ kubectl create -f pv.yaml

<span class="comment"># 查看PV详情</span>
$ kubectl get pv -o wide
NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE     VOLUMEMODE
pv-nfs1   1Gi        RWO            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          3m14s   Filesystem
pv-nfs2   3Gi        RWO            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          3m14s   Filesystem
pv-nfs3   5Gi        RWO            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          3m14s   Filesystem
pv-nfs4   10Gi       RWO            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          3m14s   Filesystem
pv-nfs5   5Gi        RWX            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          3m13s   Filesystem
pv-nfs6   5Gi        RWO            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          3m13s   Filesystem</code></pre>



<h3 id="9-4-StatefulSet-创建并使用-PVC"><a href="#9-4-StatefulSet-创建并使用-PVC" class="headerlink" title="9.4 StatefulSet 创建并使用 PVC"></a>9.4 StatefulSet 创建并使用 PVC</h3><h4 id="9-4-1-资源清单"><a href="#9-4-1-资源清单" class="headerlink" title="9.4.1 资源清单"></a>9.4.1 资源清单</h4><p><code>sts-pod-pvc.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Service</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 服务的名称为 nginx</span>
  <span class="attr">labels:</span>
    <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># 给服务打一个标签</span>
<span class="attr">spec:</span>
  <span class="attr">ports:</span> <span class="comment"># 指定服务暴露的端口</span>
    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 服务监听在 80 端口，外部请求通过该端口访问</span>
  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 设置为 None，表示这是一个 Headless Service。Headless Service 不会分配集群 IP，而是直接通过 DNS 解析到后端的 Pod。</span>
  <span class="attr">selector:</span>
    <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># 服务通过标签选择器 app: nginx 找到匹配的 Pod，将流量路由到这些 Pod。</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">apps/v1</span>
<span class="attr">kind:</span> <span class="string">StatefulSet</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">web</span> <span class="comment"># StatefulSet 名称为 web，用于管理一组 Pod。</span>
<span class="attr">spec:</span>
  <span class="attr">selector:</span>
    <span class="attr">matchLabels:</span> <span class="comment"># 通过标签 app: nginx 选择要管理的 Pod，确保 StatefulSet 只控制带有该标签的 Pod。</span>
      <span class="attr">app:</span> <span class="string">nginx</span>
  <span class="attr">serviceName:</span> <span class="string">nginx</span> <span class="comment"># 指定关联的 Service 的名称为 nginx， StatefulSet 使用此 Service 来为每个 Pod 提供稳定的 DNS 名称（例如 web-0.nginx.default.svc.cluster.local.）</span>
  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 创建 3 个 Pod 副本，分别命名为 web-0、web-1 和 web-2</span>
  <span class="attr">template:</span>
    <span class="attr">metadata:</span>
      <span class="attr">labels:</span> <span class="comment"># 为 Pod 添加标签 app: nginx，与 Service 的选择器匹配。</span>
        <span class="attr">app:</span> <span class="string">nginx</span>
    <span class="attr">spec:</span>
      <span class="attr">containers:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>
          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>
          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
          <span class="attr">ports:</span>
            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>
              <span class="attr">name:</span> <span class="string">web</span>
          <span class="attr">volumeMounts:</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span> <span class="comment"># 挂载的卷名称为 www</span>
              <span class="attr">mountPath:</span> <span class="string">/usr/local/nginx/html</span>
  <span class="attr">volumeClaimTemplates:</span>
    <span class="bullet">-</span> <span class="attr">metadata:</span>
        <span class="attr">name:</span> <span class="string">www</span> <span class="comment"># PVC 名称为 www，与 volumeMounts 中的名称对应</span>
      <span class="attr">spec:</span>
        <span class="attr">accessModes:</span>
          <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>
        <span class="attr">storageClassName:</span> <span class="string">nfs</span>
        <span class="attr">resources:</span>
          <span class="attr">requests:</span>
            <span class="attr">storage:</span> <span class="string">3Gi</span></code></pre>



<h4 id="9-4-2-启动pod并查看状态"><a href="#9-4-2-启动pod并查看状态" class="headerlink" title="9.4.2 启动pod并查看状态"></a>9.4.2 启动pod并查看状态</h4><pre><code class="highlight bash"><span class="comment"># 执行资源清单，创建Service 和 StatufulSet 和 Pod</span>
$ kubectl apply -f sts-pod-pvc.yaml

<span class="comment"># 查看 Service 详情</span>
$ kubectl get svc -o wide
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTOR
kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   66d   &lt;none&gt;
nginx        ClusterIP   None         &lt;none&gt;        80/TCP    6s    app=nginx

<span class="comment"># 查看 StatefulSet 详情</span>
$ kubectl get statefulSet -o wide
NAME   READY   AGE   CONTAINERS   IMAGES
web    3/3     52s   nginx        wangyanglinux/myapp:v1.0

<span class="comment"># 查看 Pod详情</span>
$ kubectl get pods -o wide
NAME    READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATES
web-0   1/1     Running   0          61s   192.168.85.228   k8s-node01   &lt;none&gt;           &lt;none&gt;
web-1   1/1     Running   0          56s   192.168.58.226   k8s-node02   &lt;none&gt;           &lt;none&gt;
web-2   1/1     Running   0          50s   192.168.58.227   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre>



<h4 id="9-4-3-PV和PVC状态信息查看"><a href="#9-4-3-PV和PVC状态信息查看" class="headerlink" title="9.4.3 PV和PVC状态信息查看"></a>9.4.3 PV和PVC状态信息查看</h4><pre><code class="highlight bash"><span class="comment"># PV 明细</span>
$ kubectl get pods -o wide
NAME    READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATES
web-0   1/1     Running   0          30m   192.168.58.233   k8s-node02   &lt;none&gt;           &lt;none&gt;
web-1   1/1     Running   0          30m   192.168.85.237   k8s-node01   &lt;none&gt;           &lt;none&gt;
web-2   1/1     Running   0          30m   192.168.58.234   k8s-node02   &lt;none&gt;           &lt;none&gt;

<span class="comment"># PVC 明细</span>
$ kubectl get pvc -o wide
NAME        STATUS   VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE   VOLUMEMODE
www-web-0   Bound    pv-nfs2   3Gi        RWO            nfs            &lt;<span class="built_in">unset</span>&gt;                 31m   Filesystem
www-web-1   Bound    pv-nfs3   5Gi        RWO            nfs            &lt;<span class="built_in">unset</span>&gt;                 31m   Filesystem
www-web-2   Bound    pv-nfs6   5Gi        RWO            nfs            &lt;<span class="built_in">unset</span>&gt;                 31m   Filesystem</code></pre>

<p><strong>PVC与PV绑定时会根据storageClassName（存储类名称）和accessModes（访问模式）判断哪些PV符合绑定需求。然后再根据存储量大小判断，首先存PV储量必须大于或等于PVC声明量；其次就是PV存储量越接近PVC声明量，那么优先级就越高（PV量越小优先级越高）。</strong></p>
<p>从上面的信息可以看到 web-0 对应的集群内的IP是 192.168.58.233， 运行在 k8s-node02 节点上，对应的 PVC 是 www-web-0, 绑定的PV 是 pv-nfs2</p>
<h4 id="9-4-4-curl访问验证"><a href="#9-4-4-curl访问验证" class="headerlink" title="9.4.4 curl访问验证"></a>9.4.4 curl访问验证</h4><p>在NFS服务端对应NFS共享目录创建文件</p>
<p>pv-nfs2、pv-nfs3、pv-nfs6 被绑定，只需要在这三个pv对应的目录写入文件即可</p>
<pre><code class="highlight bash">$ <span class="built_in">echo</span> <span class="string">&quot;hello nfs2&quot;</span> &gt;&gt; /root/data/nfs2/index.html
$ <span class="built_in">echo</span> <span class="string">&quot;hello nfs3&quot;</span> &gt;&gt; /root/data/nfs3/index.html
$ <span class="built_in">echo</span> <span class="string">&quot;hello nfs6&quot;</span> &gt;&gt; /root/data/nfs6/index.html</code></pre>



<p>curl 访问 pod</p>
<pre><code class="highlight bash">NAME    READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATES
web-0   1/1     Running   0          40m   192.168.58.233   k8s-node02   &lt;none&gt;           &lt;none&gt;
web-1   1/1     Running   0          40m   192.168.85.237   k8s-node01   &lt;none&gt;           &lt;none&gt;
web-2   1/1     Running   0          39m   192.168.58.234   k8s-node02   &lt;none&gt;           &lt;none&gt;
[root@k8s-master01 /opt/k8s/07/pv-pvc]$ curl 192.168.58.233
hello nfs2
[root@k8s-master01 /opt/k8s/07/pv-pvc]$ curl 192.168.58.234
hello nfs6
[root@k8s-master01 /opt/k8s/07/pv-pvc]$ curl 192.168.85.237
hello nfs3</code></pre>

<p>即使删除其中一个pod，pod被拉起来后也能正常访问。</p>
<h3 id="9-5-删除-StatefulSet-并回收-PV"><a href="#9-5-删除-StatefulSet-并回收-PV" class="headerlink" title="9.5 删除 StatefulSet 并回收 PV"></a>9.5 删除 StatefulSet 并回收 PV</h3><h4 id="9-5-1-删除-StatefulSet"><a href="#9-5-1-删除-StatefulSet" class="headerlink" title="9.5.1 删除 StatefulSet"></a>9.5.1 删除 StatefulSet</h4><pre><code class="highlight bash">$ kubectl delete -f sts-pod-pvc.yaml 
service <span class="string">&quot;nginx&quot;</span> deleted
statefulset.apps <span class="string">&quot;web&quot;</span> deleted

$ kubectl get svc 
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   70d

$ kubectl get pod 
No resources found <span class="keyword">in</span> default namespace.</code></pre>



<h4 id="9-5-2-查看PVC和PV，并删除PVC"><a href="#9-5-2-查看PVC和PV，并删除PVC" class="headerlink" title="9.5.2 查看PVC和PV，并删除PVC"></a>9.5.2 查看PVC和PV，并删除PVC</h4><pre><code class="highlight bash"><span class="comment"># 查看PVC</span>
$ kubectl get pvc -o wide
NAME        STATUS   VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE   VOLUMEMODE
www-web-0   Bound    pv-nfs2   3Gi        RWO            nfs            &lt;<span class="built_in">unset</span>&gt;                 61m   Filesystem
www-web-1   Bound    pv-nfs3   5Gi        RWO            nfs            &lt;<span class="built_in">unset</span>&gt;                 61m   Filesystem
www-web-2   Bound    pv-nfs6   5Gi        RWO            nfs            &lt;<span class="built_in">unset</span>&gt;                 61m   Filesystem

<span class="comment"># 查看PV</span>
$ kubectl get pv -o wide
NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM               STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE   VOLUMEMODE
pv-nfs1   1Gi        RWO            Recycle          Available                       nfs            &lt;<span class="built_in">unset</span>&gt;                          62m   Filesystem
pv-nfs2   3Gi        RWO            Recycle          Bound       default/www-web-0   nfs            &lt;<span class="built_in">unset</span>&gt;                          62m   Filesystem
pv-nfs3   5Gi        RWO            Recycle          Bound       default/www-web-1   nfs            &lt;<span class="built_in">unset</span>&gt;                          62m   Filesystem
pv-nfs4   10Gi       RWO            Recycle          Available                       nfs            &lt;<span class="built_in">unset</span>&gt;                          62m   Filesystem
pv-nfs5   5Gi        RWX            Recycle          Available                       nfs            &lt;<span class="built_in">unset</span>&gt;                          62m   Filesystem
pv-nfs6   5Gi        RWO            Recycle          Bound       default/www-web-2   nfs            &lt;<span class="built_in">unset</span>&gt;                          62m   Filesystem</code></pre>



<h4 id="9-5-3-回收-PV"><a href="#9-5-3-回收-PV" class="headerlink" title="9.5.3 回收 PV"></a>9.5.3 回收 PV</h4><p>删除PVC后再次查看PV，发现PV从 Bound 状态变成了 Released 状态，没有真正释放掉（变回Available状态），这时有两种办法，一是等待，让PV自动释放掉，第二种方式是手动释放PV</p>
<pre><code class="highlight bash"><span class="comment"># 再次查看PV</span>
$ kubectl get pv -o wide
NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM               STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE   VOLUMEMODE
pv-nfs1   1Gi        RWO            Recycle          Available                       nfs            &lt;<span class="built_in">unset</span>&gt;                          67m   Filesystem
pv-nfs2   3Gi        RWO            Recycle          Released    default/www-web-0   nfs            &lt;<span class="built_in">unset</span>&gt;                          67m   Filesystem
pv-nfs3   5Gi        RWO            Recycle          Released    default/www-web-1   nfs            &lt;<span class="built_in">unset</span>&gt;                          67m   Filesystem
pv-nfs4   10Gi       RWO            Recycle          Available                       nfs            &lt;<span class="built_in">unset</span>&gt;                          67m   Filesystem
pv-nfs5   5Gi        RWX            Recycle          Available                       nfs            &lt;<span class="built_in">unset</span>&gt;                          67m   Filesystem
pv-nfs6   5Gi        RWO            Recycle          Released    default/www-web-2   nfs            &lt;<span class="built_in">unset</span>&gt;                          67m   Filesystem

<span class="comment"># 编辑，手动释放PV, 将 spec.claimRef 部分删除</span>
$ kubectl edit pv pv-nfs2
$ kubectl edit pv pv-nfs3
$ kubectl edit pv pv-nfs6</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/05/27/20250527-221115.png" alt="手动释放PV"></p>
<p>手动修改完成后，再次查看PV状态</p>
<pre><code class="highlight bash">$ kubectl get pv -o wide
NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE   VOLUMEMODE
pv-nfs1   1Gi        RWO            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          72m   Filesystem
pv-nfs2   3Gi        RWO            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          72m   Filesystem
pv-nfs3   5Gi        RWO            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          72m   Filesystem
pv-nfs4   10Gi       RWO            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          72m   Filesystem
pv-nfs5   5Gi        RWX            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          72m   Filesystem
pv-nfs6   5Gi        RWO            Recycle          Available           nfs            &lt;<span class="built_in">unset</span>&gt;                          72m   Filesystem</code></pre>

<p>结论： PV 已成功释放。</p>
<h2 id="10-StatefulSet网络标识与PVC"><a href="#10-StatefulSet网络标识与PVC" class="headerlink" title="10. StatefulSet网络标识与PVC"></a>10. StatefulSet网络标识与PVC</h2><ul>
<li><p>匹配 StatefulSet 的 Pod name (网络标识)的模式为：<code>$(statefulset名称)-$(序号)</code>，比如 StatefulSet 名称为web，副本数为3。则为：web-0、web-1、web-2</p>
</li>
<li><p>StatefulSet 为每个Pod副本创建了一个DNS域名，这个域名的格式为：<code>$(podname).(headless service name)</code>，也就意味着服务之间是通过Pod域名来通信而非Pod IP。当Pod所在Node发生故障时，Pod会被漂移到其他Node上，Pod IP会发生改变，但Pod域名不会变化</p>
</li>
<li><p>StatefulSet 使用 Headless 服务来控制 Pod 的域名，这个 Headless 服务域名的为：<code>$(service name).$(namespace).svc.cluster.local</code>，其中 cluster.local 指定的集群的域名</p>
</li>
<li><p>根据 volumeClaimTemplates，为每个 Pod 创建一个 PVC，PVC的命令规则为：<code>$(volumeClaimTemplates name)-$(pod name)</code>，比如 volumeClaimTemplates 为 www，pod name 为 web-0、web-1、web-2；那么创建出来的PVC为：www-web-0、www-web-1、www-web-2</p>
</li>
<li><p>删除 Pod 不会删除对应的 PVC，手动删除 PVC 将自动释放 PV。</p>
</li>
</ul>
<h1 id="七、StorageClass"><a href="#七、StorageClass" class="headerlink" title="七、StorageClass"></a>七、StorageClass</h1><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1. 理论"></a>1. 理论</h2><p>在动态资源供应模式下，通过StorageClass和PVC完成资源动态绑定（系统自动生成PV），并供Pod使用的存储管理机制。</p>
<p>volumeClaimTemplates 实现了pvc 的自动化，StorageClass 实现了 pv 的自动化</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/05/29/20250529-160448.png" alt="存储"></p>
<h3 id="1-1-什么是-StorageClass"><a href="#1-1-什么是-StorageClass" class="headerlink" title="1.1 什么是 StorageClass"></a>1.1 什么是 StorageClass</h3><p>Kubernetes 提供了一套可以自动创建PV的机制，即：Dynamic Provisioning。而这个机制的核心在于StorageClass这个API对象。</p>
<p>StorageClass 对象会定义下面两部分内容:</p>
<ul>
<li>PV 的属性。比如，存储类型，Volume 的大小等。</li>
<li>创建这种 PV 需要用到的存储插件，即存储制备器。</li>
</ul>
<p>有了这两个信息之后，Kubernetes 就能够根据用户提交的 PVC，找到一个对应的 StorageClass，之后 Kubernetes 就会调用该 StorageClass 声明的存储插件，进而创建出需要的PV。</p>
<p>但是其实使用起来是一件很简单的事情，你只需要根据自己的需求，编写YAML文件即可，然后使用 <code>kubectl create</code> 命令执行即可。</p>
<blockquote>
<p>StorageClass 为管理员提供了描述存储 “类” 的方法。不同的类型可能会映射到不同的服务质量等级或备份策略，或是由集群管理员制定的任意策略。 Kubernetes 本身并不清楚各种类代表的什么。这个类的概念在其他存储系统中有时被称为 “配置文件”。</p>
</blockquote>
<h3 id="1-2-为什么需要-StorageClass"><a href="#1-2-为什么需要-StorageClass" class="headerlink" title="1.2 为什么需要 StorageClass"></a>1.2 为什么需要 StorageClass</h3><p>在一个大规模的 Kubernetes 集群里，可能有成千上万个 PVC，这就意味着运维人员必须实现创建出这个多个 PV，此外，随着项目的需要，会有新的 PVC 不断被提交，那么运维人员就需要不断的添加新的，满足要求的 PV，否则新的Pod就会因为 PVC 绑定不到PV而导致创建失败。而且通过 PVC 请求到一定的存储空间也很有可能不足以满足应用对于存储设备的各种需求。</p>
<p>而且不同的应用程序对于存储性能的要求可能也不尽相同，比如读写速度、并发性能等，为了解决这一问题，Kubernetes 又为我们引入了一个新的资源对象：StorageClass，通过 StorageClass 的定义，管理员可以将存储资源定义为某种类型的资源，比如快速存储、慢速存储等，用户根据 StorageClass 的描述就可以非常直观的知道各种存储资源的具体特性了，这样就可以根据应用的特性去申请合适的存储资源了。</p>
<h3 id="1-3-运行原理"><a href="#1-3-运行原理" class="headerlink" title="1.3  运行原理"></a>1.3  运行原理</h3><p>要使用 StorageClass，我们就得安装对应的自动配置程序，比如我们这里存储后端使用的是 nfs，那么我们就需要使用到一个 nfs-client 的自动配置程序，我们也叫它 <code>Provisioner</code>（制备器），这个程序使用我们已经配置好的 nfs 服务器，来自动创建持久卷，也就是自动帮我们创建 PV。</p>
<ul>
<li>自动创建的 PV 以 <code>$&#123;namespace&#125;-$&#123;pvcName&#125;-$&#123;pvName&#125;</code> 这样的命名格式创建在 NFS 服务器上的共享数据目录中</li>
<li>而当这个 PV 被回收后会以 <code>archieved-$&#123;namespace&#125;-$&#123;pvcName&#125;-$&#123;pvName&#125;</code> 这样的命名格式存在 NFS 服务器上。</li>
</ul>
<h2 id="2-StorageClass-资源"><a href="#2-StorageClass-资源" class="headerlink" title="2. StorageClass 资源"></a>2. StorageClass 资源</h2><p>StorageClass 资源清单示例：</p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span>
<span class="attr">kind:</span> <span class="string">StorageClass</span> <span class="comment"># 资源的类型为 StorageClass</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">standard</span> <span class="comment"># 存储类的名称</span>
<span class="attr">provisioner:</span> <span class="string">kubernetes.io/aws-ebs</span> <span class="comment"># 指定了存储的提供者（Provisioner）,使用 AWS EBS（Elastic Block Store）作为存储后端</span>
<span class="attr">parameters:</span>
  <span class="attr">type:</span> <span class="string">gp2</span> <span class="comment"># 指定了 AWS EBS 卷的类型为 gp2。gp2 是 AWS EBS 的通用 SSD（General Purpose SSD）卷类型</span>
<span class="attr">reclaimPolicy:</span> <span class="string">Retain</span> <span class="comment"># 定义了存储卷的回收策略为 Retain。当 PVC 被删除时，与之关联的持久卷（PV）不会被自动删除，而是保留下来，需要手动清理。这可以防止意外删除重要数据。</span>
<span class="attr">allowVolumeExpansion:</span> <span class="literal">true</span> <span class="comment"># 允许对使用此 StorageClass 创建的卷进行扩展, 如果 PVC 请求更大的容量，Kubernetes 允许动态扩展卷（前提是底层存储支持，例如 AWS EBS 的 gp2 支持扩展）。</span>
<span class="attr">mountOptions:</span>
  <span class="bullet">-</span> <span class="string">debug</span> <span class="comment"># 指定了挂载选项为 debug, 在挂载存储卷时启用调试模式，可能用于记录详细的挂载日志，便于排查问题。注意：生产环境中通常不建议使用 debug，因为它可能会增加日志输出</span>
<span class="attr">volumeBindingMode:</span> <span class="string">Immediate</span> <span class="comment"># 指定了卷绑定模式为 Immediate, 表示一旦 PVC 创建，Kubernetes 将立即尝试为它绑定一个持久卷（PV），而不等待 Pod 调度。这适用于大多数场景，但可能导致存储资源分配不灵活（相比 WaitForFirstConsumer 模式）。</span></code></pre>



<p>每个 StorageClass 都包含 <code>provisioner</code>、<code>parameters</code> 和 <code>reclaimPolicy</code> 字段， 这些字段会在 StorageClass 需要动态分配 PersistentVolume 时会使用到。</p>
<p>StorageClass 对象的命名很重要，用户使用这个命名来请求生成一个特定的类。 当创建 StorageClass 对象时，管理员设置 StorageClass 对象的命名和其他参数，一旦创建了对象就不能再对其更新。</p>
<p>管理员可以为没有申请绑定到特定 StorageClass 的 PVC 指定一个默认的存储类。</p>
<h3 id="2-1-存储制备器"><a href="#2-1-存储制备器" class="headerlink" title="2.1 存储制备器"></a>2.1 存储制备器</h3><p>每个 StorageClass 都有一个制备器（Provisioner），用来决定使用哪个卷插件制备 PV。 该字段必须指定。</p>
<table>
<thead>
<tr>
<th align="left">卷插件</th>
<th>内置制备器</th>
<th>配置例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AWSElasticBlockStore</td>
<td>✓</td>
<td><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#aws-ebs">AWS EBS</a></td>
</tr>
<tr>
<td align="left">AzureFile</td>
<td>✓</td>
<td>Azure File</td>
</tr>
<tr>
<td align="left">AzureDisk</td>
<td>✓</td>
<td>Azure Disk</td>
</tr>
<tr>
<td align="left">CephFS</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td align="left">Cinder</td>
<td>✓</td>
<td><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#openstack-cinder">OpenStack Cinder</a></td>
</tr>
<tr>
<td align="left">FC</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td align="left">FlexVolume</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td align="left">Flocker</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td align="left">GCEPersistentDisk</td>
<td>✓</td>
<td><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#gce-pd">GCE PD</a></td>
</tr>
<tr>
<td align="left">Glusterfs</td>
<td>✓</td>
<td><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#glusterfs">Glusterfs</a></td>
</tr>
<tr>
<td align="left">iSCSI</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td align="left">Quobyte</td>
<td>✓</td>
<td><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#quobyte">Quobyte</a></td>
</tr>
<tr>
<td align="left">NFS</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td align="left">RBD</td>
<td>✓</td>
<td><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#ceph-rbd">Ceph RBD</a></td>
</tr>
<tr>
<td align="left">VsphereVolume</td>
<td>✓</td>
<td><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#vsphere">vSphere</a></td>
</tr>
<tr>
<td align="left">PortworxVolume</td>
<td>✓</td>
<td>Portworx Volume</td>
</tr>
<tr>
<td align="left">ScaleIO</td>
<td>✓</td>
<td><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#scaleio">ScaleIO</a></td>
</tr>
<tr>
<td align="left">StorageOS</td>
<td>✓</td>
<td><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#storageos">StorageOS</a></td>
</tr>
<tr>
<td align="left">Local</td>
<td>-</td>
<td>Local</td>
</tr>
</tbody></table>
<p>除了列出的 “内置” 制备器（其名称前缀为 “kubernetes.io” 并打包在 Kubernetes 中）。 还可以运行和指定外部制备器，这些独立的程序遵循由 Kubernetes 定义的 规范。 外部供应商的作者完全可以自由决定他们的代码保存于何处、打包方式、运行方式、使用的插件（包括 Flex）等。例如，NFS 没有内部制备器，但可以使用外部制备器。 也有第三方存储供应商提供自己的外部制备器。</p>
<h3 id="2-2-回收策略"><a href="#2-2-回收策略" class="headerlink" title="2.2 回收策略"></a>2.2 回收策略</h3><p>由 StorageClass 动态创建的 PersistentVolume 会在类的 <code>reclaimPolicy</code> 字段中指定回收策略，可以是 Delete 或者 Retain。如果 StorageClass 对象被创建时没有指定 <code>reclaimPolicy</code>，它将默认为 <code>Delete</code>。</p>
<p>通过 <code>StorageClass</code> 手动创建并管理的 <code>PersistentVolume</code> 会使用它们被创建时指定的回收政策。</p>
<h3 id="2-3-允许卷扩展"><a href="#2-3-允许卷扩展" class="headerlink" title="2.3 允许卷扩展"></a>2.3 允许卷扩展</h3><p>PersistentVolume 可以配置为可扩展。将此功能设置为 <code>true</code> 时，允许用户通过编辑相应的 PVC 对象来调整卷大小。</p>
<p>当下层 StorageClass 的 <code>allowVolumeExpansion</code> 字段设置为 true 时，以下类型的卷支持卷扩展。</p>
<table>
<thead>
<tr>
<th>卷类型</th>
<th>Kubernetes 版本要求</th>
</tr>
</thead>
<tbody><tr>
<td>gcePersistentDisk</td>
<td>1.11</td>
</tr>
<tr>
<td>awsElasticBlockStore</td>
<td>1.11</td>
</tr>
<tr>
<td>Cinder</td>
<td>1.11</td>
</tr>
<tr>
<td>glusterfs</td>
<td>1.11</td>
</tr>
<tr>
<td>rbd</td>
<td>1.11</td>
</tr>
<tr>
<td>Azure File</td>
<td>1.11</td>
</tr>
<tr>
<td>Azure Disk</td>
<td>1.11</td>
</tr>
<tr>
<td>Portworx</td>
<td>1.11</td>
</tr>
<tr>
<td>FlexVolume</td>
<td>1.13</td>
</tr>
<tr>
<td>CSI</td>
<td>1.14 (alpha), 1.16 (beta)</td>
</tr>
</tbody></table>
<p><strong>说明： 此功能仅可用于扩容卷，不能用于缩小卷。</strong></p>
<h3 id="2-4-挂载选项"><a href="#2-4-挂载选项" class="headerlink" title="2.4 挂载选项"></a>2.4 挂载选项</h3><p>由 StorageClass 动态创建的 PersistentVolume 将使用类中 <code>mountOptions</code> 字段指定的挂载选项。</p>
<p>如果卷插件不支持挂载选项，却指定了该选项，则制备操作会失败。 挂载选项在 StorageClass 和 PV 上都不会做验证，所以如果挂载选项无效，那么这个 PV 就会失败。</p>
<h3 id="2-5-卷绑定模式"><a href="#2-5-卷绑定模式" class="headerlink" title="2.5 卷绑定模式"></a>2.5 卷绑定模式</h3><p><code>volumeBindingMode</code> 字段控制了卷绑定和动态制备 应该发生在什么时候。</p>
<p>默认情况下，<code>Immediate</code> 模式表示一旦创建了 PersistentVolumeClaim 也就完成了卷绑定和动态制备。 对于由于拓扑限制而非集群所有节点可达的存储后端，PersistentVolume 会在不知道 Pod 调度要求的情况下绑定或者制备。</p>
<p>集群管理员可以通过指定 WaitForFirstConsumer 模式来解决此问题。 该模式将延迟 PersistentVolume 的绑定和制备，直到使用该 PersistentVolumeClaim 的 Pod 被创建。 PersistentVolume 会根据 Pod 调度约束指定的拓扑来选择或制备。这些包括但不限于 资源需求、 节点筛选器、 pod 亲和性和互斥性、 以及污点和容忍度。</p>
<p>以下插件支持动态供应的 <code>WaitForFirstConsumer</code> 模式:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#aws-ebs">AWSElasticBlockStore</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#gce-pd">GCEPersistentDisk</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#azure-disk">AzureDisk</a></li>
</ul>
<p>以下插件支持预创建绑定 PersistentVolume 的 WaitForFirstConsumer 模式：</p>
<ul>
<li>上述全部</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#local">Local</a></li>
</ul>
<h3 id="2-6-允许的拓扑结构"><a href="#2-6-允许的拓扑结构" class="headerlink" title="2.6 允许的拓扑结构"></a>2.6 允许的拓扑结构</h3><p>当集群操作人员使用了 <code>WaitForFirstConsumer</code> 的卷绑定模式， 在大部分情况下就没有必要将制备限制为特定的拓扑结构。 然而，如果还有需要的话，可以使用 <code>allowedTopologies</code>。</p>
<p>这个例子描述了如何将供应卷的拓扑限制在特定的区域，在使用时应该根据插件 支持情况替换 <code>zone</code> 和 <code>zones</code> 参数。</p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span>
<span class="attr">kind:</span> <span class="string">StorageClass</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">standard</span>
<span class="attr">provisioner:</span> <span class="string">kubernetes.io/gce-pd</span>
<span class="attr">parameters:</span>
  <span class="attr">type:</span> <span class="string">pd-standard</span>
<span class="attr">volumeBindingMode:</span> <span class="string">WaitForFirstConsumer</span> <span class="comment"># 指定了卷绑定模式为 WaitForFirstConsumer。</span>
<span class="attr">allowedTopologies:</span> <span class="comment"># 定义了存储卷可以被分配的拓扑范围。</span>
  <span class="bullet">-</span> <span class="attr">matchLabelExpressions:</span> <span class="comment"># 使用标签选择器来限制存储卷的拓扑。</span>
      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">failure-domain.beta.kubernetes.io/zone</span> <span class="comment"># Kubernetes 内置标签，用于表示节点的可用区（Zone）</span>
        <span class="attr">values:</span> <span class="comment"># 限制存储卷只能在 Google Cloud 的 us-central1-a 和 us-central1-b 两个可用区中创建。</span>
          <span class="bullet">-</span> <span class="string">us-central1-a</span>
          <span class="bullet">-</span> <span class="string">us-central1-b</span></code></pre>

<p>这个 StorageClass 配置定义了一个名为 standard 的存储类，适用于 Google Cloud Platform 的 Persistent Disk（GCE PD）存储，磁盘类型为 pd-standard（标准硬盘）。它使用 WaitForFirstConsumer 绑定模式，确保存储卷的分配与 Pod 的调度位置一致，并且限制存储卷只能在 us-central1-a 和 us-central1-b 两个可用区中创建。</p>
<h2 id="3-案例演示"><a href="#3-案例演示" class="headerlink" title="3. 案例演示"></a>3. 案例演示</h2><h3 id="3-1-部署流程"><a href="#3-1-部署流程" class="headerlink" title="3.1 部署流程"></a>3.1 部署流程</h3><p>搭建StorageClass + NFS，大致有以下几个步骤：</p>
<ol>
<li>创建一个可用的 NFS Server</li>
<li>创建 Service Account，这是用来管控 NFS Provisioner 在 k8s 集群中运行的权限</li>
<li>创建 StorageClass，负责建立PVC并调用 NFS provisioner 进行预定的工作，并让 PV 与 PVC 建立关联</li>
<li>创建 NFS provisioner，有两个功能，一个是在NFS共享目录下创建挂载点( volume )，另一个则是建了 PV 并将 PV 与 NFS 的挂载点建立关联</li>
<li>创建 Pod 测试</li>
</ol>
<h3 id="3-2-搭建-NFS-服务"><a href="#3-2-搭建-NFS-服务" class="headerlink" title="3.2 搭建 NFS 服务"></a>3.2 搭建 NFS 服务</h3><p>见 5.5 章节</p>
<h3 id="3-3-创建命名空间"><a href="#3-3-创建命名空间" class="headerlink" title="3.3 创建命名空间"></a>3.3 创建命名空间</h3><p>创建新的命名空间，用于测试</p>
<pre><code class="highlight bash">$ kubectl create ns nfs-storageclass</code></pre>



<h3 id="3-4-创建-Service-Account"><a href="#3-4-创建-Service-Account" class="headerlink" title="3.4 创建 Service Account"></a>3.4 创建 Service Account</h3><h4 id="3-4-1-ServiceAccount"><a href="#3-4-1-ServiceAccount" class="headerlink" title="3.4.1 ServiceAccount"></a>3.4.1 ServiceAccount</h4><p><code>ServiceAccount-01.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">ServiceAccount</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span>
  <span class="attr">namespace:</span> <span class="string">nfs-storageclass</span></code></pre>

<p><strong>解读</strong>：</p>
<ul>
<li><strong>类型</strong>：ServiceAccount 是 Kubernetes 中的一种资源，用于为 Pod 或其他资源提供身份认证。</li>
<li><strong>用途</strong>：这里创建了一个名为 nfs-client-provisioner 的 ServiceAccount，运行在 nfs-storageclass 命名空间中。这个 ServiceAccount 将被后续的 Deployment 使用，允许 NFS 客户端动态配置器（Provisioner）以指定的身份与 Kubernetes API 交互。</li>
<li><strong>命名空间</strong>：nfs-storageclass，表示该 ServiceAccount 仅在该命名空间内有效。</li>
</ul>
<pre><code class="highlight bash"><span class="comment"># 执行资源清单</span>
$ kubectl apply -f ServiceAccount-01.yaml

<span class="comment"># 查看 SA</span>
$ kubectl get sa -n nfs-storageclass
NAME                     SECRETS   AGE
default                  0         3m36s
nfs-client-provisioner   0         20s</code></pre>



<h4 id="3-4-2-ClusterRole"><a href="#3-4-2-ClusterRole" class="headerlink" title="3.4.2 ClusterRole"></a>3.4.2 ClusterRole</h4><p><code>ClusterRole-02.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">kind:</span> <span class="string">ClusterRole</span>
<span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span>
<span class="attr">rules:</span>
  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]
    <span class="attr">resources:</span> [<span class="string">&quot;nodes&quot;</span>]
    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]
  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]
    <span class="attr">resources:</span> [<span class="string">&quot;persistentvolumes&quot;</span>]
    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;delete&quot;</span>]
  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]
    <span class="attr">resources:</span> [<span class="string">&quot;persistentvolumeclaims&quot;</span>]
    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;update&quot;</span>]
  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;storage.k8s.io&quot;</span>]
    <span class="attr">resources:</span> [<span class="string">&quot;storageclasses&quot;</span>]
    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]
  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]
    <span class="attr">resources:</span> [<span class="string">&quot;events&quot;</span>]
    <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>]</code></pre>



<p><strong>解读</strong>：</p>
<ul>
<li><strong>类型</strong>：ClusterRole 是 Kubernetes 的 RBAC（基于角色的访问控制）资源，定义了<strong>集群级别的权限规则</strong>。</li>
<li><strong>apiGroups: [“”]</strong><ul>
<li>空字符串表示核心 API 组（core API group），包含 Kubernetes 的基本资源（如 nodes、pods 等）。</li>
</ul>
</li>
<li>用途：为 nfs-client-provisioner 定义了操作权限，允许其对以下资源执行指定操作：<ul>
<li><strong>Nodes</strong>：获取、列出和监听节点信息（get, list, watch）。</li>
<li>**PersistentVolumes (PV)**：获取、列出、监听、创建和删除持久卷（get, list, watch, create, delete）。</li>
<li>**PersistentVolumeClaims (PVC)**：获取、列出、监听和更新持久卷声明（get, list, watch, update）。</li>
<li><strong>StorageClasses</strong>：获取、列出和监听存储类（get, list, watch）。</li>
<li><strong>Events</strong>：创建、更新和修补事件（create, update, patch），用于记录动态配置过程中的事件。</li>
</ul>
</li>
<li><strong>集群级别</strong>：ClusterRole 的权限是集群范围的，适用于所有命名空间。</li>
</ul>
<pre><code class="highlight bash"><span class="comment"># 执行资源清单</span>
$ kubectl apply -f ClusterRole-02.yaml

<span class="comment"># 查看 集群角色</span>
$ kubectl get ClusterRole -n nfs-storageclass
NAME                                                                   CREATED AT
nfs-client-provisioner-runner                                          2025-05-30T02:12:39Z</code></pre>



<h4 id="3-4-3-ClusterRoleBinding"><a href="#3-4-3-ClusterRoleBinding" class="headerlink" title="3.4.3 ClusterRoleBinding"></a>3.4.3 ClusterRoleBinding</h4><p><code>ClusterRoleBinding-03.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span>
<span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">run-nfs-client-provisioner</span>
<span class="attr">subjects:</span>
  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span> <span class="comment"># 绑定类型 ServiceAccount</span>
    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span> <span class="comment"># ServiceAccount 的名称</span>
    <span class="attr">namespace:</span> <span class="string">nfs-storageclass</span>
<span class="attr">roleRef:</span>
  <span class="attr">kind:</span> <span class="string">ClusterRole</span> <span class="comment"># 绑定的角色类型</span>
  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span> <span class="comment"># 集群角色名称 nfs-client-provisioner-runner</span>
  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></code></pre>

<p><strong>解读</strong>：</p>
<ul>
<li><strong>类型</strong>：ClusterRoleBinding 将 ClusterRole 绑定到特定的主体（Subject）。</li>
<li><strong>用途</strong>：将前面定义的 nfs-client-provisioner-runner ClusterRole 绑定到 nfs-client-provisioner ServiceAccount 上，授予其相应的权限。</li>
<li><strong>主体</strong>：nfs-client-provisioner ServiceAccount，位于 nfs-storageclass 命名空间。</li>
<li><strong>作用</strong>：确保 nfs-client-provisioner ServiceAccount 能够以 ClusterRole 定义的权限操作 Kubernetes 资源。</li>
</ul>
<pre><code class="highlight bash"><span class="comment"># 执行资源清单</span>
$ kubectl apply -f ClusterRoleBinding-03.yaml

<span class="comment"># 查看 集群角色绑定</span>
$ kubectl get ClusterRoleBinding -n nfs-storageclass
NAME                         ROLE                                                              AGE

run-nfs-client-provisioner   ClusterRole/nfs-client-provisioner-runner                         22s</code></pre>



<h4 id="3-4-4-Role"><a href="#3-4-4-Role" class="headerlink" title="3.4.4 Role"></a>3.4.4 Role</h4><p><code>Role-04.yaml</code></p>
<pre><code class="highlight bash">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: leader-locking-nfs-client-provisioner <span class="comment"># 角色的名称，表明它与 NFS 客户端存储提供者的领导者选举（leader election）机制相关。</span>
  namespace: nfs-storageclass
rules:
  - apiGroups: [<span class="string">&quot;&quot;</span>] <span class="comment"># 空字符串表示核心 API 组（core API group），包含 Kubernetes 的基本资源，如 endpoints。</span>
    resources: [<span class="string">&quot;endpoints&quot;</span>]
    verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>]</code></pre>

<p><strong>解读</strong>：</p>
<ul>
<li><strong>类型</strong>：Role 是命名空间级别的 RBAC 资源，定义了特定命名空间内的权限规则。</li>
<li><strong>用途</strong>：为 nfs-client-provisioner 定义了在 nfs-storageclass 命名空间内操作 endpoints 资源的权限，包括获取、列出、监听、创建、更新和修补（get, list, watch, create, update, patch）。</li>
<li><strong>背景</strong>：endpoints 资源通常用于实现领导者选举（Leader Election），确保只有一个 Provisioner 实例在动态配置存储时处于活动状态。</li>
</ul>
<pre><code class="highlight bash"><span class="comment"># 创建角色</span>
$ kubectl apply -f Role-04.yaml

<span class="comment"># 在指定名称空间内查看角色</span>
$ kubectl get Role -n nfs-storageclass
NAME                                    CREATED AT
leader-locking-nfs-client-provisioner   2025-05-30T02:39:47Z</code></pre>



<h4 id="3-4-5-RoleBinding"><a href="#3-4-5-RoleBinding" class="headerlink" title="3.4.5 RoleBinding"></a>3.4.5 RoleBinding</h4><p><code>RoleBinding-05.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">kind:</span> <span class="string">RoleBinding</span>
<span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">run-leader-locking-nfs-client-provisioner</span>
  <span class="attr">namespace:</span> <span class="string">nfs-storageclass</span>
<span class="attr">subjects:</span>
  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span> <span class="comment"># 绑定资源类型为 ServiceAccount</span>
    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span> <span class="comment"># 绑定的ServiceAccount 名称</span>
    <span class="attr">namespace:</span> <span class="string">nfs-storageclass</span>
<span class="attr">roleRef:</span>
  <span class="attr">kind:</span> <span class="string">Role</span> <span class="comment"># 绑定角色（nfs-storageclass名称空间的角色）</span>
  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span>
  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span> <span class="comment"># 角色的名称</span></code></pre>

<p><strong>解读</strong>：</p>
<ul>
<li><strong>类型</strong>：RoleBinding 将 Role 绑定到特定主体。</li>
<li><strong>用途</strong>：将 <code>leader-locking-nfs-client-provisioner</code> Role 绑定到 <code>nfs-client-provisioner</code> ServiceAccount，授予其在 nfs-storageclass 命名空间内操作 endpoints 的权限。</li>
<li><strong>作用</strong>：支持领导者选举机制，确保 NFS 客户端 Provisioner 的高可用性和一致性。</li>
</ul>
<pre><code class="highlight bash"><span class="comment"># 执行角色绑定</span>
$ kubectl apply -f RoleBinding-05.yaml

<span class="comment"># 查看角色绑定详情</span>
$ kubectl get RoleBinding -n nfs-storageclass -o wide
NAME                                        ROLE                                         AGE     USERS   GROUPS   SERVICEACCOUNTS
run-leader-locking-nfs-client-provisioner   Role/leader-locking-nfs-client-provisioner   2m45s                    nfs-storageclass/nfs-client-provisioner</code></pre>



<h4 id="3-4-6-StorageClass"><a href="#3-4-6-StorageClass" class="headerlink" title="3.4.6 StorageClass"></a>3.4.6 StorageClass</h4><p><code>StorageClass-06.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">kind:</span> <span class="string">StorageClass</span>
<span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">nfs-client</span> <span class="comment"># StorageClass 的名称</span>
  <span class="attr">namespace:</span> <span class="string">nfs-storageclass</span>
<span class="attr">provisioner:</span> <span class="string">k8s-sigs.io/nfs-subdir-external-provisioner</span>
<span class="attr">parameters:</span>
  <span class="attr">pathPattern:</span> <span class="string">$&#123;.PVC.namespace&#125;/$&#123;.PVC.name&#125;</span>
  <span class="attr">onDelete:</span> <span class="string">delete</span></code></pre>

<p><strong>解读</strong>：</p>
<ul>
<li><strong>类型</strong>：StorageClass 定义了动态存储配置的模板。</li>
<li><strong>用途</strong>：定义了一个名为 nfs-client 的存储类，位于 nfs-storageclass 命名空间，用于动态创建 NFS 持久卷。</li>
<li>配置：<ul>
<li><strong>provisioner</strong>：指定了动态配置器为 k8s-sigs.io&#x2F;nfs-subdir-external-provisioner，即 NFS 子目录外部配置器。</li>
<li><strong>parameters</strong>：<ul>
<li>pathPattern：动态生成的 NFS 路径，格式为 <code>&lt;PVC 命名空间&gt;/&lt;PVC 名称&gt;</code>，例如 nfs-storageclass&#x2F;test-claim。</li>
<li>onDelete: delete：当 PVC 被删除时，关联的 NFS 存储路径也会被删除。</li>
</ul>
</li>
</ul>
</li>
<li><strong>作用</strong>：当用户创建使用 nfs-client 存储类的 PVC 时，Provisioner 会自动在 NFS 服务器上创建对应的子目录。</li>
</ul>
<pre><code class="highlight bash"><span class="comment"># 创建 StorageClass</span>
$ kubectl apply -f StorageClass-06.yaml

<span class="comment"># 查看 StorageClass</span>
$ kubectl get StorageClass -n nfs-storageclass
NAME         PROVISIONER                                   RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
nfs-client   k8s-sigs.io/nfs-subdir-external-provisioner   Delete          Immediate           <span class="literal">false</span>                  12s</code></pre>



<h4 id="3-4-7-Deployment"><a href="#3-4-7-Deployment" class="headerlink" title="3.4.7 Deployment"></a>3.4.7 Deployment</h4><p><code>Deployment-07.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">kind:</span> <span class="string">Deployment</span>
<span class="attr">apiVersion:</span> <span class="string">apps/v1</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span>
  <span class="attr">namespace:</span> <span class="string">nfs-storageclass</span>
<span class="attr">spec:</span>
  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 3个nfs客户端副本</span>
  <span class="attr">selector:</span>
    <span class="attr">matchLabels:</span>
      <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span>
  <span class="attr">strategy:</span>
    <span class="attr">type:</span> <span class="string">Recreate</span> <span class="comment"># 更新策略为重新创建，即先删除旧 Pod 再创建新 Pod，适合单一实例场景。</span>
  <span class="attr">template:</span>
    <span class="attr">metadata:</span>
      <span class="attr">labels:</span>
        <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span>
    <span class="attr">spec:</span>
      <span class="attr">serviceAccountName:</span> <span class="string">nfs-client-provisioner</span> <span class="comment"># 使用 nfs-client-provisioner ServiceAccount，赋予其 RBAC 权限。</span>
      <span class="attr">containers:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span>
          <span class="attr">image:</span> <span class="string">k8s.dockerproxy.com/sig-storage/nfs-subdir-external-provisioner:v4.0.2</span>
          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
          <span class="attr">volumeMounts:</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span> <span class="comment"># 挂载的卷名称，与 volumes 部分定义的卷对应</span>
              <span class="attr">mountPath:</span> <span class="string">/persistentvolumes</span> <span class="comment"># 将 NFS 卷挂载到容器内的 /persistentvolumes 路径，供容器读写 NFS 共享数据。</span>
          <span class="attr">env:</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROVISIONER_NAME</span>
              <span class="attr">value:</span> <span class="string">k8s-sigs.io/nfs-subdir-external-provisioner</span> <span class="comment"># 指定配置器名称，与 StorageClass 保持一致</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_SERVER</span>
              <span class="attr">value:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.139</span> <span class="comment"># NFS 服务器地址</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_PATH</span>
              <span class="attr">value:</span> <span class="string">/root/data</span> <span class="comment"># NFS 共享路径</span>
      <span class="attr">volumes:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span> <span class="comment"># 挂载卷的名称</span>
          <span class="attr">nfs:</span>
            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.139</span>
            <span class="attr">path:</span> <span class="string">/root/data</span></code></pre>

<p><strong>解读</strong>：</p>
<ul>
<li><strong>类型</strong>：Deployment 用于管理 Pod 的部署和运行。</li>
<li><strong>用途</strong>：部署 NFS 客户端 Provisioner，确保动态存储配置服务运行。</li>
<li><strong>配置</strong>：<ul>
<li><strong>replicas: 3</strong>：运行3个 Pod 副本。</li>
<li><strong>strategy: Recreate</strong>：更新策略为重新创建，即先删除旧 Pod 再创建新 Pod，适合单一实例场景。</li>
<li><strong>serviceAccountName</strong>：使用 nfs-client-provisioner ServiceAccount，赋予其 RBAC 权限。</li>
<li><strong>容器</strong>：<ul>
<li><strong>镜像</strong>：k8s.dockerproxy.com&#x2F;sig-storage&#x2F;nfs-subdir-external-provisioner:v4.0.2，NFS 子目录外部配置器的镜像。</li>
<li><strong>volumeMounts</strong>：将 NFS 卷挂载到容器内路径 &#x2F;persistentvolumes。</li>
<li><strong>环境变量</strong>：<ul>
<li>PROVISIONER_NAME：指定配置器名称，与 StorageClass 保持一致。</li>
<li>NFS_SERVER：NFS 服务器地址（192.168.66.11）。</li>
<li>NFS_PATH：NFS 共享路径（&#x2F;root&#x2F;data）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>volumes</strong>：定义了一个 NFS 卷，连接到 NFS 服务器 192.168.6.139 的 &#x2F;root&#x2F;data 路径。</li>
</ul>
</li>
<li><strong>作用</strong>：运行 NFS Provisioner，监听 PVC 请求并动态创建 NFS 子目录。</li>
</ul>
<pre><code class="highlight bash"><span class="comment"># 执行资源清单，部署 NFS 客户端 Provisioner</span>
$ kubectl apply -f Deployment-07.yaml

<span class="comment"># 查看 Deployment 控制器</span>
$ kubectl get deployment -n nfs-storageclass
NAME                     READY   UP-TO-DATE   AVAILABLE   AGE
nfs-client-provisioner   3/3     3            3           5s

<span class="comment"># 查看Pod</span>
$ kubectl get pods -o wide -n nfs-storageclass
NAME                                      READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES
nfs-client-provisioner-5896c4d9d4-8cqwm   1/1     Running   0          18s   172.16.58.193   k8s-node02   &lt;none&gt;           &lt;none&gt;
nfs-client-provisioner-5896c4d9d4-8wnnm   1/1     Running   0          18s   172.16.85.205   k8s-node01   &lt;none&gt;           &lt;none&gt;
nfs-client-provisioner-5896c4d9d4-nds6r   1/1     Running   0          18s   172.16.58.204   k8s-node02   &lt;none&gt;           &lt;none&gt;</code></pre>



<h4 id="3-4-8-PersistentVolumeClaim-PVC"><a href="#3-4-8-PersistentVolumeClaim-PVC" class="headerlink" title="3.4.8 PersistentVolumeClaim (PVC)"></a>3.4.8 PersistentVolumeClaim (PVC)</h4><p><code>PersistentVolumeClaim-08.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">test-claim</span>
  <span class="attr">annotations:</span> <span class="comment"># 注解部分为空（annotations: ），通常用于存储非关键的元数据信息（如描述、工具标记等）</span>
<span class="attr">spec:</span>
  <span class="attr">accessModes:</span>
    <span class="bullet">-</span> <span class="string">ReadWriteMany</span>
  <span class="attr">resources:</span>
    <span class="attr">requests:</span>
      <span class="attr">storage:</span> <span class="string">1Mi</span> <span class="comment"># 请求 1MiB 的存储空间（实际存储大小由 NFS 服务器控制）</span>
  <span class="attr">storageClassName:</span> <span class="string">nfs-client</span> <span class="comment"># StorageClass(存储类) 的名称</span></code></pre>

<p><strong>解读</strong>：</p>
<ul>
<li><strong>类型</strong>：PersistentVolumeClaim 是用户请求存储资源的声明。</li>
<li><strong>用途</strong>：定义一个名为 test-claim 的 PVC，请求使用 nfs-client 存储类动态分配存储。</li>
<li><strong>配置</strong>：<ul>
<li><strong>accessModes: ReadWriteMany</strong>：支持多个节点读写访问（适合 NFS 的共享存储特性）。</li>
<li><strong>resources.requests.storage: 1Mi</strong>：请求 1MiB 的存储空间（实际存储大小由 NFS 服务器控制）。</li>
<li><strong>storageClassName: nfs-client</strong>：指定使用 nfs-client 存储类。</li>
</ul>
</li>
<li><strong>作用</strong>：触发 NFS Provisioner 创建一个对应的 PV，并分配 NFS 服务器上的子目录（路径为 nfs-storageclass&#x2F;test-claim）。</li>
</ul>
<p>注意：PVC的资源清单没有指定命名空间，当执行资源清单时会在 default 命名空间下创建一个目录，后续会更新 Pod 所在命名空间，自动创建对应的目录。</p>
<pre><code class="highlight bash"><span class="comment"># 创建PVC</span>
$ kubectl apply -f PersistentVolumeClaim-08.yaml

<span class="comment"># 指定 命名空间查看 PVC</span>
$ kubectl get pvc -o wide -n nfs-storageclass
NAME         STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE   VOLUMEMODE
test-claim   Bound    pvc-3b195b57-522a-49c5-badc-32e07fd37f88   1Mi        RWX            nfs-client     &lt;<span class="built_in">unset</span>&gt;                 15s   Filesystem

<span class="comment"># 查看 PVC 自动创建的目录， 按照存储类定义的路径格式：$&#123;.PVC.namespace&#125;/$&#123;.PVC.name&#125;</span>
$ ll /root/data/nfs-storageclass/
total 0
drwxrwxrwx 2 root root 6 May 30 17:12 test-claim</code></pre>



<h4 id="3-4-9-测试-Pod"><a href="#3-4-9-测试-Pod" class="headerlink" title="3.4.9 测试 Pod"></a>3.4.9 测试 Pod</h4><p><code>test-pod-09.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">kind:</span> <span class="string">Pod</span>
<span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">test-pod</span>
  <span class="attr">namespace:</span> <span class="string">nfs-storageclass</span>
<span class="attr">spec:</span>
  <span class="attr">containers:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-pod</span>
      <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>
      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
      <span class="attr">volumeMounts:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-pvc</span> <span class="comment"># 使用的挂在卷名</span>
          <span class="attr">mountPath:</span> <span class="string">/usr/local/nginx/html</span> <span class="comment"># 挂载到容器内的路径</span>
  <span class="attr">volumes:</span>
    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-pvc</span> <span class="comment"># 挂在卷名</span>
      <span class="attr">persistentVolumeClaim:</span>
        <span class="attr">claimName:</span> <span class="string">test-claim</span> <span class="comment"># 使用的PVC名称</span></code></pre>



<p><strong>创建Pod，测试存储类</strong></p>
<pre><code class="highlight bash"><span class="comment"># 执行资源清单，创建Pod</span>
$ kubectl apply -f test-pod-09.yaml

<span class="comment"># 查看Pod列表</span>
$ kubectl get pods -o wide -n nfs-storageclass
NAME                                      READY   STATUS    RESTARTS   AGE   IP              NODE         NOMINATED NODE   READINESS GATES
nfs-client-provisioner-5896c4d9d4-8cqwm   1/1     Running   0          37m   172.16.58.193   k8s-node02   &lt;none&gt;           &lt;none&gt;
nfs-client-provisioner-5896c4d9d4-8wnnm   1/1     Running   0          37m   172.16.85.205   k8s-node01   &lt;none&gt;           &lt;none&gt;
nfs-client-provisioner-5896c4d9d4-nds6r   1/1     Running   0          37m   172.16.58.204   k8s-node02   &lt;none&gt;           &lt;none&gt;
test-pod                                  1/1     Running   0          36s   172.16.58.249   k8s-node02   &lt;none&gt;           &lt;none&gt;

<span class="comment"># 测试文件到PVC挂载目录</span>
$ <span class="built_in">echo</span> <span class="string">&quot;hello test pod&quot;</span> &gt;&gt; /root/data/nfs-storageclass/test-claim/index.html

<span class="comment"># 访问Pod</span>
$ curl 172.16.58.249
hello <span class="built_in">test</span> pod</code></pre>



<h4 id="3-4-10-测试-Service"><a href="#3-4-10-测试-Service" class="headerlink" title="3.4.10 测试 Service"></a>3.4.10 测试 Service</h4><p><code>test-sts-pod-10.yaml</code></p>
<pre><code class="highlight yaml"><span class="attr">apiVersion:</span> <span class="string">v1</span>
<span class="attr">kind:</span> <span class="string">Service</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 服务的名称为 nginx</span>
  <span class="attr">namespace:</span> <span class="string">nfs-storageclass</span>
  <span class="attr">labels:</span>
    <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># 给服务打一个标签</span>
<span class="attr">spec:</span>
  <span class="attr">ports:</span> <span class="comment"># 指定服务暴露的端口</span>
    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 服务监听在 80 端口，外部请求通过该端口访问</span>
  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 设置为 None，表示这是一个 Headless Service。Headless Service 不会分配集群 IP，而是直接通过 DNS 解析到后端的 Pod。</span>
  <span class="attr">selector:</span>
    <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># 服务通过标签选择器 app: nginx 找到匹配的 Pod，将流量路由到这些 Pod。</span>

<span class="meta">---</span>
<span class="meta"></span>
<span class="attr">apiVersion:</span> <span class="string">apps/v1</span>
<span class="attr">kind:</span> <span class="string">StatefulSet</span>
<span class="attr">metadata:</span>
  <span class="attr">name:</span> <span class="string">web</span> <span class="comment"># StatefulSet 名称为 web，用于管理一组 Pod。</span>
  <span class="attr">namespace:</span> <span class="string">nfs-storageclass</span>
<span class="attr">spec:</span>
  <span class="attr">selector:</span>
    <span class="attr">matchLabels:</span> <span class="comment"># 通过标签 app: nginx 选择要管理的 Pod，确保 StatefulSet 只控制带有该标签的 Pod。</span>
      <span class="attr">app:</span> <span class="string">nginx</span>
  <span class="attr">serviceName:</span> <span class="string">nginx</span> <span class="comment"># 指定关联的 Service 的名称为 nginx， StatefulSet 使用此 Service 来为每个 Pod 提供稳定的 DNS 名称（例如 web-0.nginx.default.svc.cluster.local）</span>
  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 创建 3 个 Pod 副本，分别命名为 web-0、web-1 和 web-2</span>
  <span class="attr">template:</span>
    <span class="attr">metadata:</span>
      <span class="attr">labels:</span> <span class="comment"># 为 Pod 添加标签 app: nginx，与 Service 的选择器匹配。</span>
        <span class="attr">app:</span> <span class="string">nginx</span>
    <span class="attr">spec:</span>
      <span class="attr">containers:</span>
        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>
          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v1.0</span>
          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>
          <span class="attr">ports:</span>
            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>
              <span class="attr">name:</span> <span class="string">web</span>
          <span class="attr">volumeMounts:</span>
            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span> <span class="comment"># 挂载的卷名称为 www</span>
              <span class="attr">mountPath:</span> <span class="string">/usr/local/nginx/html</span>
  <span class="attr">volumeClaimTemplates:</span>
    <span class="bullet">-</span> <span class="attr">metadata:</span>
        <span class="attr">name:</span> <span class="string">www</span> <span class="comment"># PVC 名称为 www，与 volumeMounts 中的名称对应</span>
      <span class="attr">spec:</span>
        <span class="attr">accessModes:</span>
          <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>
        <span class="attr">storageClassName:</span> <span class="string">nfs-client</span> <span class="comment"># StorageClass(存储类) 的名称</span>
        <span class="attr">resources:</span>
          <span class="attr">requests:</span>
            <span class="attr">storage:</span> <span class="string">1Gi</span></code></pre>



<p><strong>执行资源清单，测试Service</strong></p>
<pre><code class="highlight bash"><span class="comment"># 执行资源清单</span>
$ kubectl apply -f test-sts-pod-10.yaml

<span class="comment"># 查看 Service</span>
$ kubectl get svc -o wide -n nfs-storageclass
NAME    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTOR
nginx   ClusterIP   None         &lt;none&gt;        80/TCP    30s   app=nginx

<span class="comment"># 查看 StatefulSet 控制器</span>
$ kubectl get sts -o wide -n nfs-storageclass
NAME   READY   AGE   CONTAINERS   IMAGES
web    3/3     40s   nginx        wangyanglinux/myapp:v1.0

<span class="comment"># 查看 Pod</span>
$ kubectl get pods -o wide -n nfs-storageclass
NAME                                      READY   STATUS    RESTARTS   AGE     IP              NODE         NOMINATED NODE   READINESS GATES
nfs-client-provisioner-5896c4d9d4-8cqwm   1/1     Running   0          43m     172.16.58.193   k8s-node02   &lt;none&gt;           &lt;none&gt;
nfs-client-provisioner-5896c4d9d4-8wnnm   1/1     Running   0          43m     172.16.85.205   k8s-node01   &lt;none&gt;           &lt;none&gt;
nfs-client-provisioner-5896c4d9d4-nds6r   1/1     Running   0          43m     172.16.58.204   k8s-node02   &lt;none&gt;           &lt;none&gt;
test-pod                                  1/1     Running   0          6m54s   172.16.58.249   k8s-node02   &lt;none&gt;           &lt;none&gt;
web-0                                     1/1     Running   0          58s     172.16.85.204   k8s-node01   &lt;none&gt;           &lt;none&gt;
web-1                                     1/1     Running   0          55s     172.16.58.245   k8s-node02   &lt;none&gt;           &lt;none&gt;
web-2                                     1/1     Running   0          52s     172.16.85.209   k8s-node01   &lt;none&gt;           &lt;none&gt;

<span class="comment"># 查看 PV</span>
$ kubectl get pv -o wide -n nfs-storageclass
NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                         STORAGECLASS   VOLUMEATTRIBUTESCLASS   REASON   AGE     VOLUMEMODE
pvc-3b195b57-522a-49c5-badc-32e07fd37f88   1Mi        RWX            Delete           Bound    nfs-storageclass/test-claim   nfs-client     &lt;<span class="built_in">unset</span>&gt;                          17m     Filesystem
pvc-42a8b9df-f53d-4cd4-92e4-47c46ea07e17   1Gi        RWO            Delete           Bound    nfs-storageclass/www-web-2    nfs-client     &lt;<span class="built_in">unset</span>&gt;                          69s     Filesystem
pvc-8a8cefe1-00f1-4639-a1d4-d72e616b084b   1Gi        RWO            Delete           Bound    nfs-storageclass/www-web-1    nfs-client     &lt;<span class="built_in">unset</span>&gt;                          72s     Filesystem
pvc-be68e955-0d6c-4f4b-8422-2158a89a833b   1Gi        RWO            Delete           Bound    nfs-storageclass/www-web-0    nfs-client     &lt;<span class="built_in">unset</span>&gt;                          75s     Filesystem

<span class="comment"># 查看PVC</span>
$ kubectl get pvc -o wide -n nfs-storageclass
NAME         STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE   VOLUMEMODE
test-claim   Bound    pvc-3b195b57-522a-49c5-badc-32e07fd37f88   1Mi        RWX            nfs-client     &lt;<span class="built_in">unset</span>&gt;                 18m   Filesystem
www-web-0    Bound    pvc-be68e955-0d6c-4f4b-8422-2158a89a833b   1Gi        RWO            nfs-client     &lt;<span class="built_in">unset</span>&gt;                 92s   Filesystem
www-web-1    Bound    pvc-8a8cefe1-00f1-4639-a1d4-d72e616b084b   1Gi        RWO            nfs-client     &lt;<span class="built_in">unset</span>&gt;                 89s   Filesystem
www-web-2    Bound    pvc-42a8b9df-f53d-4cd4-92e4-47c46ea07e17   1Gi        RWO            nfs-client     &lt;<span class="built_in">unset</span>&gt;                 86s   Filesystem

<span class="comment"># 查看存储类</span>
$ kubectl get storageclass -n nfs-storageclass
NAME         PROVISIONER                                   RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
nfs-client   k8s-sigs.io/nfs-subdir-external-provisioner   Delete          Immediate           <span class="literal">false</span>                  6h18m

<span class="comment"># 查看PVC自动创建的目录</span>
$ ll /root/data/nfs-storageclass/
total 0
drwxrwxrwx 2 root root 45 May 30 17:23 test-claim
drwxrwxrwx 2 root root 27 May 30 17:28 www-web-0
drwxrwxrwx 2 root root 27 May 30 17:28 www-web-1
drwxrwxrwx 2 root root 27 May 30 17:28 www-web-2

<span class="comment"># 测试文件到PVC挂载目录</span>
$ <span class="built_in">echo</span> <span class="string">&quot;hello test svc pod&quot;</span> &gt;&gt; /root/data/nfs-storageclass/www-web-0/index.html

<span class="comment"># 访问Pod</span>
$ curl 172.16.85.204
hello <span class="built_in">test</span> svc pod

<span class="comment"># 进入Pod测试</span>
$ kubectl <span class="built_in">exec</span> -it web-0 -n nfs-storageclass -- /bin/bash
web-0:/<span class="comment"># curl web-0.nginx.nfs-storageclass.svc.cluster.local.</span>
hello <span class="built_in">test</span> svc pod</code></pre>





<p><strong>参考链接</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/timelesszhuang/p/k8s.html">https://www.cnblogs.com/timelesszhuang/p/k8s.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhanglianghhh/p/13818190.html">https://www.cnblogs.com/zhanglianghhh/p/13818190.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhanglianghhh/p/13743024.html">https://www.cnblogs.com/zhanglianghhh/p/13743024.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengjian2016/p/13337686.html">https://www.cnblogs.com/fengjian2016/p/13337686.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhanglianghhh/p/13844062.html">https://www.cnblogs.com/zhanglianghhh/p/13844062.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhanglianghhh/p/13861817.html">https://www.cnblogs.com/zhanglianghhh/p/13861817.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41947378/article/details/111509849">https://blog.csdn.net/weixin_41947378/article/details/111509849</a></p>
</blockquote>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 george_95@126.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'f820fe811764cacedc4f',
            clientSecret: '0ce07abb65f0e79ddb8830f32029b8a9656e0ee0',
            repo: 'georgechan95.github.io',
            owner: 'GeorgeChan95',
            admin: ['GeorgeChan95'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('15',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 George
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
