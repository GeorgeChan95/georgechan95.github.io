<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>第四章-虚拟机栈 | George&#39;s Blog</title>
  <meta name="google-site-verification" content="RobLWkyyFziZxPJ4I887QROdX8XrYthcJwWTcuH0wwQ" />
  <meta name="msvalidate.01" content="626D541C48E5D151F52CECC2C6714BD4" />
  <meta name="360-site-verification" content="c838adf8357ca2f614d08ad5235a1717" />
  <meta name="keywords" content=" java , jvm ">
  <meta name="description" content="第四章-虚拟机栈 | George&#39;s Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="个人简介目前人在合肥，从事后端开发工作。 联系方式 邮箱：&#x67;&#x65;&#111;&#114;&#103;&#x65;&#x5f;&#x39;&#53;&#64;&#49;&#x32;&#x36;&#x2e;&#99;&#x6f;&#x6d;  邮件可能几天才看一次，如有联系，请耐心等待。">
<meta property="og:type" content="website">
<meta property="og:title" content="关于">
<meta property="og:url" content="https://georgechan95.github.io/about/index.html">
<meta property="og:site_name" content="George&#39;s Blog">
<meta property="og:description" content="个人简介目前人在合肥，从事后端开发工作。 联系方式 邮箱：&#x67;&#x65;&#111;&#114;&#103;&#x65;&#x5f;&#x39;&#53;&#64;&#49;&#x32;&#x36;&#x2e;&#99;&#x6f;&#x6d;  邮件可能几天才看一次，如有联系，请耐心等待。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-21T02:29:45.000Z">
<meta property="article:modified_time" content="2024-06-22T10:36:12.823Z">
<meta property="article:author" content="George">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/favicon.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="George's Blog" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>George</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/GeorgeChan95"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:george_95@126.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(63)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Hexo">
            <i class="fold iconfont icon-right"></i>
            Hexo
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Hexo&lt;---&gt;Typora">
            
            Typora
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JUC">
            
            JUC
            <small>(23)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JVM">
            
            JVM
            <small>(27)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="linux">
            
            linux
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="neo4j">
            
            neo4j
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">关于</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="63">
<input type="hidden" id="yelog_site_word_count" value="298.3k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>插入排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二分法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二进制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>合并有序链表</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>链表</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>冒泡排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>双亲委派机制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>位运算</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>选择排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github pages</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jenkins</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>juc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jvm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>neo4j</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>sitemap</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>typora</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ubuntu18</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 neo4j "
           href="/blog/5c93903a.html"
           data-tag="linux,neo4j"
           data-author="" >
            <span class="post-title" title="Docker部署Neo4j并导入CSV数据">Docker部署Neo4j并导入CSV数据</span>
            <span class="post-date" title="2024-10-17 15:00:30">2024/10/17</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/ad38e6b1.html"
           data-tag="linux,ubuntu18"
           data-author="" >
            <span class="post-title" title="Ubuntu18.04离线源环境搭建">Ubuntu18.04离线源环境搭建</span>
            <span class="post-date" title="2024-10-17 09:47:33">2024/10/17</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3fdbf0f6.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="12-JUC进阶-从ReentrantLock到AQS源码详解">12-JUC进阶-从ReentrantLock到AQS源码详解</span>
            <span class="post-date" title="2024-10-15 19:42:07">2024/10/15</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3e0d7592.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="11-JUC进阶-Synchronized与锁升级">11-JUC进阶-Synchronized与锁升级</span>
            <span class="post-date" title="2024-10-06 09:28:00">2024/10/06</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4502cffa.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="10-JUC进阶-Java对象内存布局和对象头">10-JUC进阶-Java对象内存布局和对象头</span>
            <span class="post-date" title="2024-10-04 09:54:40">2024/10/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4de6a39b.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="09-JUC进阶-ThreadLocal">09-JUC进阶-ThreadLocal</span>
            <span class="post-date" title="2024-10-01 20:39:10">2024/10/01</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/72329cf5.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="08-JUC进阶-常用的原子操作类(18个)">08-JUC进阶-常用的原子操作类(18个)</span>
            <span class="post-date" title="2024-09-28 13:37:09">2024/09/28</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/5e3757c1.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="07-JUC进阶-CAS">07-JUC进阶-CAS</span>
            <span class="post-date" title="2024-09-26 19:37:00">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/546d628d.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="06-JUC进阶-Volatile与Java内存模型">06-JUC进阶-Volatile与Java内存模型</span>
            <span class="post-date" title="2024-09-25 19:01:01">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/1f2e0014.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="05-JUC进阶-Java内存模型-JMM">05-JUC进阶-Java内存模型-JMM</span>
            <span class="post-date" title="2024-09-23 23:01:07">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/19653fb9.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="04-JUC进阶-LockSupport与线程中断">04-JUC进阶-LockSupport与线程中断</span>
            <span class="post-date" title="2024-09-23 20:51:50">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/219e52ea.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="03-JUC进阶-Java中的锁的解析">03-JUC进阶-Java中的锁的解析</span>
            <span class="post-date" title="2024-09-21 14:15:20">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/7e2d78eb.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="02-JUC进阶-CompletableFuture">02-JUC进阶-CompletableFuture</span>
            <span class="post-date" title="2024-09-18 22:50:00">2024/09/18</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3d102971.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="01-JUC进阶-线程基础">01-JUC进阶-线程基础</span>
            <span class="post-date" title="2024-09-18 22:32:00">2024/09/18</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/37d56d14.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="11-CompletableFuture">11-CompletableFuture</span>
            <span class="post-date" title="2024-09-16 16:12:00">2024/09/16</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/31919959.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="10-Fork/Join">10-Fork/Join</span>
            <span class="post-date" title="2024-09-16 13:10:00">2024/09/16</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/a0197c15.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="09-ThreadPool-线程池">09-ThreadPool-线程池</span>
            <span class="post-date" title="2024-09-13 20:10:08">2024/09/13</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/a6760d1f.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="08-阻塞队列BlockingQueue">08-阻塞队列BlockingQueue</span>
            <span class="post-date" title="2024-09-07 17:30:00">2024/09/07</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/838e7581.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore">07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore</span>
            <span class="post-date" title="2024-09-07 13:00:00">2024/09/07</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/f60e37c5.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="06-Callable &amp; Future 接口">06-Callable &amp; Future 接口</span>
            <span class="post-date" title="2024-09-06 22:10:00">2024/09/06</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/f184587f.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="05-公平锁和非公平锁，死锁，可重入锁">05-公平锁和非公平锁，死锁，可重入锁</span>
            <span class="post-date" title="2024-09-05 20:12:00">2024/09/05</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/9a09d992.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="04-集合的线程安全">04-集合的线程安全</span>
            <span class="post-date" title="2024-09-04 21:09:05">2024/09/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/bd2134da.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="03-线程间通信">03-线程间通信</span>
            <span class="post-date" title="2024-09-04 20:06:00">2024/09/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/850dac3c.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="02-Lock接口">02-Lock接口</span>
            <span class="post-date" title="2024-08-30 19:27:00">2024/08/30</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4e6bd685.html"
           data-tag="juc,java"
           data-author="" >
            <span class="post-title" title="01-多线程的基本概念">01-多线程的基本概念</span>
            <span class="post-date" title="2024-08-30 19:03:01">2024/08/30</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1b0522f4.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十五章-分析GC日志">第二十五章-分析GC日志</span>
            <span class="post-date" title="2024-08-28 21:36:08">2024/08/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/944806143.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十四章-JVM运行时参数">第二十四章-JVM运行时参数</span>
            <span class="post-date" title="2024-08-27 18:30:10">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/490498600.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-使用OQL语言查询对象信息">第二十三章-使用OQL语言查询对象信息</span>
            <span class="post-date" title="2024-08-24 15:02:10">2024/08/24</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1471620196.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-浅堆-深堆-内存泄漏">第二十三章-浅堆-深堆-内存泄漏</span>
            <span class="post-date" title="2024-08-24 13:04:37">2024/08/24</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/971417975.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-JVM监控及诊断工具-GUI篇">第二十三章-JVM监控及诊断工具-GUI篇</span>
            <span class="post-date" title="2024-08-16 21:00:00">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2165702380.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十二章-JVM监控及诊断工具-命令行篇">第二十二章-JVM监控及诊断工具-命令行篇</span>
            <span class="post-date" title="2024-08-12 19:36:32">2024/08/12</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2681163762.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十一章-性能监控与调优概述">第二十一章-性能监控与调优概述</span>
            <span class="post-date" title="2024-08-12 19:13:06">2024/08/12</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3537043756.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十章-再谈类的加载器">第二十章-再谈类的加载器</span>
            <span class="post-date" title="2024-08-10 13:43:10">2024/08/10</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3387211378.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十九章-类的加载过程详解">第十九章-类的加载过程详解</span>
            <span class="post-date" title="2024-08-02 19:33:27">2024/08/02</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1107503247.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十八章-字节码指令集与解析指令">第十八章-字节码指令集与解析指令</span>
            <span class="post-date" title="2024-08-01 01:40:02">2024/08/01</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2772873157.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十七章-使用javap指令解析class文件">第十七章-使用javap指令解析class文件</span>
            <span class="post-date" title="2024-07-22 23:54:00">2024/07/22</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/143162370.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十六章-Class文件结构">第十六章-Class文件结构</span>
            <span class="post-date" title="2024-07-15 19:54:50">2024/07/15</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/309245330.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十五章-GC日志分析">第十五章-GC日志分析</span>
            <span class="post-date" title="2024-07-13 08:34:00">2024/07/13</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1750792302.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十四章-垃圾收集器">第十四章-垃圾收集器</span>
            <span class="post-date" title="2024-07-10 19:27:00">2024/07/10</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/484946532.html"
           data-tag="算法,合并有序链表"
           data-author="" >
            <span class="post-title" title="合并两个有序链表">合并两个有序链表</span>
            <span class="post-date" title="2024-07-06 09:11:00">2024/07/06</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2929260443.html"
           data-tag="算法,链表"
           data-author="" >
            <span class="post-title" title="链表反转">链表反转</span>
            <span class="post-date" title="2024-07-05 19:45:45">2024/07/05</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/1403776474.html"
           data-tag="算法,选择排序,冒泡排序,插入排序"
           data-author="" >
            <span class="post-title" title="选择-冒泡-插入排序">选择-冒泡-插入排序</span>
            <span class="post-date" title="2024-07-03 11:02:16">2024/07/03</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2561891005.html"
           data-tag="算法,二分法"
           data-author="" >
            <span class="post-title" title="二分搜索">二分搜索</span>
            <span class="post-date" title="2024-06-29 10:04:10">2024/06/29</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2224151177.html"
           data-tag="算法,二进制,位运算"
           data-author="" >
            <span class="post-title" title="二进制和位运算">二进制和位运算</span>
            <span class="post-date" title="2024-06-20 08:04:00">2024/06/20</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2105268063.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十三章-垃圾回收相关概念">第十三章-垃圾回收相关概念</span>
            <span class="post-date" title="2024-01-14 14:27:00">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/364508352.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十二章-垃圾回收概述和相关算法">第十二章-垃圾回收概述和相关算法</span>
            <span class="post-date" title="2024-01-06 16:28:00">2024/01/06</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/2050535563.html"
           data-tag="linux,jenkins"
           data-author="" >
            <span class="post-title" title="Jenkins的安装和搭建自动化部署平台">Jenkins的安装和搭建自动化部署平台</span>
            <span class="post-date" title="2024-01-05 16:00:00">2024/01/05</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2388209687.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十一章-StringTable(字符串常量池)">第十一章-StringTable(字符串常量池)</span>
            <span class="post-date" title="2023-12-25 17:27:06">2023/12/25</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3385856233.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十章-执行引擎">第十章-执行引擎</span>
            <span class="post-date" title="2023-12-23 20:03:00">2023/12/23</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/4075763684.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第九章-对象的实例化内存布局与访问定位">第九章-对象的实例化内存布局与访问定位</span>
            <span class="post-date" title="2023-12-21 11:50:00">2023/12/21</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3720767522.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第八章-直接内存">第八章-直接内存</span>
            <span class="post-date" title="2023-12-20 17:03:00">2023/12/20</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/105864584.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第七章-方法区">第七章-方法区</span>
            <span class="post-date" title="2023-12-14 18:24:00">2023/12/14</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/543408063.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第六章-JVM堆">第六章-JVM堆</span>
            <span class="post-date" title="2023-12-02 08:01:00">2023/12/02</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/554039338.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第五章-本地方法接口">第五章-本地方法接口</span>
            <span class="post-date" title="2023-11-30 17:55:00">2023/11/30</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1123461525.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第四章-虚拟机栈">第四章-虚拟机栈</span>
            <span class="post-date" title="2023-11-28 20:55:00">2023/11/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1626061462.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第三章-运行时数据区">第三章-运行时数据区</span>
            <span class="post-date" title="2023-11-28 19:31:00">2023/11/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/222077543.html"
           data-tag="java,jvm,双亲委派机制"
           data-author="" >
            <span class="post-title" title="第二章-JVM类加载子系统">第二章-JVM类加载子系统</span>
            <span class="post-date" title="2023-11-25 14:35:00">2023/11/25</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1897413233.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第一章-JVM和Java体系结构">第一章-JVM和Java体系结构</span>
            <span class="post-date" title="2023-11-25 10:00:00">2023/11/25</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/4179015178.html"
           data-tag="hexo,github pages,sitemap"
           data-author="" >
            <span class="post-title" title="给博客网站添加站点地图-sitemap">给博客网站添加站点地图-sitemap</span>
            <span class="post-date" title="2023-11-21 20:00:00">2023/11/21</span>
        </a>
        
        
        <a  class="全部文章 Hexo Typora "
           href="/blog/877664098.html"
           data-tag="hexo,typora,github"
           data-author="" >
            <span class="post-title" title="Typora设置图片自动上传Github">Typora设置图片自动上传Github</span>
            <span class="post-date" title="2023-11-20 20:30:00">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/3069199997.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="Hexo主题常用配置">Hexo主题常用配置</span>
            <span class="post-date" title="2023-11-20 00:00:01">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/2016918085.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="Hexo博客安装主题">Hexo博客安装主题</span>
            <span class="post-date" title="2023-11-20 00:00:01">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/3070587776.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="基于Hexo和Github Pages搭建个人博客">基于Hexo和Github Pages搭建个人博客</span>
            <span class="post-date" title="2023-11-18 15:40:20">2023/11/18</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-jvm/第四章-虚拟机栈" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">第四章-虚拟机栈</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="JVM">JVM</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">java</a>
            
            <a class="color4">jvm</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-08-28 12:17:33'>2023-11-28 20:55</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:10.7k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83"><span class="toc-text">环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">一、简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E5%87%BA%E7%8E%B0%E8%83%8C%E6%99%AF"><span class="toc-text">1. 虚拟机栈的出现背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E5%A0%86"><span class="toc-text">2. 内存中的栈与堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="toc-text">3. 虚拟机栈基本内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">4. 虚拟机栈的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-text">5. 虚拟机栈的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%AE%BE%E7%BD%AE%E6%A0%88%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-text">6. 设置栈内存大小</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="toc-text">二、栈的存储单位</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1. 栈中存储什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">2. 栈运行原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">3. 栈帧的内部结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-text">三、局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-text">1. 认识局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.2 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%83%A8%E5%88%86%E8%AF%A6%E8%A7%A3"><span class="toc-text">1.3 部分详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bytecode"><span class="toc-text">Bytecode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exception-Table"><span class="toc-text">Exception Table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Misc"><span class="toc-text">Misc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LineNumberTable"><span class="toc-text">LineNumberTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalVariableTable"><span class="toc-text">LocalVariableTable</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E4%BA%8ESlot%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">2. 关于Slot的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.1 代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Slot%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8"><span class="toc-text">2.2 Slot的重复利用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">3. 静态变量与局部变量的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">3.1 变量的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%80%BB%E7%BB%93"><span class="toc-text">3.2 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">3.3 补充说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-text">四、操作数栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1. 操作数栈的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2. 操作数栈的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA"><span class="toc-text">3. 操作数栈代码追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">具体执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">4. 常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%85%B3%E4%BA%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">4.1 关于类型转换的说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%96%B9%E6%B3%95%E5%B8%A6%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">4.2 方法带有返回值</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-text">五、栈顶缓存技术</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">六、动态链接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-text">七、方法的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">1. 静态链接与动态链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%97%A9%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8E%E6%99%9A%E6%9C%9F%E7%BB%91%E5%AE%9A"><span class="toc-text">2. 早期绑定与晚期绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BB%91%E5%AE%9A"><span class="toc-text">3. 多态与绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%99%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-text">3.1 虚方法与非虚方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">虚方法与非虚方法的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="toc-text">多态的使用前提</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-text">虚拟机中调用方法的指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B3%E4%BA%8E-invokedynamic-%E6%8C%87%E4%BB%A4"><span class="toc-text">3.2 关于 invokedynamic 指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E5%92%8C%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80"><span class="toc-text">4. 动态语言和静态语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Java%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">5. Java语言中方法重写的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IllegalAccessError%E4%BB%8B%E7%BB%8D"><span class="toc-text">IllegalAccessError介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-text">6. 虚方法表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-text">八、方法返回地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E9%80%80%E5%87%BA%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 方法退出的两种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%A1%A8"><span class="toc-text">3. 异常处理表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-text">九、一些附加信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">十、常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BE%E4%BE%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">1. 举例栈溢出的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%B0%83%E6%95%B4%E6%A0%88%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%B0%B1%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%8D%E5%87%BA%E7%8E%B0%E6%BA%A2%E5%87%BA%E4%B9%88%EF%BC%9F"><span class="toc-text">2. 调整栈大小，就能保证不出现溢出么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%86%E9%85%8D%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E8%B6%8A%E5%A4%A7%E8%B6%8A%E5%A5%BD%E4%B9%88%EF%BC%9F"><span class="toc-text">3. 分配的栈内存越大越好么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E5%90%A6%E6%B6%89%E5%8F%8A%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%9F"><span class="toc-text">4. 垃圾回收是否涉及到虚拟机栈？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">5. 方法中定义的局部变量是否线程安全？</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote>
<p>系统 : Windows 10<br>JDK : 1.8</p>
</blockquote>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-虚拟机栈的出现背景"><a href="#1-虚拟机栈的出现背景" class="headerlink" title="1. 虚拟机栈的出现背景"></a>1. 虚拟机栈的出现背景</h2><ul>
<li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li>
<li>基于栈设计优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li>
</ul>
<h2 id="2-内存中的栈与堆"><a href="#2-内存中的栈与堆" class="headerlink" title="2. 内存中的栈与堆"></a>2. 内存中的栈与堆</h2><ul>
<li>首先栈是运行时的单位，而堆是存储的单位。</li>
<li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-093805.png" alt="堆和栈"></p>
<h2 id="3-虚拟机栈基本内容"><a href="#3-虚拟机栈基本内容" class="headerlink" title="3. 虚拟机栈基本内容"></a>3. 虚拟机栈基本内容</h2><ul>
<li>Java虚拟机栈是什么？<ul>
<li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用，栈是线程私有的</strong>。</li>
</ul>
</li>
</ul>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest</span> &#123;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">StackTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackTest</span>();
        test.methodA();
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;
        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;
        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;

        methodB();
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;
        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">30</span>;
        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">40</span>;
    &#125;
&#125;</code></pre>

<p>如上面的代码，<code>main()</code> 、<code>methodA()</code> 、<code>methodB()</code>  在虚拟机栈中都对应着一个一个的栈帧。</p>
<ul>
<li>虚拟机栈的生命周期<ul>
<li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li>
</ul>
</li>
<li>虚拟机栈的作用<ul>
<li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。<ul>
<li>局部变量，它是相比于成员变量来说的（或属性）</li>
<li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-虚拟机栈的特点"><a href="#4-虚拟机栈的特点" class="headerlink" title="4. 虚拟机栈的特点"></a>4. 虚拟机栈的特点</h2><ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li>
<li>JVM直接对Java栈的操作只有两个<ul>
<li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li>
<li>执行结束后的<strong>出栈</strong>工作</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收问题<ul>
<li>栈不需要GC，但是可能存在OOM</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-095026.png" alt="入栈和出栈" style="zoom:50%;" />





<h2 id="5-虚拟机栈的异常"><a href="#5-虚拟机栈的异常" class="headerlink" title="5. 虚拟机栈的异常"></a>5. 虚拟机栈的异常</h2><p><strong>栈中可能出现的异常有哪些？</strong></p>
<ul>
<li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutofMemoryError 异常。</li>
</ul>
</li>
</ul>
<h2 id="6-设置栈内存大小"><a href="#6-设置栈内存大小" class="headerlink" title="6. 设置栈内存大小"></a>6. 设置栈内存大小</h2><p><strong>参考：</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">官方文档-JDK11</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#CBBFHAJA">官方文档-JDK8</a></p>
<p>可以使用参数 <code>-Xss</code> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-095748.png" alt="image-20231129095746846"></p>
<p><strong>IDEA中设置栈大小</strong></p>
<p>修改 <code>VM options</code> 设置栈的大小</p>
<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-100149.png" alt="image-20231129100148069" style="zoom: 80%;" />



<h1 id="二、栈的存储单位"><a href="#二、栈的存储单位" class="headerlink" title="二、栈的存储单位"></a>二、栈的存储单位</h1><h2 id="1-栈中存储什么？"><a href="#1-栈中存储什么？" class="headerlink" title="1. 栈中存储什么？"></a>1. 栈中存储什么？</h2><ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ul>
<h2 id="2-栈运行原理"><a href="#2-栈运行原理" class="headerlink" title="2. 栈运行原理"></a>2. 栈运行原理</h2><ul>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li>
</ul>
<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-102521.jpg" alt="方法与栈桢" style="zoom: 50%;" />

<ul>
<li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li>
<li>Java方法有两种返回函数的方式。<ul>
<li>一种是正常的函数返回，使用return指令。</li>
<li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li>
<li>但不管使用哪种方式，都会导致栈帧被弹出。</li>
</ul>
</li>
</ul>
<h2 id="3-栈帧的内部结构"><a href="#3-栈帧的内部结构" class="headerlink" title="3. 栈帧的内部结构"></a>3. 栈帧的内部结构</h2><ul>
<li>每个栈帧中存储着：<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）（或表达式栈）</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-102908.jpg" alt="栈桢内部结构" style="zoom:50%;" />

<p><strong>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的。</strong></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-103440.png" alt="线程和虚拟机栈"></p>
<h1 id="三、局部变量表"><a href="#三、局部变量表" class="headerlink" title="三、局部变量表"></a>三、局部变量表</h1><h2 id="1-认识局部变量表"><a href="#1-认识局部变量表" class="headerlink" title="1. 认识局部变量表"></a>1. 认识局部变量表</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul>
<li>局部变量表也被称之为局部变量数组或本地变量表</li>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul>
<li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
</ul>
</li>
<li>局部变量表中的变量只在当前方法调用中有效。<ul>
<li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li>
<li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li>
</ul>
</li>
</ul>
<h3 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;
    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();
        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;
        test.test1();
    &#125;

    <span class="comment">//练习：</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;
        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();
        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();
        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;
        System.out.println(count);
        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span>
<span class="comment">//        System.out.println(this.count);</span>
    &#125;

    <span class="comment">//关于Slot的使用的理解</span>
    <span class="keyword">public</span> <span class="title function_">LocalVariablesTest</span><span class="params">()</span>&#123;
        <span class="built_in">this</span>.count = <span class="number">1</span>;
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;
        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();
        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;
        test2(date, name1);
        System.out.println(date + name1);
    &#125;

    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;
        dateP = <span class="literal">null</span>;
        name2 = <span class="string">&quot;songhongkang&quot;</span>;
        <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span>
        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;
        <span class="keyword">return</span> dateP + name2;
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;
        <span class="built_in">this</span>.count++;
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;
        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;
        &#123;
            <span class="type">String</span> <span class="variable">j</span> <span class="operator">=</span> <span class="string">&quot;George&quot;</span>;
            <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> <span class="string">&quot;Chan&quot;</span>;
            System.out.println(j);
            System.out.println(p);
            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;
            b = a + <span class="number">1</span>;
        &#125;
        <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span>
        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;
    &#125;

    <span class="comment">/*</span>
<span class="comment">    变量的分类：按照数据类型分：① 基本数据类型  ② 引用数据类型</span>
<span class="comment">                按照在类中声明的位置分：① 成员变量：在使用前，都经历过默认初始化赋值</span>
<span class="comment">                                                类变量： linking的prepare阶段：给类变量默认赋值  ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span>
<span class="comment">                                                实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span>
<span class="comment">                                       ② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5Temp</span><span class="params">()</span>&#123;
        <span class="type">int</span> num;
        <span class="comment">//System.out.println(num);//错误信息：变量num未进行初始化</span>
    &#125;
&#125;</code></pre>

<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-191609.png" alt="image-20231129191607535" style="zoom:50%;" />



<h3 id="1-3-部分详解"><a href="#1-3-部分详解" class="headerlink" title="1.3 部分详解"></a>1.3 部分详解</h3><p>下面以main方法为例</p>
<h4 id="Bytecode"><a href="#Bytecode" class="headerlink" title="Bytecode"></a>Bytecode</h4><p>0-15表示main方法编译成字节码后有16行。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-192403.png" alt="image-20231129192402449"></p>
<h4 id="Exception-Table"><a href="#Exception-Table" class="headerlink" title="Exception Table"></a>Exception Table</h4><p>异常表。由于main()方法没有声明异常，所以异常表为空。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-192508.png" alt="image-20231129192506846"></p>
<h4 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h4><ul>
<li>Maximum stack size : 2 <ul>
<li>最大栈深度，2表示最多同时会往此方法的 <code>操作数栈</code> 中压入两个变量</li>
</ul>
</li>
<li>Maximum local variables : 3<ul>
<li>局部变量数，这里对应着 args、test、num</li>
</ul>
</li>
<li>Code length : 16<ul>
<li>字节码行数</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-193742.png" alt="image-20231129193741378"></p>
<h4 id="LineNumberTable"><a href="#LineNumberTable" class="headerlink" title="LineNumberTable"></a>LineNumberTable</h4><ul>
<li>行号表<ul>
<li>将编译后字节码指令行号(Bytecode)与Java代码行号对应起来</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-194412.png" alt="image-20231129194411074"></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-192403.png" alt="image-20231129192402449"></p>
<h4 id="LocalVariableTable"><a href="#LocalVariableTable" class="headerlink" title="LocalVariableTable"></a>LocalVariableTable</h4><ul>
<li>局部变量表<ul>
<li>作用：保存方法的局部变量的索引和变量的作用范围信息</li>
<li>Start PC<ul>
<li>变量在字节码指令中的行号，变量从这里开始生效。</li>
</ul>
</li>
<li>Length<ul>
<li>变量在字节码指令中，从Start PC开始，向下有效的行数。(由于字节码行号从0开始，所以Length需要减1，否则可能会超过字节码总行数)</li>
</ul>
</li>
<li>Index<ul>
<li>在局部变量表中的索引位置(成员方法索引位置为0的位置参数默认是 <code>this</code> )</li>
</ul>
</li>
<li>Name<ul>
<li>参数名</li>
</ul>
</li>
<li>Descriptor<ul>
<li>参数的描述信息</li>
<li>[Ljava&#x2F;lang&#x2F;String; <ul>
<li>表示参数为String类型的数组，L表示引用类型</li>
</ul>
</li>
<li>I 表示参数为 int类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-194716.png" alt="image-20231129194715444"  />





<h2 id="2-关于Slot的理解"><a href="#2-关于Slot的理解" class="headerlink" title="2. 关于Slot的理解"></a>2. 关于Slot的理解</h2><ul>
<li><p>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</p>
</li>
<li><p>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
</li>
<li><p>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）。</p>
<ul>
<li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li>
<li>long和double则占据两个slot</li>
</ul>
</li>
<li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</p>
</li>
<li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</p>
</li>
<li><p>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-092013.png" alt="image-20231130092010061"></p>
<h3 id="2-1-代码示例"><a href="#2-1-代码示例" class="headerlink" title="2.1 代码示例"></a>2.1 代码示例</h3><p><strong>this 存放在 index &#x3D; 0 的位置：</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;
	<span class="built_in">this</span>.count++;
&#125;</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-093254.png" alt="image-20231130093253042"></p>
<p><strong>64位的类型（ long 和 double ）占用两个slot</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;
    dateP = <span class="literal">null</span>;
    name2 = <span class="string">&quot;songhongkang&quot;</span>;
    <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span>
    <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;
    <span class="keyword">return</span> dateP + name2;
&#125;</code></pre>

<p>weight 为 double 类型， 占用了3和4两个index 索引位</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-094139.png" alt="image-20231130094138168"></p>
<p><strong>static 无法调用 this</strong></p>
<p>this 不存在与 static 方法的局部变量表中，所以无法调用</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;
    <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();
    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();
    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;
    System.out.println(count);
    <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span>
	<span class="comment">// System.out.println(this.count);</span>
&#125;</code></pre>



<h3 id="2-2-Slot的重复利用"><a href="#2-2-Slot的重复利用" class="headerlink" title="2.2 Slot的重复利用"></a>2.2 Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;
    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;
    &#123;
        <span class="type">String</span> <span class="variable">j</span> <span class="operator">=</span> <span class="string">&quot;George&quot;</span>;
        <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> <span class="string">&quot;Chan&quot;</span>;
        System.out.println(j);
        System.out.println(p);
        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;
        b = a + <span class="number">1</span>;
    &#125;
    <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span>
    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;
&#125;</code></pre>

<p>局部变量 c 重用了局部变量 j 的 slot 位置</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-095006.png" alt="image-20231130095004942"></p>
<h2 id="3-静态变量与局部变量的对比"><a href="#3-静态变量与局部变量的对比" class="headerlink" title="3. 静态变量与局部变量的对比"></a>3. 静态变量与局部变量的对比</h2><h3 id="3-1-变量的分类"><a href="#3-1-变量的分类" class="headerlink" title="3.1 变量的分类"></a>3.1 变量的分类</h3><ul>
<li>按照数据类型分<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
</li>
<li>按照在类中声明的位置分<ul>
<li>成员变量：在使用前，都经历过默认初始化赋值<ul>
<li>类变量：<ul>
<li>linking的prepare阶段：给类变量默认赋值</li>
<li>initial阶段：给类变量显式赋值即静态代码块赋值</li>
</ul>
</li>
<li>实例变量：<ul>
<li>随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</li>
</ul>
</li>
</ul>
</li>
<li>局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</li>
</ul>
</li>
</ul>
<h3 id="3-2-总结"><a href="#3-2-总结" class="headerlink" title="3.2 总结"></a>3.2 总结</h3><ul>
<li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li>
<li>成员变量有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li>
<li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>
</ul>
<h3 id="3-3-补充说明"><a href="#3-3-补充说明" class="headerlink" title="3.3 补充说明"></a>3.3 补充说明</h3><ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li>
</ul>
<h2 id="四、操作数栈"><a href="#四、操作数栈" class="headerlink" title="四、操作数栈"></a>四、操作数栈</h2><h3 id="1-操作数栈的特点"><a href="#1-操作数栈的特点" class="headerlink" title="1. 操作数栈的特点"></a>1. 操作数栈的特点</h3><ul>
<li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</li>
<li>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</li>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈<ul>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-100454.png" alt="操作数栈" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-100652.png" alt="操作数栈2" style="zoom:67%;" />



<h3 id="2-操作数栈的作用"><a href="#2-操作数栈的作用" class="headerlink" title="2. 操作数栈的作用"></a>2. 操作数栈的作用</h3><ul>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li>
<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li>
<li>栈中的任何一个元素都是可以任意的Java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></li>
<li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li>
<li>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li>
</ul>
<h3 id="3-操作数栈代码追踪"><a href="#3-操作数栈代码追踪" class="headerlink" title="3. 操作数栈代码追踪"></a>3. 操作数栈代码追踪</h3><blockquote>
<p>Java代码</p>
</blockquote>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;
    <span class="comment">//byte、short、char、boolean：都以int型来保存</span>
    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;
    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;
    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;
&#125;</code></pre>

<blockquote>
<p>对应字节码指令</p>
</blockquote>
<pre><code class="highlight plaintext"> 0 bipush 15
 2 istore_1
 3 bipush 8
 5 istore_2
 6 iload_1
 7 iload_2
 8 iadd
 9 istore_3
10 return</code></pre>



<h4 id="具体执行流程"><a href="#具体执行流程" class="headerlink" title="具体执行流程"></a>具体执行流程</h4><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-103909.png" alt="image-20231130103907694"></p>
<p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素，并且操作数栈为空了。</p>
<ul>
<li>解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104032.png" alt="image-20231130104030850"></p>
<p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104137.png" alt="image-20231130104135613"></p>
<p>4、PC寄存器往下移，指向下一行代码，将操作数栈的元素8存储到局部变量表索引为 2 的位置（<code>istore_2</code>）</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104333.png" alt="image-20231130104332206"></p>
<p>5、从局部变量表中，依次将数据取出放在操作数栈中，等待执行 add 操作</p>
<ul>
<li>iload_1：取出局部变量表中索引为1的数据入操作数栈</li>
<li>iload_2：取出局部变量表中索引为2的数据入操作数栈</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104553.png" alt="image-20231130104551702"></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104728.png" alt="image-20231130104551702"></p>
<p>6、将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104835.png" alt="image-20231130104834157"></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104858.png" alt="image-20231130104857485"></p>
<h3 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4. 常见问题"></a>4. 常见问题</h3><h4 id="4-1-关于类型转换的说明"><a href="#4-1-关于类型转换的说明" class="headerlink" title="4.1 关于类型转换的说明"></a>4.1 关于类型转换的说明</h4><ul>
<li>因为 15 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 15</li>
<li>但是存储在局部变量的时候，会转成 int 类型的变量：istore_1</li>
<li>如果数值超过了byte类型能存储的数据值范围，存储局部变量表时会使用更大的类型，如 <code>sipush 800</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-105244.png" alt="image-20231130105242980"></p>
<h4 id="4-2-方法带有返回值"><a href="#4-2-方法带有返回值" class="headerlink" title="4.2 方法带有返回值"></a>4.2 方法带有返回值</h4><ul>
<li>如果被调用的方法带有返回值，返回值入操作数栈</li>
</ul>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span>&#123;
    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;
    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;
    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + n;
    <span class="keyword">return</span> k;
&#125;

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSum</span><span class="params">()</span>&#123;
    <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span>
    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getSum();
    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;
&#125;</code></pre>

<ul>
<li>getSum() 方法字节码指令：最后带着个 <code>ireturn</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-105742.png" alt="image-20231130105740956"></p>
<ul>
<li>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-105824.png" alt="image-20231130105823472"></p>
<p>解释：<code>aload_0</code> 加载的是 <strong>this 变量</strong>，然后通过 this 变量执行  <code>invokevirtual</code> 指令调用 <code>getSum</code> 方法计算结果，然后将计算的结果 通过 <code>istore_1</code> 存储到局部变量表<strong>索引为 1</strong> 的位置</p>
<h1 id="五、栈顶缓存技术"><a href="#五、栈顶缓存技术" class="headerlink" title="五、栈顶缓存技术"></a>五、栈顶缓存技术</h1><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p>
<ul>
<li>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读&#x2F;写次数多，效率不高。</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></li>
<li>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li>
</ul>
<h1 id="六、动态链接"><a href="#六、动态链接" class="headerlink" title="六、动态链接"></a>六、动态链接</h1><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p>
<ul>
<li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li>
</ul>
<blockquote>
<p>Java源代码</p>
</blockquote>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicLinkingTest</span> &#123;

    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;
        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;
        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);

        methodA();

        num++;
    &#125;

&#125;</code></pre>

<blockquote>
<p>字节码</p>
</blockquote>
<pre><code class="highlight plaintext">Classfile /H:/code_test/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.class
  Last modified 2023-11-28; size 712 bytes       
  MD5 checksum e56913c945f897c7ee6c0a608629bca8  
  Compiled from &quot;DynamicLinkingTest.java&quot;        
public class com.atguigu.java1.DynamicLinkingTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #9.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Fieldref           #8.#24         // com/atguigu/java1/DynamicLinkingTest.num:I
   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;
   #4 = String             #27            // methodA()....
   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #6 = String             #30            // methodB()....
   #7 = Methodref          #8.#31         // com/atguigu/java1/DynamicLinkingTest.methodA:()V
   #8 = Class              #32            // com/atguigu/java1/DynamicLinkingTest
   #9 = Class              #33            // java/lang/Object
  #10 = Utf8               num
  #11 = Utf8               I
  #12 = Utf8               &lt;init&gt;
  #13 = Utf8               ()V
  #14 = Utf8               Code
  #15 = Utf8               LineNumberTable
  #16 = Utf8               LocalVariableTable
  #17 = Utf8               this
  #18 = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;
  #19 = Utf8               methodA
  #20 = Utf8               methodB
  #21 = Utf8               SourceFile
  #22 = Utf8               DynamicLinkingTest.java
  #23 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V
  #24 = NameAndType        #10:#11        // num:I
  #25 = Class              #34            // java/lang/System
  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;
  #27 = Utf8               methodA()....
  #28 = Class              #37            // java/io/PrintStream
  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V
  #30 = Utf8               methodB()....
  #31 = NameAndType        #19:#13        // methodA:()V
  #32 = Utf8               com/atguigu/java1/DynamicLinkingTest
  #33 = Utf8               java/lang/Object
  #34 = Utf8               java/lang/System
  #35 = Utf8               out
  #36 = Utf8               Ljava/io/PrintStream;
  #37 = Utf8               java/io/PrintStream
  #38 = Utf8               println
  #39 = Utf8               (Ljava/lang/String;)V
&#123;
  int num;
    descriptor: I
    flags:

  public com.atguigu.java1.DynamicLinkingTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: aload_0
         5: bipush        10
         7: putfield      #2                  // Field num:I
        10: return
      LineNumberTable:
        line 7: 0
        line 9: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      11     0  this   Lcom/atguigu/java1/DynamicLinkingTest;

  public void methodA();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #4                  // String methodA()....
         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 12: 0
        line 13: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lcom/atguigu/java1/DynamicLinkingTest;

  public void methodB();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #6                  // String methodB()....
         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: aload_0
         9: invokevirtual #7                  // Method methodA:()V
        12: aload_0
        13: dup
        14: getfield      #2                  // Field num:I
        17: iconst_1
        18: iadd
        19: putfield      #2                  // Field num:I
        22: return
      LineNumberTable:
        line 16: 0
        line 18: 8
        line 20: 12
        line 21: 22
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      23     0  this   Lcom/atguigu/java1/DynamicLinkingTest;
&#125;
SourceFile: &quot;DynamicLinkingTest.java&quot;</code></pre>

<p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p>
<p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p>
<ul>
<li>先找 #8 ：<ul>
<li><code>#8 = Class #32</code> ：去找 #32</li>
<li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li>
<li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li>
</ul>
</li>
<li>再来找 #31：<ul>
<li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li>
<li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li>
<li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li>
</ul>
</li>
</ul>
<p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p>
<p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-113303.png" alt="运行时常量池"></p>
<p><strong>为什么要用常量池呢？</strong></p>
<ul>
<li>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</li>
<li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li>
</ul>
<h1 id="七、方法的调用"><a href="#七、方法的调用" class="headerlink" title="七、方法的调用"></a>七、方法的调用</h1><h2 id="1-静态链接与动态链接"><a href="#1-静态链接与动态链接" class="headerlink" title="1. 静态链接与动态链接"></a>1. 静态链接与动态链接</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li><p>静态链接</p>
<p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
</li>
<li><p>动态链接</p>
<p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>
</li>
</ul>
<h2 id="2-早期绑定与晚期绑定"><a href="#2-早期绑定与晚期绑定" class="headerlink" title="2. 早期绑定与晚期绑定"></a>2. 早期绑定与晚期绑定</h2><p>静态链接与动态链接针对的是方法，早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p>
<p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p>
<ul>
<li><p>早期绑定</p>
<p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p>
</li>
<li><p>晚期绑定</p>
<p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
</li>
</ul>
<blockquote>
<p>JAVA 源码</p>
</blockquote>
<pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;
        System.out.println(<span class="string">&quot;动物进食&quot;</span>);
    &#125;
&#125;
<span class="keyword">interface</span> <span class="title class_">Huntable</span>&#123;
    <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span>;
&#125;
<span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);
    &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span>&#123;

    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;
        <span class="built_in">super</span>();<span class="comment">//表现为：早期绑定</span>
    &#125;

    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span>&#123;
        <span class="built_in">this</span>();<span class="comment">//表现为：早期绑定</span>
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;
        <span class="built_in">super</span>.eat();<span class="comment">//表现为：早期绑定</span>
        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);
    &#125;
&#125;
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(Animal animal)</span>&#123;
        animal.eat();<span class="comment">//表现为：晚期绑定</span>
    &#125;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(Huntable h)</span>&#123;
        h.hunt();<span class="comment">//表现为：晚期绑定</span>
    &#125;
&#125;</code></pre>

<blockquote>
<p>字节码</p>
</blockquote>
<p><strong>执行命令：</strong> <code>javap -v AnimalTest.class</code></p>
<pre><code class="highlight plaintext">Classfile /H:/code_test/JVMDemo/out/production/chapter05/com/atguigu/java2/AnimalTest.class
  Last modified 2023-11-28; size 701 bytes
  MD5 checksum 874899c4a820e8bd8fa1d408ae7a36c0
  Compiled from &quot;AnimalTest.java&quot;
public class com.atguigu.java2.AnimalTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #5.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Methodref          #24.#25        // com/atguigu/java2/Animal.eat:()V
   #3 = InterfaceMethodref #26.#27        // com/atguigu/java2/Huntable.hunt:()V
   #4 = Class              #28            // com/atguigu/java2/AnimalTest
   #5 = Class              #29            // java/lang/Object
   #6 = Utf8               &lt;init&gt;
   #7 = Utf8               ()V
   #8 = Utf8               Code
   #9 = Utf8               LineNumberTable
  #10 = Utf8               LocalVariableTable
  #11 = Utf8               this
  #12 = Utf8               Lcom/atguigu/java2/AnimalTest;
  #13 = Utf8               showAnimal
  #14 = Utf8               (Lcom/atguigu/java2/Animal;)V
  #15 = Utf8               animal
  #16 = Utf8               Lcom/atguigu/java2/Animal;
  #17 = Utf8               showHunt
  #18 = Utf8               (Lcom/atguigu/java2/Huntable;)V
  #19 = Utf8               h
  #20 = Utf8               Lcom/atguigu/java2/Huntable;
  #21 = Utf8               SourceFile
  #22 = Utf8               AnimalTest.java
  #23 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V
  #24 = Class              #30            // com/atguigu/java2/Animal
  #25 = NameAndType        #31:#7         // eat:()V
  #26 = Class              #32            // com/atguigu/java2/Huntable
  #27 = NameAndType        #33:#7         // hunt:()V
  #28 = Utf8               com/atguigu/java2/AnimalTest
  #29 = Utf8               java/lang/Object
  #30 = Utf8               com/atguigu/java2/Animal
  #31 = Utf8               eat
  #32 = Utf8               com/atguigu/java2/Huntable
  #33 = Utf8               hunt
&#123;
  public com.atguigu.java2.AnimalTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 50: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/atguigu/java2/AnimalTest;

  public void showAnimal(com.atguigu.java2.Animal);
    descriptor: (Lcom/atguigu/java2/Animal;)V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=2, args_size=2
         0: aload_1
    Code:
      stack=1, locals=2, args_size=2
         0: aload_1
         1: invokeinterface #3,  1            // InterfaceMethod com/atguigu/java2/Huntable.hunt:()V
         6: return
      LineNumberTable:
        line 55: 0
        line 56: 6
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       7     0  this   Lcom/atguigu/java2/AnimalTest;
            0       7     1     h   Lcom/atguigu/java2/Huntable;
&#125;
SourceFile: &quot;AnimalTest.java&quot;</code></pre>

<ul>
<li><p><strong>invokevirtual</strong>  体现为晚期绑定</p>
</li>
<li><p><strong>invokeinterface</strong>  也体现为晚期绑定</p>
</li>
<li><p><strong>invokespecial</strong>  体现为早期绑定</p>
</li>
</ul>
<h2 id="3-多态与绑定"><a href="#3-多态与绑定" class="headerlink" title="3. 多态与绑定"></a>3. 多态与绑定</h2><ul>
<li>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</li>
<li>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li>
</ul>
<h3 id="3-1-虚方法与非虚方法"><a href="#3-1-虚方法与非虚方法" class="headerlink" title="3.1 虚方法与非虚方法"></a>3.1 虚方法与非虚方法</h3><h4 id="虚方法与非虚方法的区别"><a href="#虚方法与非虚方法的区别" class="headerlink" title="虚方法与非虚方法的区别"></a>虚方法与非虚方法的区别</h4><ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法(static)、私有方法(private)、final方法、实例构造器、父类方法(super)都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ul>
<h4 id="多态的使用前提"><a href="#多态的使用前提" class="headerlink" title="多态的使用前提"></a>多态的使用前提</h4><ul>
<li>存在类的继承</li>
<li>子类重写父类方法</li>
</ul>
<h4 id="虚拟机中调用方法的指令"><a href="#虚拟机中调用方法的指令" class="headerlink" title="虚拟机中调用方法的指令"></a>虚拟机中调用方法的指令</h4><ul>
<li>普通指令<ul>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用 <code>&lt;init&gt;</code> (构造器)方法、私有(private)及父类(super)方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
</li>
<li>动态调用指令<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p>
<p><strong>final 修饰的方法在字节码中也会被标记为 invokevirtual ，但它其实是非虚方法</strong></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote>
<p>JAVA代码</p>
</blockquote>
<pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;
    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);
    &#125;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;
        System.out.println(<span class="string">&quot;father &quot;</span> + str);
    &#125;

    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showFinal</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;father show final&quot;</span>);
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCommon</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;
    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;
        <span class="comment">//invokespecial</span>
        <span class="built_in">super</span>();
    &#125;
    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span> &#123;
        <span class="comment">//invokespecial</span>
        <span class="built_in">this</span>();
    &#125;
    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;
        System.out.println(<span class="string">&quot;son &quot;</span> + str);
    &#125;
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPrivate</span><span class="params">(String str)</span> &#123;
        System.out.println(<span class="string">&quot;son private&quot;</span> + str);
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;
        <span class="comment">//invokestatic</span>
        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);
        <span class="comment">//invokestatic</span>
        <span class="built_in">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);
        <span class="comment">//invokespecial</span>
        showPrivate(<span class="string">&quot;hello!&quot;</span>);
        <span class="comment">//invokespecial</span>
        <span class="built_in">super</span>.showCommon();

        <span class="comment">//invokevirtual</span>
        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span>
        <span class="comment">//虚方法如下：</span>
        <span class="comment">//invokevirtual</span>
        showCommon();
        info();

        <span class="type">MethodInterface</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;
        <span class="comment">//invokeinterface</span>
        in.methodA();
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;

    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Father f)</span>&#123;
        f.showCommon();
    &#125;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">Son</span> <span class="variable">so</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();
        so.show();
    &#125;
&#125;

<span class="keyword">interface</span> <span class="title class_">MethodInterface</span>&#123;
    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;
&#125;</code></pre>

<p>Son 类中 show() 方法的字节码指令如下</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-133257.png" alt="image-20231130133256188"></p>
<h3 id="3-2-关于-invokedynamic-指令"><a href="#3-2-关于-invokedynamic-指令" class="headerlink" title="3.2 关于 invokedynamic 指令"></a>3.2 关于 invokedynamic 指令</h3><ul>
<li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li>
<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li>
</ul>
<blockquote>
<p>JAVA源码示例</p>
</blockquote>
<pre><code class="highlight java"><span class="meta">@FunctionalInterface</span>
<span class="keyword">interface</span> <span class="title class_">Func</span> &#123;
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">func</span><span class="params">(String str)</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> &#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">(Func func)</span> &#123;
        <span class="keyword">return</span>;
    &#125;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>();

        <span class="type">Func</span> <span class="variable">func</span> <span class="operator">=</span> s -&gt; &#123;
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125;;

        lambda.lambda(func);

        lambda.lambda(s -&gt; &#123;
            <span class="keyword">return</span> <span class="literal">true</span>;
        &#125;);
    &#125;
&#125;</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-133827.png" alt="image-20231130133826164"></p>
<h2 id="4-动态语言和静态语言"><a href="#4-动态语言和静态语言" class="headerlink" title="4. 动态语言和静态语言"></a>4. 动态语言和静态语言</h2><ul>
<li><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
</li>
<li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
</li>
<li><p>JAVA 属于静态语言，JavaScript 属于动态语言，Python 属于动态语言。</p>
</li>
</ul>
<h2 id="5-Java语言中方法重写的本质"><a href="#5-Java语言中方法重写的本质" class="headerlink" title="5. Java语言中方法重写的本质"></a>5. Java语言中方法重写的本质</h2><ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ol>
<li>如果通过则返回这个方法的直接引用，查找过程结束</li>
<li>如果不通过，则返回java.lang.IllegalAccessError 异常</li>
</ol>
</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<p><em>上面这个过程称为<strong>动态分派</strong></em></p>
<h3 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h3><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</p>
<h2 id="6-虚方法表"><a href="#6-虚方法表" class="headerlink" title="6. 虚方法表"></a>6. 虚方法表</h2><ul>
<li>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li>
<li>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</li>
</ul>
<blockquote>
<p>示例1</p>
</blockquote>
<p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-134718.png" alt="image-20231130134717020"></p>
<ul>
<li>比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</li>
<li>下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</li>
</ul>
<h1 id="八、方法返回地址"><a href="#八、方法返回地址" class="headerlink" title="八、方法返回地址"></a>八、方法返回地址</h1><blockquote>
<p>方法返回地址、动态链接、附加信息 在某些时候也叫做 <strong>帧数据区</strong></p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul>
<li><p>存放调用该方法的pc寄存器的值。</p>
<p>一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
</li>
<li><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要<strong>恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值</strong>等，让调用者方法继续执行下去。</p>
</li>
<li><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
</li>
</ul>
<h2 id="2-方法退出的两种方式"><a href="#2-方法退出的两种方式" class="headerlink" title="2. 方法退出的两种方式"></a>2. 方法退出的两种方式</h2><blockquote>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法</p>
</blockquote>
<ul>
<li>正常退出<ul>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含：<ul>
<li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li>
<li>lreturn：Long类型</li>
<li>freturn：Float类型</li>
<li>dreturn：Double类型</li>
<li>areturn：引用类型</li>
<li>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</li>
</ul>
</li>
</ul>
</li>
<li>异常退出<ul>
<li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。<ul>
<li>简单来说就是代码块中是否声明了try catch，以及catch块中是否包含了对应的异常</li>
</ul>
</li>
<li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;

    methodVoid();

    <span class="keyword">try</span> &#123;
        method1();
    &#125; <span class="keyword">catch</span> (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;
    <span class="type">FileReader</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;atguigu.txt&quot;</span>);
    <span class="type">char</span>[] cBuffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];
    <span class="type">int</span> len;
    <span class="keyword">while</span> ((len = fis.read(cBuffer)) != -<span class="number">1</span>) &#123;
        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cBuffer, <span class="number">0</span>, len);
        System.out.println(str);
    &#125;
    fis.close();
&#125;</code></pre>

<blockquote>
<p>字节码：异常表</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-140311.png" alt="image-20231130140309699"></p>
<h2 id="3-异常处理表"><a href="#3-异常处理表" class="headerlink" title="3. 异常处理表"></a>3. 异常处理表</h2><ul>
<li>反编译字节码文件，可得到 Exception Table</li>
<li>Start PC(from) ：字节码指令起始地址</li>
<li>End PC(to) ：字节码指令结束地址</li>
<li>Handler PC(target) ：出现异常跳转至地址为 11 的指令执行</li>
<li>Catch Type(type) ：捕获异常的类型</li>
</ul>
<p>异常处理表通过javap命令查看的表头信息与通过Jclasslib插件查看的表头名称不同，但是意思是一样的。</p>
<pre><code class="highlight plaintext">
public void method2();
  descriptor: ()V
  flags: ACC_PUBLIC
  Code:
    stack=1, locals=2, args_size=1
       0: aload_0
       1: invokevirtual #2                  // Method methodVoid:()V
       4: aload_0
       5: invokevirtual #3                  // Method method1:()V
       8: goto          16
      11: astore_1
      12: aload_1
      13: invokevirtual #5                  // Method java/io/IOException.printStackTrace:()V
      16: return
    Exception table:
       from    to  target type
           4     8    11   Class java/io/IOException
    LineNumberTable:
      line 69: 0
      line 72: 4
      line 75: 8
      line 73: 11
      line 74: 12
      line 76: 16
    LocalVariableTable:
      Start  Length  Slot  Name   Signature
         12       4     1     e   Ljava/io/IOException;
          0      17     0  this   Lcom/atguigu/java3/ReturnAddressTest;
    StackMapTable: number_of_entries = 2
      frame_type = 75 /* same_locals_1_stack_item */
        stack = [ class java/io/IOException ]
      frame_type = 4 /* same */
</code></pre>





<h1 id="九、一些附加信息"><a href="#九、一些附加信息" class="headerlink" title="九、一些附加信息"></a>九、一些附加信息</h1><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h1 id="十、常见问题"><a href="#十、常见问题" class="headerlink" title="十、常见问题"></a>十、常见问题</h1><h2 id="1-举例栈溢出的情况"><a href="#1-举例栈溢出的情况" class="headerlink" title="1. 举例栈溢出的情况"></a>1. 举例栈溢出的情况</h2><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p>
<h2 id="2-调整栈大小，就能保证不出现溢出么？"><a href="#2-调整栈大小，就能保证不出现溢出么？" class="headerlink" title="2. 调整栈大小，就能保证不出现溢出么？"></a>2. 调整栈大小，就能保证不出现溢出么？</h2><p>不能保证不溢出，只能保证SOF出现的几率小</p>
<h2 id="3-分配的栈内存越大越好么？"><a href="#3-分配的栈内存越大越好么？" class="headerlink" title="3. 分配的栈内存越大越好么？"></a>3. 分配的栈内存越大越好么？</h2><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p>
<h2 id="4-垃圾回收是否涉及到虚拟机栈？"><a href="#4-垃圾回收是否涉及到虚拟机栈？" class="headerlink" title="4. 垃圾回收是否涉及到虚拟机栈？"></a>4. 垃圾回收是否涉及到虚拟机栈？</h2><p><strong>不会</strong></p>
<table>
<thead>
<tr>
<th>位置</th>
<th>是否有Error</th>
<th>是否存在GC</th>
</tr>
</thead>
<tbody><tr>
<td>PC计数器</td>
<td>无</td>
<td>不存在</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>有，SOF</td>
<td>不存在</td>
</tr>
<tr>
<td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>堆</td>
<td>有，OOM</td>
<td>存在</td>
</tr>
<tr>
<td>方法区</td>
<td>有</td>
<td>存在</td>
</tr>
</tbody></table>
<h2 id="5-方法中定义的局部变量是否线程安全？"><a href="#5-方法中定义的局部变量是否线程安全？" class="headerlink" title="5. 方法中定义的局部变量是否线程安全？"></a>5. 方法中定义的局部变量是否线程安全？</h2><ul>
<li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li>
<li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li>
</ul>
<p><strong>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</strong></p>
<blockquote>
<p>示例：</p>
</blockquote>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> &#123;

    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;

    <span class="comment">//s1的声明方式是线程安全的</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;
        <span class="comment">//StringBuilder:线程不安全</span>
        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();
        s1.append(<span class="string">&quot;a&quot;</span>);
        s1.append(<span class="string">&quot;b&quot;</span>);
        <span class="comment">//...</span>
    &#125;
    <span class="comment">//sBuilder的操作过程：是线程不安全的</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuilder)</span>&#123;
        sBuilder.append(<span class="string">&quot;a&quot;</span>);
        sBuilder.append(<span class="string">&quot;b&quot;</span>);
        <span class="comment">//...</span>
    &#125;
    <span class="comment">//s1的操作：是线程不安全的</span>
    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;
        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();
        s1.append(<span class="string">&quot;a&quot;</span>);
        s1.append(<span class="string">&quot;b&quot;</span>);
        <span class="keyword">return</span> s1;
    &#125;
    <span class="comment">//s1的操作：是线程安全的</span>
    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;
        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();
        s1.append(<span class="string">&quot;a&quot;</span>);
        s1.append(<span class="string">&quot;b&quot;</span>);
        <span class="keyword">return</span> s1.toString();
    &#125;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();
        
        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;
            s.append(<span class="string">&quot;a&quot;</span>);
            s.append(<span class="string">&quot;b&quot;</span>);
        &#125;).start();

        method2(s);

    &#125;

&#125;</code></pre>


      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 george_95@126.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'f820fe811764cacedc4f',
            clientSecret: '0ce07abb65f0e79ddb8830f32029b8a9656e0ee0',
            repo: 'georgechan95.github.io',
            owner: 'GeorgeChan95',
            admin: ['GeorgeChan95'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('15',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 George
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
