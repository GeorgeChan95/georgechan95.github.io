<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>01-设计模式六大原则 | George&#39;s Blog</title>
  <meta name="google-site-verification" content="RobLWkyyFziZxPJ4I887QROdX8XrYthcJwWTcuH0wwQ" />
  <meta name="msvalidate.01" content="626D541C48E5D151F52CECC2C6714BD4" />
  <meta name="360-site-verification" content="c838adf8357ca2f614d08ad5235a1717" />
  <meta name="keywords" content=" 设计模式 , java ">
  <meta name="description" content="01-设计模式六大原则 | George&#39;s Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="个人简介本人在合肥，从事后端开发工作。 联系方式 邮箱：&#x67;&#101;&#111;&#114;&#103;&#101;&#x5f;&#57;&#x35;&#64;&#x31;&#x32;&#54;&#46;&#99;&#x6f;&#109;  邮件可能几天才看一次，如有联系，请耐心等待。">
<meta property="og:type" content="website">
<meta property="og:title" content="关于">
<meta property="og:url" content="https://georgechan95.github.io/about/index.html">
<meta property="og:site_name" content="George&#39;s Blog">
<meta property="og:description" content="个人简介本人在合肥，从事后端开发工作。 联系方式 邮箱：&#x67;&#101;&#111;&#114;&#103;&#101;&#x5f;&#57;&#x35;&#64;&#x31;&#x32;&#54;&#46;&#99;&#x6f;&#109;  邮件可能几天才看一次，如有联系，请耐心等待。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-21T02:29:45.000Z">
<meta property="article:modified_time" content="2024-12-09T05:22:48.462Z">
<meta property="article:author" content="George">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/favicon.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="George's Blog" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>George</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/GeorgeChan95"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:george_95@126.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(100)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="设计模式">
            
            设计模式
            <small>(24)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Docker">
            
            Docker
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Hexo">
            <i class="fold iconfont icon-right"></i>
            Hexo
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Hexo&lt;---&gt;Typora">
            
            Typora
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JUC">
            
            JUC
            <small>(24)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JVM">
            
            JVM
            <small>(27)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="k8s">
            
            k8s
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="linux">
            
            linux
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="neo4j">
            
            neo4j
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="UML">
            
            UML
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">关于</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="100">
<input type="hidden" id="yelog_site_word_count" value="428.4k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>插入排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二分法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二进制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>合并有序链表</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>科学上网</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>链表</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>冒泡排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>双亲委派机制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>位运算</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>选择排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github pages</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jenkins</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>juc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jvm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>neo4j</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Rocky</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>sitemap</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SpringBoot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>typora</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ubuntu18</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>UML</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 k8s "
           href="/blog/970719d6.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="006-Kubernetes Service">006-Kubernetes Service</span>
            <span class="post-date" title="2025-04-28 22:10:00">2025/04/28</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/c790096a.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="005-Kubernetes控制器">005-Kubernetes控制器</span>
            <span class="post-date" title="2025-04-02 20:12:00">2025/04/02</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/79e06aab.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="004-Pod的生命周期">004-Pod的生命周期</span>
            <span class="post-date" title="2025-03-22 09:05:00">2025/03/22</span>
        </a>
        
        
        <a  class="全部文章 Docker "
           href="/blog/b01d5c62.html"
           data-tag="linux,Docker,科学上网"
           data-author="" >
            <span class="post-title" title="Docker配置网络代理实现外网镜像下载">Docker配置网络代理实现外网镜像下载</span>
            <span class="post-date" title="2025-01-08 23:00:00">2025/01/08</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/7f174b3e.html"
           data-tag="linux,科学上网,Rocky"
           data-author="" >
            <span class="post-title" title="Rocky9安装Shadowsocks实现科学上网">Rocky9安装Shadowsocks实现科学上网</span>
            <span class="post-date" title="2025-01-08 21:09:00">2025/01/08</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/b00f53e9.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="003-基于Rocky9.3系统使用kubeadm安装k8s1.29集群">003-基于Rocky9.3系统使用kubeadm安装k8s1.29集群</span>
            <span class="post-date" title="2025-01-03 22:05:00">2025/01/03</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/3c79d8d9.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="002-Rocky9.3系统初始化设置和Docker安装">002-Rocky9.3系统初始化设置和Docker安装</span>
            <span class="post-date" title="2025-01-02 13:25:00">2025/01/02</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/7e3a5200.html"
           data-tag="linux,Rocky"
           data-author="" >
            <span class="post-title" title="001-ESXi8安装Rocky9.3虚拟机">001-ESXi8安装Rocky9.3虚拟机</span>
            <span class="post-date" title="2025-01-02 09:34:00">2025/01/02</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/77d85f50.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="25-责任链模式">25-责任链模式</span>
            <span class="post-date" title="2024-12-03 21:08:00">2024/12/03</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/fcec839d.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="24-策略模式">24-策略模式</span>
            <span class="post-date" title="2024-12-02 18:16:00">2024/12/02</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/6109865a.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="23-状态模式">23-状态模式</span>
            <span class="post-date" title="2024-11-29 19:30:00">2024/11/29</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/58d4db7.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="22-解释器模式">22-解释器模式</span>
            <span class="post-date" title="2024-11-28 22:00:00">2024/11/28</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/a5cf7eb4.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="21-备忘录模式">21-备忘录模式</span>
            <span class="post-date" title="2024-11-27 21:40:00">2024/11/27</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/3148d6be.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="20-中介者模式">20-中介者模式</span>
            <span class="post-date" title="2024-11-26 20:35:00">2024/11/26</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/f06aea0b.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="19-观察者模式">19-观察者模式</span>
            <span class="post-date" title="2024-11-25 21:07:00">2024/11/25</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/7dbd9149.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="18-迭代器模式">18-迭代器模式</span>
            <span class="post-date" title="2024-11-24 00:02:00">2024/11/24</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/4fdf6e52.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="17-访问者模式">17-访问者模式</span>
            <span class="post-date" title="2024-11-23 21:55:00">2024/11/23</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/60fd53f.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="16-命令模式">16-命令模式</span>
            <span class="post-date" title="2024-11-23 20:30:00">2024/11/23</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/4930323d.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="15-模板方法模式">15-模板方法模式</span>
            <span class="post-date" title="2024-11-23 19:40:00">2024/11/23</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/e4235185.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="14-代理模式">14-代理模式</span>
            <span class="post-date" title="2024-11-21 23:16:00">2024/11/21</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/1b225c1f.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="13-享元模式">13-享元模式</span>
            <span class="post-date" title="2024-11-20 23:10:00">2024/11/20</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/906e9e8b.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="12-外观模式">12-外观模式</span>
            <span class="post-date" title="2024-11-20 22:09:00">2024/11/20</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/c456a66a.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="11-组合模式">11-组合模式</span>
            <span class="post-date" title="2024-11-16 17:00:00">2024/11/16</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/90213fc6.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="10-装饰器模式">10-装饰器模式</span>
            <span class="post-date" title="2024-11-16 14:06:00">2024/11/16</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/c7419cfa.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="09-桥接模式">09-桥接模式</span>
            <span class="post-date" title="2024-11-14 20:51:00">2024/11/14</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/f77fc055.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="08-适配器模式">08-适配器模式</span>
            <span class="post-date" title="2024-11-12 22:55:00">2024/11/12</span>
        </a>
        
        
        <a  class="全部文章 neo4j "
           href="/blog/a3b0b090.html"
           data-tag="SpringBoot,neo4j"
           data-author="" >
            <span class="post-title" title="Spring Boot对Neo4j节点关系的增删改查">Spring Boot对Neo4j节点关系的增删改查</span>
            <span class="post-date" title="2024-11-12 21:00:30">2024/11/12</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/3ab9aa56.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="07-建造者模式">07-建造者模式</span>
            <span class="post-date" title="2024-11-11 21:55:00">2024/11/11</span>
        </a>
        
        
        <a  class="全部文章 neo4j "
           href="/blog/7dc0fcde.html"
           data-tag="SpringBoot,neo4j"
           data-author="" >
            <span class="post-title" title="Spring Boot整合Neo4j实现增删改查">Spring Boot整合Neo4j实现增删改查</span>
            <span class="post-date" title="2024-11-07 19:04:30">2024/11/07</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/564adc33.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="06-原型模式">06-原型模式</span>
            <span class="post-date" title="2024-11-06 19:00:00">2024/11/06</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/effeea78.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="05-工厂模式">05-工厂模式</span>
            <span class="post-date" title="2024-11-04 21:00:00">2024/11/04</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/d7e99843.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="04-单例模式">04-单例模式</span>
            <span class="post-date" title="2024-11-04 19:00:00">2024/11/04</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/90f1850a.html"
           data-tag="设计模式,UML"
           data-author="" >
            <span class="post-title" title="03-UML类图">03-UML类图</span>
            <span class="post-date" title="2024-11-02 14:57:00">2024/11/02</span>
        </a>
        
        
        <a  class="全部文章 UML "
           href="/blog/c13304c1.html"
           data-tag="设计模式,UML"
           data-author="" >
            <span class="post-title" title="02-UML图绘制工具">02-UML图绘制工具</span>
            <span class="post-date" title="2024-11-02 09:57:00">2024/11/02</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/2e826df1.html"
           data-tag="linux,ubuntu18"
           data-author="" >
            <span class="post-title" title="Docker环境下RTSP流转RTMP和HLS">Docker环境下RTSP流转RTMP和HLS</span>
            <span class="post-date" title="2024-11-01 15:17:33">2024/11/01</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/cd625bba.html"
           data-tag="设计模式,java"
           data-author="" >
            <span class="post-title" title="01-设计模式六大原则">01-设计模式六大原则</span>
            <span class="post-date" title="2024-10-31 17:00:00">2024/10/31</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/1a649f4c.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="13-JUC进阶-ReentrantReadWriteLock与StampedLock">13-JUC进阶-ReentrantReadWriteLock与StampedLock</span>
            <span class="post-date" title="2024-10-19 09:26:00">2024/10/19</span>
        </a>
        
        
        <a  class="全部文章 neo4j "
           href="/blog/5c93903a.html"
           data-tag="linux,neo4j"
           data-author="" >
            <span class="post-title" title="Docker部署Neo4j并导入CSV数据">Docker部署Neo4j并导入CSV数据</span>
            <span class="post-date" title="2024-10-17 15:00:30">2024/10/17</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/ad38e6b1.html"
           data-tag="linux,ubuntu18"
           data-author="" >
            <span class="post-title" title="Ubuntu18.04离线源环境搭建">Ubuntu18.04离线源环境搭建</span>
            <span class="post-date" title="2024-10-17 09:47:33">2024/10/17</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3fdbf0f6.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="12-JUC进阶-从ReentrantLock到AQS源码详解">12-JUC进阶-从ReentrantLock到AQS源码详解</span>
            <span class="post-date" title="2024-10-15 19:42:07">2024/10/15</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3e0d7592.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="11-JUC进阶-Synchronized与锁升级">11-JUC进阶-Synchronized与锁升级</span>
            <span class="post-date" title="2024-10-06 09:28:00">2024/10/06</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4502cffa.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="10-JUC进阶-Java对象内存布局和对象头">10-JUC进阶-Java对象内存布局和对象头</span>
            <span class="post-date" title="2024-10-04 09:54:40">2024/10/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4de6a39b.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="09-JUC进阶-ThreadLocal">09-JUC进阶-ThreadLocal</span>
            <span class="post-date" title="2024-10-01 20:39:10">2024/10/01</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/72329cf5.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="08-JUC进阶-常用的原子操作类(18个)">08-JUC进阶-常用的原子操作类(18个)</span>
            <span class="post-date" title="2024-09-28 13:37:09">2024/09/28</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/5e3757c1.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="07-JUC进阶-CAS">07-JUC进阶-CAS</span>
            <span class="post-date" title="2024-09-26 19:37:00">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/546d628d.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="06-JUC进阶-Volatile与Java内存模型">06-JUC进阶-Volatile与Java内存模型</span>
            <span class="post-date" title="2024-09-25 19:01:01">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/1f2e0014.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="05-JUC进阶-Java内存模型-JMM">05-JUC进阶-Java内存模型-JMM</span>
            <span class="post-date" title="2024-09-23 23:01:07">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/19653fb9.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="04-JUC进阶-LockSupport与线程中断">04-JUC进阶-LockSupport与线程中断</span>
            <span class="post-date" title="2024-09-23 20:51:50">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/219e52ea.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="03-JUC进阶-Java中的锁的解析">03-JUC进阶-Java中的锁的解析</span>
            <span class="post-date" title="2024-09-21 14:15:20">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/7e2d78eb.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="02-JUC进阶-CompletableFuture">02-JUC进阶-CompletableFuture</span>
            <span class="post-date" title="2024-09-18 22:50:00">2024/09/18</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3d102971.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="01-JUC进阶-线程基础">01-JUC进阶-线程基础</span>
            <span class="post-date" title="2024-09-18 22:32:00">2024/09/18</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/37d56d14.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="11-CompletableFuture">11-CompletableFuture</span>
            <span class="post-date" title="2024-09-16 16:12:00">2024/09/16</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/31919959.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="10-Fork/Join">10-Fork/Join</span>
            <span class="post-date" title="2024-09-16 13:10:00">2024/09/16</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/a0197c15.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="09-ThreadPool-线程池">09-ThreadPool-线程池</span>
            <span class="post-date" title="2024-09-13 20:10:08">2024/09/13</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/a6760d1f.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="08-阻塞队列BlockingQueue">08-阻塞队列BlockingQueue</span>
            <span class="post-date" title="2024-09-07 17:30:00">2024/09/07</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/838e7581.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore">07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore</span>
            <span class="post-date" title="2024-09-07 13:00:00">2024/09/07</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/f60e37c5.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="06-Callable &amp; Future 接口">06-Callable &amp; Future 接口</span>
            <span class="post-date" title="2024-09-06 22:10:00">2024/09/06</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/f184587f.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="05-公平锁和非公平锁，死锁，可重入锁">05-公平锁和非公平锁，死锁，可重入锁</span>
            <span class="post-date" title="2024-09-05 20:12:00">2024/09/05</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/9a09d992.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="04-集合的线程安全">04-集合的线程安全</span>
            <span class="post-date" title="2024-09-04 21:09:05">2024/09/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/bd2134da.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="03-线程间通信">03-线程间通信</span>
            <span class="post-date" title="2024-09-04 20:06:00">2024/09/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/850dac3c.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="02-Lock接口">02-Lock接口</span>
            <span class="post-date" title="2024-08-30 19:27:00">2024/08/30</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4e6bd685.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="01-多线程的基本概念">01-多线程的基本概念</span>
            <span class="post-date" title="2024-08-30 19:03:01">2024/08/30</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1b0522f4.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十五章-分析GC日志">第二十五章-分析GC日志</span>
            <span class="post-date" title="2024-08-28 21:36:08">2024/08/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/944806143.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十四章-JVM运行时参数">第二十四章-JVM运行时参数</span>
            <span class="post-date" title="2024-08-27 18:30:10">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/490498600.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-使用OQL语言查询对象信息">第二十三章-使用OQL语言查询对象信息</span>
            <span class="post-date" title="2024-08-24 15:02:10">2024/08/24</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1471620196.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-浅堆-深堆-内存泄漏">第二十三章-浅堆-深堆-内存泄漏</span>
            <span class="post-date" title="2024-08-24 13:04:37">2024/08/24</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/971417975.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-JVM监控及诊断工具-GUI篇">第二十三章-JVM监控及诊断工具-GUI篇</span>
            <span class="post-date" title="2024-08-16 21:00:00">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2165702380.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十二章-JVM监控及诊断工具-命令行篇">第二十二章-JVM监控及诊断工具-命令行篇</span>
            <span class="post-date" title="2024-08-12 19:36:32">2024/08/12</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2681163762.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十一章-性能监控与调优概述">第二十一章-性能监控与调优概述</span>
            <span class="post-date" title="2024-08-12 19:13:06">2024/08/12</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3537043756.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十章-再谈类的加载器">第二十章-再谈类的加载器</span>
            <span class="post-date" title="2024-08-10 13:43:10">2024/08/10</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3387211378.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十九章-类的加载过程详解">第十九章-类的加载过程详解</span>
            <span class="post-date" title="2024-08-02 19:33:27">2024/08/02</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1107503247.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十八章-字节码指令集与解析指令">第十八章-字节码指令集与解析指令</span>
            <span class="post-date" title="2024-08-01 01:40:02">2024/08/01</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2772873157.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十七章-使用javap指令解析class文件">第十七章-使用javap指令解析class文件</span>
            <span class="post-date" title="2024-07-22 23:54:00">2024/07/22</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/143162370.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十六章-Class文件结构">第十六章-Class文件结构</span>
            <span class="post-date" title="2024-07-15 19:54:50">2024/07/15</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/309245330.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十五章-GC日志分析">第十五章-GC日志分析</span>
            <span class="post-date" title="2024-07-13 08:34:00">2024/07/13</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1750792302.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十四章-垃圾收集器">第十四章-垃圾收集器</span>
            <span class="post-date" title="2024-07-10 19:27:00">2024/07/10</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/484946532.html"
           data-tag="算法,合并有序链表"
           data-author="" >
            <span class="post-title" title="合并两个有序链表">合并两个有序链表</span>
            <span class="post-date" title="2024-07-06 09:11:00">2024/07/06</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2929260443.html"
           data-tag="算法,链表"
           data-author="" >
            <span class="post-title" title="链表反转">链表反转</span>
            <span class="post-date" title="2024-07-05 19:45:45">2024/07/05</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/1403776474.html"
           data-tag="算法,选择排序,冒泡排序,插入排序"
           data-author="" >
            <span class="post-title" title="选择-冒泡-插入排序">选择-冒泡-插入排序</span>
            <span class="post-date" title="2024-07-03 11:02:16">2024/07/03</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2561891005.html"
           data-tag="算法,二分法"
           data-author="" >
            <span class="post-title" title="二分搜索">二分搜索</span>
            <span class="post-date" title="2024-06-29 10:04:10">2024/06/29</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2224151177.html"
           data-tag="算法,二进制,位运算"
           data-author="" >
            <span class="post-title" title="二进制和位运算">二进制和位运算</span>
            <span class="post-date" title="2024-06-20 08:04:00">2024/06/20</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2105268063.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十三章-垃圾回收相关概念">第十三章-垃圾回收相关概念</span>
            <span class="post-date" title="2024-01-14 14:27:00">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/364508352.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十二章-垃圾回收概述和相关算法">第十二章-垃圾回收概述和相关算法</span>
            <span class="post-date" title="2024-01-06 16:28:00">2024/01/06</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/2050535563.html"
           data-tag="linux,jenkins"
           data-author="" >
            <span class="post-title" title="Jenkins的安装和搭建自动化部署平台">Jenkins的安装和搭建自动化部署平台</span>
            <span class="post-date" title="2024-01-05 16:00:00">2024/01/05</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2388209687.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十一章-StringTable(字符串常量池)">第十一章-StringTable(字符串常量池)</span>
            <span class="post-date" title="2023-12-25 17:27:06">2023/12/25</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3385856233.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十章-执行引擎">第十章-执行引擎</span>
            <span class="post-date" title="2023-12-23 20:03:00">2023/12/23</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/4075763684.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第九章-对象的实例化内存布局与访问定位">第九章-对象的实例化内存布局与访问定位</span>
            <span class="post-date" title="2023-12-21 11:50:00">2023/12/21</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3720767522.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第八章-直接内存">第八章-直接内存</span>
            <span class="post-date" title="2023-12-20 17:03:00">2023/12/20</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/105864584.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第七章-方法区">第七章-方法区</span>
            <span class="post-date" title="2023-12-14 18:24:00">2023/12/14</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/543408063.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第六章-JVM堆">第六章-JVM堆</span>
            <span class="post-date" title="2023-12-02 08:01:00">2023/12/02</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/554039338.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第五章-本地方法接口">第五章-本地方法接口</span>
            <span class="post-date" title="2023-11-30 17:55:00">2023/11/30</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1123461525.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第四章-虚拟机栈">第四章-虚拟机栈</span>
            <span class="post-date" title="2023-11-28 20:55:00">2023/11/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1626061462.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第三章-运行时数据区">第三章-运行时数据区</span>
            <span class="post-date" title="2023-11-28 19:31:00">2023/11/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/222077543.html"
           data-tag="java,jvm,双亲委派机制"
           data-author="" >
            <span class="post-title" title="第二章-JVM类加载子系统">第二章-JVM类加载子系统</span>
            <span class="post-date" title="2023-11-25 14:35:00">2023/11/25</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1897413233.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第一章-JVM和Java体系结构">第一章-JVM和Java体系结构</span>
            <span class="post-date" title="2023-11-25 10:00:00">2023/11/25</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/4179015178.html"
           data-tag="hexo,github pages,sitemap"
           data-author="" >
            <span class="post-title" title="给博客网站添加站点地图-sitemap">给博客网站添加站点地图-sitemap</span>
            <span class="post-date" title="2023-11-21 20:00:00">2023/11/21</span>
        </a>
        
        
        <a  class="全部文章 Hexo Typora "
           href="/blog/877664098.html"
           data-tag="hexo,typora,github"
           data-author="" >
            <span class="post-title" title="Typora设置图片自动上传Github">Typora设置图片自动上传Github</span>
            <span class="post-date" title="2023-11-20 20:30:00">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/2016918085.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="Hexo博客安装主题">Hexo博客安装主题</span>
            <span class="post-date" title="2023-11-20 00:00:01">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/3069199997.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="Hexo主题常用配置">Hexo主题常用配置</span>
            <span class="post-date" title="2023-11-20 00:00:01">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/3070587776.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="基于Hexo和Github Pages搭建个人博客">基于Hexo和Github Pages搭建个人博客</span>
            <span class="post-date" title="2023-11-18 15:40:20">2023/11/18</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-design-pattern/01-设计模式六大原则" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">01-设计模式六大原则</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="设计模式">设计模式</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">设计模式</a>
            
            <a class="color5">java</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-11-01 16:14:11'>2024-10-31 17:00</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:15.6k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">一、设计模式的目的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88Single-Responsibility-Principle%EF%BC%89"><span class="toc-text">二、单一职责原则（Single Responsibility Principle）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1. 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%B5%E5%AE%88%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-text">2. 为什么要遵守单一职责原则？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E5%BA%94%E7%94%A8%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-text">3. 单一职责原则应用的范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E3%80%90%E6%96%B9%E6%B3%95%E5%B1%82%E9%9D%A2%E3%80%91%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">3.1  【方法层面】单一职责原则的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E3%80%90%E6%8E%A5%E5%8F%A3%E5%B1%82%E9%9D%A2%E3%80%91%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">3.2 【接口层面】单一职责原则的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E9%81%B5%E5%AE%88%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-text">4. 如何遵守单一职责原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%90%88%E7%90%86%E7%9A%84%E8%81%8C%E8%B4%A3%E5%88%86%E8%A7%A3"><span class="toc-text">4.1 合理的职责分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.2 代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">5. 单一职责原则的优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99-Interface-Segregation-Principle"><span class="toc-text">三、接口隔离原则(Interface Segregation Principle)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 接口隔离原则的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E5%92%8C%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-text">2. 接口隔离原则和单一职责原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">3. 接口隔离原则的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">4. 接口隔离原则的实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-text">5. 接口隔离原则的建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">6. 案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%9C%80%E5%88%9D%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.1 最初的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.2 使用接口隔离原则的设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%EF%BC%88Dependence-Inversion-Principle%EF%BC%89"><span class="toc-text">四、依赖倒转原则（Dependence Inversion Principle）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="toc-text">2. 什么是依赖？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BE%9D%E8%B5%96%E7%9A%84%E5%85%B3%E7%B3%BB%E7%A7%8D%E7%B1%BB"><span class="toc-text">3. 依赖的关系种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-text">4. 依赖倒置的案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%88%9D%E6%AD%A5%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-text">4.1 初步设计方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-text">4.2 改进后的方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">5.依赖的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">5.1 依赖注入主要有三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%E5%9C%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">5.2 依赖倒置原则在设计模式中的体现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88Liskov-Substitution-Principle%EF%BC%89"><span class="toc-text">五、里氏替换原则（Liskov Substitution Principle）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-text">1. 什么是里式替换原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 里式替换原则定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E6%9C%89%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%90%AB%E4%B9%89"><span class="toc-text">1.2 里氏替换原则有至少有两种含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">2. 使用里式替换原则的目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E4%B8%8E%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">3. 里式替换原则与继承多态之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">4. 里式替换的规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%BF%9D%E8%83%8C%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E5%AF%B9%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BA%A6%E5%AE%9A"><span class="toc-text">4.1 子类方法不能违背父类方法对输入输出异常的约定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%BF%9D%E8%83%8C%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2 子类方法不能违背父类方法定义的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AD%90%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%8C%E5%85%A8%E5%AE%9E%E7%8E%B0%E7%88%B6%E7%B1%BB%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">4.3 子类必须完全实现父类的抽象方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">5. 里氏替换原则的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">6. 里氏替换原则的实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">7. 案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A1%88%E4%BE%8B%E4%B8%80-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%87%8F"><span class="toc-text">7.1 案例一: 两数相减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%A1%88%E4%BE%8B%E4%BA%8C-%E2%80%9C%E5%87%A0%E7%BB%B4%E9%B8%9F%E4%B8%8D%E6%98%AF%E9%B8%9F%E2%80%9D"><span class="toc-text">7.2 案例二: “几维鸟不是鸟”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88Open-Closed-Principle%EF%BC%89"><span class="toc-text">六、开闭原则（Open Closed Principle）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-text">1. 什么是开闭原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 开闭原则的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-text">2. 如何实现开放封闭原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%8A%BD%E8%B1%A1"><span class="toc-text">2.1 依赖与抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-text">2.2 如何落地开闭原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-text">2.3 开闭原则的重要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-text">2.4 如何使用开闭原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">3. 案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A1%88%E4%BE%8B%E4%B8%80-%E7%94%BB%E5%BD%A2%E7%8A%B6"><span class="toc-text">3.1 案例一: 画形状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="toc-text">3.2 案例二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%88Demeter-Principle%EF%BC%89"><span class="toc-text">七、迪米特法则（Demeter Principle）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-text">1. 什么是迪米特法则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%B5%E5%AE%88%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-text">2. 为什么要遵守迪米特法则?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E7%9A%84%E5%B9%BF%E7%8B%AD%E4%B9%89"><span class="toc-text">3. 迪米特法则的广狭义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%8B%AD%E4%B9%89%E7%9A%84%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-text">3.1 狭义的迪米特法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B9%BF%E4%B9%89%E7%9A%84%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E5%9C%A8%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">3.2 广义的迪米特法则在类的设计上的体现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E5%9C%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4. 迪米特法则在设计模式中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E5%AE%9E%E8%B7%B5"><span class="toc-text">5. 迪米特法则实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%8F%AA%E5%92%8C%E7%9B%B4%E6%8E%A5%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BA%A4%E6%B5%81"><span class="toc-text">5.1 只和直接的朋友交流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%87%8F%E5%B0%91%E5%AF%B9%E6%9C%8B%E5%8F%8B%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-text">5.2 减少对朋友的了解</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、设计模式的目的"><a href="#一、设计模式的目的" class="headerlink" title="一、设计模式的目的"></a>一、设计模式的目的</h1><p>编写软件过程中，程序员面临着来自<strong>耦合性</strong>，<strong>内聚性</strong>以及<strong>可维护性</strong>，<strong>可扩展性</strong>，重用性，<strong>灵活性</strong> 等多方面的 挑战，设计模式是为了让程序(软件) ，具有更好的</p>
<ul>
<li>代码重用性 (即：相同功能的代码，不用多次编写)</li>
<li>可读性 (即：编程规范性,  便于其他程序员的阅读和理解)</li>
<li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li>
<li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li>
<li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li>
</ul>
<h1 id="二、单一职责原则（Single-Responsibility-Principle）"><a href="#二、单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="二、单一职责原则（Single Responsibility Principle）"></a>二、单一职责原则（Single Responsibility Principle）</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>就一个类而言，应该仅有一个引起它变化的原因。应该只有一个职责。如果一个类有一个以上的职责，这些职责就耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。想要避免这种现象的发生，就要尽可能的遵守单一职责原则。</p>
<p>单一职责原则的核心就是<strong>解耦和增强内聚性</strong>。</p>
<h2 id="2-为什么要遵守单一职责原则？"><a href="#2-为什么要遵守单一职责原则？" class="headerlink" title="2. 为什么要遵守单一职责原则？"></a>2. 为什么要遵守单一职责原则？</h2><ul>
<li><p>提高类的可维护性和可读写性</p>
<p>一个类的职责少了，复杂度降低了，代码就少了，可读性也就好了，可维护性自然就高了。</p>
</li>
<li><p>提高系统的可维护性</p>
<p>系统是由类组成的，每个类的可维护性高，相对来讲整个系统的可维护性就高。当然，前提是系统的架构没有问题。</p>
</li>
<li><p>降低变更的风险</p>
<p>一个类的职责越多，变更的可能性就越大，变更带来的风险也就越大</p>
</li>
</ul>
<p>如果在一个类中可能会有多个发生变化的东西，这样的设计会带来风险, 我们尽量保证只有一个可以变化，其他变化的就放在其他类中，这样的好处就是 <strong>提高内聚，降低耦合</strong>。</p>
<h2 id="3-单一职责原则应用的范围"><a href="#3-单一职责原则应用的范围" class="headerlink" title="3. 单一职责原则应用的范围"></a>3. 单一职责原则应用的范围</h2><p>单一职责原则适用的范围有接口、方法类。按大家的说法，<strong>接口和方法必须保证单一职责</strong>，类就不必保证，只要符合业务就行。</p>
<h3 id="3-1-【方法层面】单一职责原则的应用"><a href="#3-1-【方法层面】单一职责原则的应用" class="headerlink" title="3.1  【方法层面】单一职责原则的应用"></a>3.1  【方法层面】单一职责原则的应用</h3><p>现在有一个场景, 需要修改用户的用户名和密码. 就针对这个功能我们可以有多种实现.</p>
<p><strong>第一种:</strong></p>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment"> * 操作的类型</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperateEnum</span> &#123;
    UPDATE_USERNAME,
    UPDATE_PASSWORD;
&#125;

<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOperate</span> &#123;
    <span class="keyword">void</span> <span class="title function_">updateUserInfo</span><span class="params">(OperateEnum type, UserInfo userInfo)</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOperateImpl</span> <span class="keyword">implements</span> <span class="title class_">UserOperate</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserInfo</span><span class="params">(OperateEnum type, UserInfo userInfo)</span> &#123;
        <span class="keyword">if</span> (type == OperateEnum.UPDATE_PASSWORD) &#123;
            <span class="comment">// 修改密码</span>
        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == OperateEnum.UPDATE_USERNAME) &#123;
            <span class="comment">// 修改用户名</span>
        &#125;
    &#125;
&#125;</code></pre>



<p><strong>第二种方法:</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOperate</span> &#123;
    <span class="keyword">void</span> <span class="title function_">updateUserName</span><span class="params">(UserInfo userInfo)</span>;

    <span class="keyword">void</span> <span class="title function_">updateUserPassword</span><span class="params">(UserInfo userInfo)</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOperateImpl</span> <span class="keyword">implements</span> <span class="title class_">UserOperate</span> &#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserName</span><span class="params">(UserInfo userInfo)</span> &#123;
        <span class="comment">// 修改用户名逻辑</span>
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserPassword</span><span class="params">(UserInfo userInfo)</span> &#123;
        <span class="comment">// 修改密码逻辑</span>
    &#125;
&#125;</code></pre>

<p>来看看这两种实现的区别: </p>
<ul>
<li>第一种实现是根据操作类型进行区分, 不同类型执行不同的逻辑. 把修改用户名和修改密码这两件事耦合在一起了. 如果客户端在操作的时候传错了类型, 那么就会发生错误. </li>
<li>第二种实现是我们推荐的实现方式. 修改用户名和修改密码逻辑分开. 各自执行各自的职责, 互不干扰. 功能清晰明了.</li>
</ul>
<p>由此可见, 第二种设计是符合单一职责原则的. 这是在方法层面实现单一职责原则.</p>
<h3 id="3-2-【接口层面】单一职责原则的应用"><a href="#3-2-【接口层面】单一职责原则的应用" class="headerlink" title="3.2 【接口层面】单一职责原则的应用"></a>3.2 【接口层面】单一职责原则的应用</h3><p>我们假设一个场景, 大家一起做家务, 张三扫地, 李四买菜. 李四买完菜回来还得做饭. 这个逻辑怎么实现呢?</p>
<p><strong>方式一</strong></p>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment"> * 做家务</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HouseWork</span> &#123;
    <span class="comment">// 扫地</span>
    <span class="keyword">void</span> <span class="title function_">sweepFloor</span><span class="params">()</span>;

    <span class="comment">// 购物</span>
    <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zhangsan</span> <span class="keyword">implements</span> <span class="title class_">HouseWork</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sweepFloor</span><span class="params">()</span> &#123;
        <span class="comment">// 扫地</span>
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;

    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lisi</span> <span class="keyword">implements</span> <span class="title class_">HouseWork</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sweepFloor</span><span class="params">()</span> &#123;

    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;
        <span class="comment">// 购物</span>
    &#125;
&#125;</code></pre>

<p>首先定义了一个做家务的接口, 定义两个方法扫地和买菜. 张三扫地, 就实现扫地接口. 李四买菜, 就实现买菜接口. 然后李四买完菜回来还要做饭, 于是就要在接口类中增加一个方法cooking. 张三和李四都重写这个方法, 但只有李四有具体实现.</p>
<p>这样设计本身就是不合理的. 首先: 张三只扫地, 但是他需要重写买菜方法, 李四不需要扫地, 但是李四也要重写扫地方法. 第二: 这也不符合开闭原则. 增加一种类型做饭, 要修改3个类. 这样当逻辑很复杂的时候, 很容易引起意外错误.</p>
<p>上面这种设计不符合单一职责原则, 修改一个地方, 影响了其他不需要修改的地方.</p>
<p><strong>方法二</strong></p>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment"> * 做家务</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hoursework</span> &#123;
&#125;

<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shopping</span> <span class="keyword">extends</span> <span class="title class_">Hoursework</span>&#123;
    <span class="comment">// 购物</span>
    <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SweepFloor</span> <span class="keyword">extends</span> <span class="title class_">Hoursework</span>&#123;
    <span class="comment">// 扫地</span>
    <span class="keyword">void</span> <span class="title function_">sweepFlooring</span><span class="params">()</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zhangsan</span> <span class="keyword">implements</span> <span class="title class_">SweepFloor</span>&#123;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sweepFlooring</span><span class="params">()</span> &#123;
        <span class="comment">// 张三扫地</span>
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lisi</span> <span class="keyword">implements</span> <span class="title class_">Shopping</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;
        <span class="comment">// 李四购物</span>
    &#125;
&#125;</code></pre>

<p>上面做家务不是定义成一个接口, 而是将扫地和做家务分开了. 张三扫地, 那么张三就实现扫地的接口. 李四购物, 李四就实现购物的接口. 后面李四要增加一个功能做饭. 那么就新增一个做饭接口, 这次只需要李四实现做饭接口就可以了.</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cooking</span> <span class="keyword">extends</span> <span class="title class_">Hoursework</span>&#123; 
    <span class="keyword">void</span> <span class="title function_">cooking</span><span class="params">()</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lisi</span> <span class="keyword">implements</span> <span class="title class_">Shopping</span>, Cooking&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;
        <span class="comment">// 李四购物</span>
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cooking</span><span class="params">()</span> &#123;
        <span class="comment">// 李四做饭</span>
    &#125;
&#125;</code></pre>

<p>如上, 我们看到张三没有实现多余的接口, 李四也没有. 而且当新增功能的时候, 只影响了李四, 并没有影响张三. 这就是符合单一职责原则. 一个类只做一件事. 并且他的修改不会带来其他的变化.</p>
<h2 id="4-如何遵守单一职责原则"><a href="#4-如何遵守单一职责原则" class="headerlink" title="4. 如何遵守单一职责原则"></a>4. 如何遵守单一职责原则</h2><h3 id="4-1-合理的职责分解"><a href="#4-1-合理的职责分解" class="headerlink" title="4.1 合理的职责分解"></a>4.1 合理的职责分解</h3><p>相同的职责放到一起，不同的职责分解到不同的接口和实现中去，这个是最容易也是最难运用的原则，关键还是要从业务出发，从需求出发，识别出同一种类型的职责。</p>
<p>例子：人的行为分析，包括了生活和工作等行为的分析，生活行为包括吃、跑、睡等行为，工作行为包括上下班，开会等行为，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-161624.png" alt="单一职责原则"></p>
<p>人类的行为分成了两个接口：生活行为接口、工作行为接口，以及两个实现类。如果都用一个实现类来承担这两个接口的职责，就会导致代码臃肿，不易维护，如果以后再加上其他行为，例如学习行为接口，将会产生变更风险（这里还用到了组合模式）。</p>
<h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h3><p><strong>第一步: 定义一个行为接口</strong></p>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment"> * 人的行为</span>
<span class="comment"> * 人的行为包括两种: 生活行为, 工作行为</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBehavior</span> &#123;
    
&#125;</code></pre>

<p>这里面定义了一个空的接口, 行为接口. 具体这个行为接口下面有哪些接口呢?有生活和工作两方面的行为.</p>
<p><strong>第二步: 定义生活和工作接口, 并且他们都是行为接口的子类</strong></p>
<p>生活行为接口:</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LivingBehavior</span> <span class="keyword">extends</span> <span class="title class_">IBehavior</span>&#123;
    <span class="comment">/** 吃饭 */</span>
    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;

    <span class="comment">/** 跑步 */</span>
    <span class="keyword">void</span> <span class="title function_">running</span><span class="params">()</span>;

    <span class="comment">/** 睡觉 */</span>
    <span class="keyword">void</span> <span class="title function_">sleeping</span><span class="params">()</span>;
&#125;</code></pre>

<p>工作行为接口:</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WorkingBehavior</span> <span class="keyword">extends</span> <span class="title class_">IBehavior</span>&#123;

    <span class="comment">/** 上班 */</span>
    <span class="keyword">void</span> <span class="title function_">goToWork</span><span class="params">()</span>;

    <span class="comment">/** 下班 */</span>
    <span class="keyword">void</span> <span class="title function_">goOffWork</span><span class="params">()</span>;

    <span class="comment">/** 开会 */</span>
    <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span>;
&#125;</code></pre>



<p><strong>第三步: 定义工作行为接口和生活行为接口的实现类</strong></p>
<p>生活行为接口实现类:</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LivingBehaviorImpl</span> <span class="keyword">implements</span> <span class="title class_">LivingBehavior</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;吃饭&quot;</span>);
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;跑步&quot;</span>);
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleeping</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;睡觉&quot;</span>);
    &#125;
&#125;</code></pre>

<p>工作行为接口实现类:</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkingBehaviorImpl</span> <span class="keyword">implements</span> <span class="title class_">WorkingBehavior</span>&#123;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToWork</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;上班&quot;</span>);
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goOffWork</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;下班&quot;</span>);
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;开会&quot;</span>);
    &#125;
&#125;</code></pre>



<p><strong>第四步: 行为组合调用</strong></p>
<p>行为接口定义好了. 接下来会定义一个行为集合. 不同的用户拥有的行为是不一样 , 有的用户只用生活行为, 有的用户既有生活行为又有工作行为. 我们并不知道具体用户到底会有哪些行为, 所以,通常使用一个集合来接收用户的行为. 用户有哪些行为, 就往里面添加哪些行为.</p>
<ul>
<li><p>行为组合接口BehaviorComposer</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BehaviorComposer</span> &#123;
    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(IBehavior behavior)</span>;
&#125;</code></pre>
</li>
<li><p>行为组合接口实现类IBehaviorComposerImpl</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBehaviorComposerImpl</span> <span class="keyword">implements</span> <span class="title class_">BehaviorComposer</span> &#123;

    <span class="keyword">private</span> List&lt;IBehavior&gt; behaviors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(IBehavior behavior)</span> &#123;
        System.out.println(<span class="string">&quot;添加行为&quot;</span>);
        behaviors.add(behavior);
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span> &#123;
        behaviors.forEach(b-&gt;&#123;
            <span class="keyword">if</span>(b <span class="keyword">instanceof</span> LivingBehavior) &#123;
                <span class="type">LivingBehavior</span> <span class="variable">li</span> <span class="operator">=</span> (LivingBehavior)b;
                <span class="comment">// 处理生活行为</span>
            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(b <span class="keyword">instanceof</span> WorkingBehavior) &#123;
                <span class="type">WorkingBehavior</span> <span class="variable">wb</span> <span class="operator">=</span> (WorkingBehavior) b;
                <span class="comment">// 处理工作行为</span>
            &#125;

        &#125;);
    &#125;
&#125;</code></pre></li>
</ul>
<p><strong>第五步: 客户端调用</strong></p>
<p>用户在调用的时候, 根据实际情况调用就可以了, 比如下面的代码: 张三是全职妈妈, 只有生活行为, 李四是职场妈妈, 既有生活行为又有工作行为.</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
    <span class="comment">//  张三--全职妈妈</span>
    <span class="type">LivingBehavior</span> <span class="variable">zslivingBehavior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LivingBehaviorImpl</span>();
    <span class="type">BehaviorComposer</span> <span class="variable">zsBehaviorComposer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBehaviorComposerImpl</span>();
    zsBehaviorComposer.add(zslivingBehavior);

    <span class="comment">// 李四--职场妈妈</span>
    <span class="type">LivingBehavior</span> <span class="variable">lsLivingBehavior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LivingBehaviorImpl</span>();
    <span class="type">WorkingBehavior</span> <span class="variable">lsWorkingBehavior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkingBehaviorImpl</span>();
    <span class="type">BehaviorComposer</span> <span class="variable">lsBehaviorComposer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBehaviorComposerImpl</span>();
    lsBehaviorComposer.add(lsLivingBehavior);
    lsBehaviorComposer.add(lsWorkingBehavior);
&#125;</code></pre>



<h2 id="5-单一职责原则的优缺点"><a href="#5-单一职责原则的优缺点" class="headerlink" title="5. 单一职责原则的优缺点"></a>5. 单一职责原则的优缺点</h2><ul>
<li>类的复杂性降低: 一个类实现什么职责都有清晰明确的定义了, 复杂性自然就降低了 </li>
<li>可读性提高: 复杂性降低了，可读性自然就提高了 </li>
<li>可维护性提高: 可读性提高了，代码就更容易维护了 </li>
<li>变更引起的风险降低: 变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口和类无影响，这对系统的扩展性、维护性都有非常大的帮助</li>
</ul>
<h1 id="三、接口隔离原则-Interface-Segregation-Principle"><a href="#三、接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="三、接口隔离原则(Interface Segregation Principle)"></a>三、接口隔离原则(Interface Segregation Principle)</h1><h2 id="1-接口隔离原则的定义"><a href="#1-接口隔离原则的定义" class="headerlink" title="1. 接口隔离原则的定义"></a>1. 接口隔离原则的定义</h2><p>客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。</p>
<p>类间的依赖关系应建立在最小的接口上。</p>
<p>也就是说: 接口尽量细化，接口中的方法尽量少</p>
<h2 id="2-接口隔离原则和单一职责原则"><a href="#2-接口隔离原则和单一职责原则" class="headerlink" title="2. 接口隔离原则和单一职责原则"></a>2. 接口隔离原则和单一职责原则</h2><p>功能上来看，接口隔离原则和单一职责原则都是为了提高类的内聚, 降低类之间的耦合, 体现了封装的思想。但二者还是有区别的。</p>
<ul>
<li>从原则约束来看: 接口隔离原则更关注的是接口依赖程度的隔离；而单一职责原则更加注重的是接口职责的划分。</li>
<li>从接口的细化程度来看: 单一职责原则对接口的划分更加精细，而接口隔离原则注重的是相同功能的接口的隔离。接口隔离里面的最小接口有时可以是多个单一职责的公共接口。</li>
<li>单一职责原则更加偏向对业务的约束: 接口隔离原则更加偏向设计架构的约束。这个应该好理解，职责是根据业务功能来划分的，所以单一原则更加偏向业务；而接口隔离更多是为了“高内聚”，偏向架构的设计。</li>
</ul>
<h2 id="3-接口隔离原则的优点"><a href="#3-接口隔离原则的优点" class="headerlink" title="3. 接口隔离原则的优点"></a>3. 接口隔离原则的优点</h2><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p>
<ul>
<li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li>
<li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li>
<li>如果接口的粒度大小定义合理，能够保证系统的稳定性；然而，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li>
<li>使用多个专门的接口能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li>
<li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li>
</ul>
<h2 id="4-接口隔离原则的实现方法"><a href="#4-接口隔离原则的实现方法" class="headerlink" title="4. 接口隔离原则的实现方法"></a>4. 接口隔离原则的实现方法</h2><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p>
<ul>
<li><p>接口要尽量小</p>
<p>不能出现Fat Interface；但是要有限度，首先不能违反单一职责原则（不能一个接口对应半个职责）。</p>
</li>
<li><p>接口要高内聚</p>
<p> 在接口中尽量少公布public方法。 接口是对外的承诺，承诺越少对系统的开发越有利。</p>
</li>
<li><p>定制服务</p>
<p>只提供访问者需要的方法。例如，为管理员提供IComplexSearcher接口，为公网提供ISimpleSearcher接口。</p>
</li>
<li><p>接口的设计是有限度的</p>
<p>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同, 需要深入了解业务逻辑。</p>
</li>
</ul>
<h2 id="5-接口隔离原则的建议"><a href="#5-接口隔离原则的建议" class="headerlink" title="5. 接口隔离原则的建议"></a>5. 接口隔离原则的建议</h2><ul>
<li>一个接口只服务于一个子模块或业务逻辑；</li>
<li>通过业务逻辑压缩接口中的public方法；</li>
<li>已被污染了的接口，尽量去修改；若变更的风险较大，则采用适配器模式转化处理；</li>
<li>拒绝盲从</li>
</ul>
<h2 id="6-案例分析"><a href="#6-案例分析" class="headerlink" title="6. 案例分析"></a>6. 案例分析</h2><p>下面以学生成绩管理为例来说明接口隔离原则:</p>
<p>分析：学生成绩管理程序一般包含查询成绩、新增成绩、删除成绩、修改成绩、计算总分、计算平均分、打印成绩信息等功能，通常我们会怎么做呢？</p>
<h3 id="6-1-最初的设计"><a href="#6-1-最初的设计" class="headerlink" title="6.1 最初的设计"></a>6.1 最初的设计</h3><p>通常我们设计接口的方式如下:</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudentScore</span> &#123;
    <span class="comment">// 查询成绩</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span>;

    <span class="comment">// 修改成绩</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span>;

    <span class="comment">// 添加成绩</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span>;

    <span class="comment">// 删除成绩</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;

    <span class="comment">// 计算总分</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span>;

    <span class="comment">// 计算平均分</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span>;

    <span class="comment">// 打印成绩单</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span>;

&#125;</code></pre>

<p>我们会吧所有的功能都放在一个接口里面. 这会产生什么样的问题呢?</p>
<p>首先, 接口的方法很多, 不利于扩展. 比如: 学生只有查看成绩,打印成绩单的权限, 没有增删改的权限; 老师拥有所有的权限.</p>
<p><strong>查询成绩单:</strong></p>
<pre><code class="highlight java"><span class="keyword">package</span> com.lxl.www.designPatterns.sixPrinciple.interfaceSegregationPrinciple.score;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueryScore</span> <span class="keyword">implements</span> <span class="title class_">IStudentScore</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;
        <span class="comment">// 查询成绩</span>
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span> &#123;
         <span class="comment">// 没有权限</span>
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span> &#123;
        <span class="comment">// 没有权限</span>
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;
        <span class="comment">// 没有权限</span>
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;
        <span class="comment">// 没有权限</span>
        <span class="keyword">return</span> <span class="number">0</span>;
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span> &#123;
        <span class="comment">// 没有权限</span>
        <span class="keyword">return</span> <span class="number">0</span>;
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;
        <span class="comment">//打印成绩单</span>
    &#125;
&#125;</code></pre>



<p><strong>操作成绩单</strong></p>
<pre><code class="highlight java"><span class="keyword">package</span> com.lxl.www.designPatterns.sixPrinciple.interfaceSegregationPrinciple.score;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Operate</span> <span class="keyword">implements</span> <span class="title class_">IStudentScore</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;
        
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span> &#123;

    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span> &#123;

    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;

    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;
        <span class="keyword">return</span> <span class="number">0</span>;
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span> &#123;
        <span class="keyword">return</span> <span class="number">0</span>;
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;

    &#125;
&#125;</code></pre>

<p>可以看出问题. 查询成绩单, 我们只会用到两个方法, 可是因为实现了接口, 不得不重写所有的方法.</p>
<p> 如果这时候增加需求–发送给家长, 只有老师才有这个权限, 学生没有这个权限. 可是, 在接口中增加一个抽象方法以后, 所有的实现类都要重写这个方法. 这就违背了开闭原则.</p>
<h3 id="6-2-使用接口隔离原则的设计"><a href="#6-2-使用接口隔离原则的设计" class="headerlink" title="6.2 使用接口隔离原则的设计"></a>6.2 使用接口隔离原则的设计</h3><p>采用接口隔离原则设计的接口, 代码如下:</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IQueryScore</span> &#123;
    <span class="comment">// 查询成绩</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span>;

    <span class="comment">// 打印成绩单</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IOperateScore</span> &#123;

    <span class="comment">// 修改成绩</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span>;

    <span class="comment">// 添加成绩</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span>;

    <span class="comment">// 删除成绩</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;

    <span class="comment">// 计算总分</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span>;

    <span class="comment">// 计算平均分</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span>;

&#125;


<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperate</span> <span class="keyword">implements</span> <span class="title class_">IQueryScore</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;
        <span class="comment">// 查询成绩</span>
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;
        <span class="comment">//打印成绩单</span>
    &#125;
&#125;


<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherOperate</span> <span class="keyword">implements</span> <span class="title class_">IQueryScore</span>, IOperateScore&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;

    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span> &#123;

    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span> &#123;

    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;

    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;
        <span class="keyword">return</span> <span class="number">0</span>;
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span> &#123;
        <span class="keyword">return</span> <span class="number">0</span>;
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;

    &#125;
&#125;</code></pre>

<p>我们将原来的一个接口进行了接口拆分. 分为查询接口和操作接口. 这样学生端就不需要重写和他不相关的接口了.</p>
<p>如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中。</p>
<h1 id="四、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#四、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="四、依赖倒转原则（Dependence Inversion Principle）"></a>四、依赖倒转原则（Dependence Inversion Principle）</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>依赖倒置原则(Dependence Inversion Principle, DIP), 其含义:</p>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li>
<li>抽象不应该依赖细节, 细节应该依赖于抽象</li>
<li>要针对接口编程，不要针对实现编程</li>
</ul>
<h2 id="2-什么是依赖？"><a href="#2-什么是依赖？" class="headerlink" title="2. 什么是依赖？"></a>2. 什么是依赖？</h2><p>这里的依赖关系我们理解为UML关系中的依赖。简单的说就是A use B，那么A对B产生了依赖。具体请看下面的例子。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190021.png" alt="依赖"></p>
<p>从上图中我们可以发现, 类A中的<code>方法a()</code>里面用到了类B, 其实这就是依赖关系, A依赖了B. 需要注意的是: 并不是说A中声明了B就叫依赖, 如果引用了但是没有真实调用方法, 那么叫做零耦合关系. 如下图:</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190058.png" alt="零耦合"></p>
<h2 id="3-依赖的关系种类"><a href="#3-依赖的关系种类" class="headerlink" title="3. 依赖的关系种类"></a>3. 依赖的关系种类</h2><p>1、零耦合关系：如果两个类之间没有耦合关系，称之为零耦合</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190458.png" alt="零耦合关系"></p>
<p>2、直接耦合关系: 具体耦合发生在两个具体类（可实例化的）之间，经由一个类对另一个类的直接引用造成。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190516.png" alt="直接耦合关系"></p>
<p>3、抽象耦合关系: 抽象耦合关系发生在一个具体类和一个抽象类（或者java接口）之间，使两个必须发生关系的类之间存在最大的灵活性。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190525.png" alt="抽象耦合关系"></p>
<p>依赖倒转原则就是要针对接口编程，不要针对实现编程。这就是说，应当使用接口或者抽象类进行<strong>变量的类型声明</strong>，<strong>参数的类型声明</strong>，<strong>方法的返回类型说明</strong>，<strong>以及数据类型的转换</strong>等。</p>
<h2 id="4-依赖倒置的案例"><a href="#4-依赖倒置的案例" class="headerlink" title="4. 依赖倒置的案例"></a>4. 依赖倒置的案例</h2><h3 id="4-1-初步设计方案"><a href="#4-1-初步设计方案" class="headerlink" title="4.1 初步设计方案"></a>4.1 初步设计方案</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Benz</span> &#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;奔驰跑起来了!&quot;</span>);
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;
    <span class="keyword">private</span> String name;
    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">(String name)</span> &#123;
        <span class="built_in">this</span>.name = name;
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(Benz benz)</span> &#123;
        benz.run();
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">Benz</span> <span class="variable">benz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Benz</span>();
        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>(<span class="string">&quot;张三&quot;</span>);
        driver.driver(benz);
    &#125;
&#125;</code></pre>

<p>有一个驾驶员张三可以驾驶奔驰汽车, 于是最开始我们思考, 会有一个驾驶员类, 有一个奔驰汽车类. 随着业务的发展, 我们发现, 驾驶员张三还可以驾驶宝马.</p>
<p>于是,我们定义一个BM类,</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BM</span> &#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;宝马跑起来了!&quot;</span>);
    &#125;
&#125;</code></pre>

<p>这时, 张三如果想要开宝马, 就要将宝马注册在他名下.</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;
    <span class="keyword">private</span> String name;
    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">(String name)</span> &#123;
        <span class="built_in">this</span>.name = name;
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(Benz benz)</span> &#123;
        benz.run();
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(BM bm)</span> &#123;
        bm.run();
    &#125;

&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">Benz</span> <span class="variable">benz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Benz</span>();
        <span class="type">BM</span> <span class="variable">bm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BM</span>();
        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>(<span class="string">&quot;张三&quot;</span>);
        driver.driver(benz);
        driver.driver(bm);
    &#125;
&#125;</code></pre>

<p>似乎这样就可以了, 但是这样有什么问题呢?</p>
<ul>
<li>如果张三有一天要开大众, 还要增加一个大众车类, 同时还得挂载司机名下.</li>
<li>不是所有的人都要开奔驰, 开宝马. 开大众.</li>
</ul>
<p>这就是面向实现编程的问题, 接下来我们就要考虑面向接口编程.</p>
<h3 id="4-2-改进后的方案"><a href="#4-2-改进后的方案" class="headerlink" title="4.2 改进后的方案"></a>4.2 改进后的方案</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICar</span> &#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Benz</span> <span class="keyword">implements</span> <span class="title class_">ICar</span>&#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;奔驰跑起来了!&quot;</span>);
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BM</span> <span class="keyword">implements</span> <span class="title class_">ICar</span>&#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;宝马跑起来了!&quot;</span>);
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDriver</span> &#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(ICar car)</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">implements</span> <span class="title class_">IDriver</span>&#123;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(ICar car)</span> &#123;
        car.run();
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">IDriver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();
        driver.driver(<span class="keyword">new</span> <span class="title class_">Benz</span>());
        driver.driver(<span class="keyword">new</span> <span class="title class_">BM</span>());
    &#125;
&#125;</code></pre>

<p>修改后的代码, 提炼出来一个IDriver接口和ICar接口, 面向接口编程. IDriver的实现类驾驶员可以driver任何类型的汽车, 所以传入参数也是一个接口ICar. 任何类型的汽车, 都可以通过实现ICar接口注册为一种新的汽车类型. 当客户端调用的时候, 将对应的汽车传入就可以了.</p>
<h2 id="5-依赖的方式"><a href="#5-依赖的方式" class="headerlink" title="5.依赖的方式"></a>5.依赖的方式</h2><h3 id="5-1-依赖注入主要有三种方式"><a href="#5-1-依赖注入主要有三种方式" class="headerlink" title="5.1 依赖注入主要有三种方式"></a>5.1 依赖注入主要有三种方式</h3><ul>
<li><p>构造注入</p>
<p>在构造的时候注入依赖</p>
</li>
<li><p>Setter方法注入</p>
</li>
<li><p>接口方法中注入(汽车的例子使用的就是此方法)</p>
</li>
</ul>
<h3 id="5-2-依赖倒置原则在设计模式中的体现"><a href="#5-2-依赖倒置原则在设计模式中的体现" class="headerlink" title="5.2 依赖倒置原则在设计模式中的体现"></a>5.2 依赖倒置原则在设计模式中的体现</h3><ul>
<li>简单工厂设计模式, 使用的是接口方法中注入</li>
<li>策略设计模式: 在构造函数中注入</li>
</ul>
<h1 id="五、里氏替换原则（Liskov-Substitution-Principle）"><a href="#五、里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="五、里氏替换原则（Liskov Substitution Principle）"></a>五、里氏替换原则（Liskov Substitution Principle）</h1><h2 id="1-什么是里式替换原则"><a href="#1-什么是里式替换原则" class="headerlink" title="1. 什么是里式替换原则"></a>1. 什么是里式替换原则</h2><h3 id="1-1-里式替换原则定义"><a href="#1-1-里式替换原则定义" class="headerlink" title="1.1 里式替换原则定义"></a>1.1 里式替换原则定义</h3><p>里式替换原则是用来帮助我们在继承关系中进行父子类的设计。</p>
<p>里氏替换原则（Liskov Substitution principle）是对子类型的特别定义的. 为什么叫里式替换原则呢?因为这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p>
<p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p>
<p>里式替换原则有两层定义: </p>
<p>定义1：</p>
<blockquote>
<p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。 如果S是T的子类，则T的对象可以替换为S的对象，而不会破坏程序。</p>
</blockquote>
<p>定义2：</p>
<blockquote>
<p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。<br>所有引用其父类对象方法的地方，都可以透明的替换为其子类对象</p>
</blockquote>
<p>这两种定义方式其实都是一个意思，即：应用程序中任何父类对象出现的地方，我们都可以用其子类的对象来替换，并且可以保证原有程序的逻辑行为和正确性。</p>
<h3 id="1-2-里氏替换原则有至少有两种含义"><a href="#1-2-里氏替换原则有至少有两种含义" class="headerlink" title="1.2 里氏替换原则有至少有两种含义"></a>1.2 里氏替换原则有至少有两种含义</h3><ul>
<li>里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。</li>
<li>如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</li>
</ul>
<p>不符合LSP的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。</p>
<h2 id="2-使用里式替换原则的目的"><a href="#2-使用里式替换原则的目的" class="headerlink" title="2. 使用里式替换原则的目的"></a>2. 使用里式替换原则的目的</h2><p>采用里氏替换原则就是为了减少继承带来的缺点，增强程序的健壮性，版本升级时也可以保持良好的兼容性。即使增加子类，原有的子类也可以继续运行。</p>
<h2 id="3-里式替换原则与继承多态之间的关系"><a href="#3-里式替换原则与继承多态之间的关系" class="headerlink" title="3. 里式替换原则与继承多态之间的关系"></a>3. 里式替换原则与继承多态之间的关系</h2><p>里式替换原则和继承多态有关系, 但是他俩并不是一回事. 我们来看看下面的案例</p>
<pre><code class="highlight java">
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;

    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Redis</span> <span class="keyword">extends</span> <span class="title class_">Cache</span> &#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;

    &#125;
&#125;


<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memcache</span> <span class="keyword">extends</span> <span class="title class_">Cache</span> &#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;

    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheTest</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="comment">// 父类对象都可以接收子类对象</span>
        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>();
        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);

        cache = <span class="keyword">new</span> <span class="title class_">Redis</span>();
        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);

        cache = <span class="keyword">new</span> <span class="title class_">Memcache</span>();
        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);
    &#125;
&#125;</code></pre>

<p>通过上面的例子, 可以看出Cache是父类, Redis 和 Memcache是子类, 他们继承自Cache. 这是继承和多态的思想. 而且这两个子类目前为止也都符合里式替换原则.可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。 看最后的CacheTest类, 我们使用父类的cache可以接收任何一种类型的缓存对象, 包括父类和子类.</p>
<p>但如果我们对Redis中的set方法做了长度校验</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Redis</span> <span class="keyword">extends</span> <span class="title class_">Cache</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;
        <span class="keyword">if</span> (key == <span class="literal">null</span> || key.length() &lt; <span class="number">10</span> || key.length() &gt; <span class="number">100</span>) &#123;
            System.out.println(<span class="string">&quot;key的长度不符合要求&quot;</span>);
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(key的长度不符合要求);
        &#125;
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheTest</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="comment">// 父类对象都可以接收子类对象</span>
        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>();
        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);

        cache = <span class="keyword">new</span> <span class="title class_">Redis</span>();
        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);
    &#125;
&#125;</code></pre>

<p>如上情况, 如果我们使用父类对象时替换成子类对象, 那么就会抛出异常. 程序的逻辑行为就发生了变化，虽然改造之后的代码仍然可以通过子类来替换父类 ，但是，从设计思路上来讲，Redis子类的设计是不符合里式替换原则的。</p>
<p>继承和多态是面向对象语言所提供的一种语法，是代码实现的思路，而里式替换则是一种思想，一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p>
<h2 id="4-里式替换的规则"><a href="#4-里式替换的规则" class="headerlink" title="4. 里式替换的规则"></a>4. 里式替换的规则</h2><p>里式替换原则的核心就是“约定”，父类与子类的约定。里氏替换原则要求子类在进行设计的时候要遵守父类的一些行为约定。这里的行为约定包括：函数所要实现的功能，对输入、输出、异常的约定，甚至包括注释中一些特殊说明等。</p>
<h3 id="4-1-子类方法不能违背父类方法对输入输出异常的约定"><a href="#4-1-子类方法不能违背父类方法对输入输出异常的约定" class="headerlink" title="4.1 子类方法不能违背父类方法对输入输出异常的约定"></a>4.1 子类方法不能违背父类方法对输入输出异常的约定</h3><p>1、前置条件不能被加强</p>
<p>前置条件即输入参数是不能被加强的，就像上面Cache的示例，Redis子类对输入参数Key的要求进行了加强，此时在调用处替换父类对象为子类对象就可能引发异常。</p>
<p>也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p>
<p>2、后置条件不能被削弱</p>
<p>后置条件即输出，假设我们的父类方法约定输出参数要大于0，调用父类方法的程序根据约定对输出参数进行了大于0的验证。而子类在实现的时候却输出了小于等于0的值。此时子类的涉及就违背了里氏替换原则</p>
<p>3、不能违背对异常的约定</p>
<p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常， 那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p>
<h3 id="4-2-子类方法不能违背父类方法定义的功能"><a href="#4-2-子类方法不能违背父类方法定义的功能" class="headerlink" title="4.2 子类方法不能违背父类方法定义的功能"></a>4.2 子类方法不能违背父类方法定义的功能</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;
    <span class="keyword">private</span> BigDecimal amount;
    <span class="keyword">private</span> Calendar createTime;
 
    <span class="keyword">public</span> BigDecimal <span class="title function_">getAmount</span><span class="params">()</span> &#123;
        <span class="keyword">return</span> amount;
    &#125;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAmount</span><span class="params">(BigDecimal amount)</span> &#123;
        <span class="built_in">this</span>.amount = amount;
    &#125;
 
    <span class="keyword">public</span> Calendar <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;
        <span class="keyword">return</span> createTime;
    &#125;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Calendar createTime)</span> &#123;
        <span class="built_in">this</span>.createTime = createTime;
    &#125;
&#125;
 
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductSort</span> <span class="keyword">extends</span> <span class="title class_">Sort</span>&lt;Product&gt; &#123;
 
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortByAmount</span><span class="params">(List&lt;Product&gt; list)</span> &#123;
        <span class="comment">//根据时间进行排序</span>
        list.sort((h1, h2)-&gt;h1.getCreateTime().compareTo(h2.getCreateTime()));
    &#125;
&#125;</code></pre>

<p>父类中提供的 sortByAmount() 排序函数，是按照金额从小到大来进行排序的，而子类重写这个 sortByAmount() 排序函数之后，却是是按照创建日期来进行排序的。那子类的设计就违背里式替换原则。</p>
<p>实际上对于如何验证子类设计是否符合里氏替换原则其实有一个小技巧，那就是你可以使用父类的单测来运行子类的代码，如果不可以正常运行，那么你就要考虑一下自己的设计是否合理了！</p>
<h3 id="4-3-子类必须完全实现父类的抽象方法"><a href="#4-3-子类必须完全实现父类的抽象方法" class="headerlink" title="4.3 子类必须完全实现父类的抽象方法"></a>4.3 子类必须完全实现父类的抽象方法</h3><p>如果你设计的子类不能完全实现父类的抽象方法那么你的设计就不满足里式替换原则。</p>
<pre><code class="highlight java"><span class="comment">// 定义抽象类枪</span>
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractGun</span>&#123;
    <span class="comment">// 射击</span>
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>;
    
    <span class="comment">// 杀人</span>
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>;
&#125;</code></pre>

<p>比如我们定义了一个抽象的枪类，可以射击和杀人。无论是步枪还是手枪都可以射击和杀人，我们可以定义子类来继承父类</p>
<pre><code class="highlight java"><span class="comment">// 定义手枪，步枪，机枪</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handgun</span> <span class="keyword">extends</span> <span class="title class_">AbstractGun</span>&#123;   
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>&#123;  
         <span class="comment">// 手枪射击</span>
    &#125;
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;    
        <span class="comment">// 手枪杀人</span>
    &#125;
&#125;
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rifle</span> <span class="keyword">extends</span> <span class="title class_">AbstractGun</span>&#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>&#123;
         <span class="comment">// 步枪射击</span>
    &#125;
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;    
         <span class="comment">// 步枪杀人</span>
    &#125;
&#125;</code></pre>

<p>但是如果我们在这个继承体系内加入一个玩具枪，就会有问题了，因为玩具枪只能射击，不能杀人。但是很多人写代码经常会这么写。</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToyGun</span> <span class="keyword">extends</span> <span class="title class_">AbstractGun</span>&#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>&#123;
        <span class="comment">// 玩具枪射击</span>
    &#125;
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123; 
        <span class="comment">// 因为玩具枪不能杀人，就返回空，或者直接throw一个异常出去</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;我是个玩具枪，惊不惊喜，意不意外，刺不刺激？&quot;</span>);
    &#125;
&#125;</code></pre>

<p>这时，我们如果把使用父类对象的地方替换为子类对象，显然是会有问题的。</p>
<p>而这种情况不仅仅不满足里氏替换原则，也不满足接口隔离原则，对于这种场景可以通过 <strong>接口隔离+委托</strong> 的方式来解决。</p>
<h2 id="5-里氏替换原则的作用"><a href="#5-里氏替换原则的作用" class="headerlink" title="5. 里氏替换原则的作用"></a>5. 里氏替换原则的作用</h2><ul>
<li>里氏替换原则是实现开闭原则的重要方式之一。</li>
<li>它克服了继承中重写父类造成的可复用性变差的缺点。</li>
<li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li>
<li>加强程序的健壮性，同时变更时可以做 到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li>
</ul>
<p><strong>尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。</strong></p>
<h2 id="6-里氏替换原则的实现方法"><a href="#6-里氏替换原则的实现方法" class="headerlink" title="6. 里氏替换原则的实现方法"></a>6. 里氏替换原则的实现方法</h2><p>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>
<p>根据上述理解，对里氏替换原则的定义可以总结如下：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li>
<li>子类中可以增加自己特有的方法</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li>
<li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等</li>
</ul>
<p>通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p>
<p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p>
<h2 id="7-案例分析"><a href="#7-案例分析" class="headerlink" title="7. 案例分析"></a>7. 案例分析</h2><h3 id="7-1-案例一-两数相减"><a href="#7-1-案例一-两数相减" class="headerlink" title="7.1 案例一: 两数相减"></a>7.1 案例一: 两数相减</h3><p>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p>
<p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<blockquote>
<p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p>
</blockquote>
<pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">A</span>&#123;
	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;
		<span class="keyword">return</span> a-b;
	&#125;
&#125;
 
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;
		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();
		System.out.println(<span class="string">&quot;100-50=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));
		System.out.println(<span class="string">&quot;100-80=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));
	&#125;
&#125;</code></pre>

<p>运行结果：</p>
<pre><code class="highlight shell">100-50=50 
100-80=20</code></pre>

<p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p>
<ol>
<li>两数相减。</li>
<li>两数相加，然后再加100。</li>
</ol>
<p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</p>
<pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;
	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;
		<span class="keyword">return</span> a+b;
	&#125;
	
	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;
		<span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;
	&#125;
&#125;
 
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;
		<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();
		System.out.println(<span class="string">&quot;100-50=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));
		System.out.println(<span class="string">&quot;100-80=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));
		System.out.println(<span class="string">&quot;100+20+100=&quot;</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));
	&#125;
&#125;</code></pre>

<p>类B完成后，运行结果：</p>
<pre><code class="highlight shell">100-50=150 
100-80=180 
100+20+100=220</code></pre>

<p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较<strong>通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</strong></p>
<h3 id="7-2-案例二-“几维鸟不是鸟”"><a href="#7-2-案例二-“几维鸟不是鸟”" class="headerlink" title="7.2 案例二: “几维鸟不是鸟”"></a>7.2 案例二: “几维鸟不是鸟”</h3><p>需求分析: 鸟通常都是会飞的, 比如燕子每小时120千米, 但是新西兰的几维鸟由于翅膀退化不会飞. 假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 下 所示。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-202900.png" alt="里氏替换原则"></p>
<p>源码如下:</p>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment"> * 鸟</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;
    <span class="comment">// 飞行的速度</span>
    <span class="keyword">private</span> <span class="type">double</span> flySpeed;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;
        <span class="built_in">this</span>.flySpeed = flySpeed;
    &#125;

    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getFlyTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;
        <span class="keyword">return</span> distance/flySpeed;
    &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 燕子</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swallow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 几维鸟</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kiwi</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;
        flySpeed = <span class="number">0</span>;
    &#125;
&#125;

<span class="comment">/**</span>
<span class="comment">  * 测试飞行耗费时间</span>
<span class="comment">  */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BirdTest</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">Bird</span> <span class="variable">bird1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swallow</span>();
        <span class="type">Bird</span> <span class="variable">bird2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kiwi</span>();
        bird1.setFlySpeed(<span class="number">120</span>);
        bird2.setFlySpeed(<span class="number">120</span>);
        System.out.println(<span class="string">&quot;如果飞行300公里：&quot;</span>);
        <span class="keyword">try</span> &#123;
            System.out.println(<span class="string">&quot;燕子花费&quot;</span> + bird1.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时.&quot;</span>);
            System.out.println(<span class="string">&quot;几维花费&quot;</span> + bird2.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时。&quot;</span>);
        &#125; <span class="keyword">catch</span> (Exception err) &#123;
            System.out.println(<span class="string">&quot;发生错误了!&quot;</span>);
        &#125;
    &#125;
&#125;</code></pre>

<p>运行结果:</p>
<pre><code class="highlight java">如果飞行<span class="number">300</span>公里： 燕子花费<span class="number">2.5</span>小时. 几维花费Infinity小时。</code></pre>

<p>程序运行错误的原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。其类图如图 下所示。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-203352.png" alt="里氏替换原则2"></p>
<p>源代码实现如下</p>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment"> * 动物</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;
    <span class="keyword">private</span> <span class="type">double</span> runSpeed;

    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRunTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;
        <span class="keyword">return</span> distance/runSpeed;
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunSpeed</span><span class="params">(<span class="type">double</span> runSpeed)</span> &#123;
        <span class="built_in">this</span>.runSpeed = runSpeed;
    &#125;
&#125;


<span class="comment">/**</span>
<span class="comment"> * 鸟</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;
    <span class="comment">// 飞行的速度</span>
    <span class="keyword">private</span> <span class="type">double</span> flySpeed;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;
        <span class="built_in">this</span>.flySpeed = flySpeed;
    &#125;

    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getFlyTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;
        <span class="keyword">return</span> distance/flySpeed;
    &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 燕子</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swallow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 几维鸟</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kiwi</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunSpeed</span><span class="params">(<span class="type">double</span> runSpeed)</span> &#123;
        <span class="built_in">super</span>.setRunSpeed(runSpeed);
    &#125;
&#125;

<span class="comment">/**</span>
<span class="comment">  * 测试飞行耗费时间</span>
<span class="comment">  */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BirdTest</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">Bird</span> <span class="variable">bird1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swallow</span>();
        <span class="type">Animal</span> <span class="variable">bird2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kiwi</span>();
        bird1.setFlySpeed(<span class="number">120</span>);
        bird2.setRunSpeed(<span class="number">110</span>);
        System.out.println(<span class="string">&quot;如果飞行300公里：&quot;</span>);
        <span class="keyword">try</span> &#123;
            System.out.println(<span class="string">&quot;燕子花费&quot;</span> + bird1.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时.&quot;</span>);
            System.out.println(<span class="string">&quot;几维鸟花费&quot;</span> + bird2.getRunTime(<span class="number">300</span>) + <span class="string">&quot;小时。&quot;</span>);
        &#125; <span class="keyword">catch</span> (Exception err) &#123;
            System.out.println(<span class="string">&quot;发生错误了!&quot;</span>);
        &#125;
    &#125;
&#125;</code></pre>

<p>运行结果</p>
<pre><code class="highlight shell">如果飞行300公里： 燕子花费2.5小时. 几维鸟花费2.727272727272727小时。</code></pre>



<p><strong>总结:</strong></p>
<p>面向对象的编程思想中提供了继承和多态是我们可以很好的实现代码的复用性和可扩展性，但继承并非没有缺点，因为继承的本身就是具有侵入性的，如果使用不当就会大大增加代码的耦合性，而降低代码的灵活性，增加我们的维护成本，然而在实际使用过程中却往往会出现滥用继承的现象，而里式替换原则可以很好的帮助我们在继承关系中进行父子类的设计。</p>
<h1 id="六、开闭原则（Open-Closed-Principle）"><a href="#六、开闭原则（Open-Closed-Principle）" class="headerlink" title="六、开闭原则（Open Closed Principle）"></a>六、开闭原则（Open Closed Principle）</h1><h2 id="1-什么是开闭原则"><a href="#1-什么是开闭原则" class="headerlink" title="1. 什么是开闭原则"></a>1. 什么是开闭原则</h2><p>开放封闭原则（OCP，Open Closed Principle）是所有面向对象原则的核心。软件设计本身所追求的目标就是封装变化、降低耦合，而开放封闭原则正是对这一目标的最直接体现。其他的设计原则，很多时候是为实现这一目标服务的.</p>
<h3 id="1-1-开闭原则的定义"><a href="#1-1-开闭原则的定义" class="headerlink" title="1.1 开闭原则的定义"></a>1.1 开闭原则的定义</h3><blockquote>
<p>Software entities like classes,modules and functions should be open for extension but closed for modifications 一个软件实体, 如类, 模块, 函数等应该对扩展开放, 对修改封闭.</p>
</blockquote>
<p>这也是开放封闭原则的核心思想：对扩展开放，对修改封闭.</p>
<ul>
<li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li>
<li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对已有代码进行任何修改</li>
</ul>
<h2 id="2-如何实现开放封闭原则"><a href="#2-如何实现开放封闭原则" class="headerlink" title="2. 如何实现开放封闭原则"></a>2. 如何实现开放封闭原则</h2><p>“需求总是变化”、“世界上没有一个软件是不变的”。这里投射出的意思是：需求总是变化的， 可是对于软件设计者来说, 如何才能做到不对原有系统修改的前提下, 实现灵活的扩展. 这就是开闭原则要实现的.</p>
<p>我们在设计系统的时候, 不可能设想一次性把需求确定后, 后面就不改变了.这不科学也不现实的. 既然需求是一定会变化的, 那么我们要如何优雅的面对这种变化呢? 如何设计可以使软件相对容易修改, 不至于需求一变, 就要把整个程序推到重来?</p>
<blockquote>
<p>开封-封闭原则. 设计软件要容易维护且不容易出问题的最好办法, 就是多扩展, 少修改.</p>
</blockquote>
<h3 id="2-1-依赖与抽象"><a href="#2-1-依赖与抽象" class="headerlink" title="2.1 依赖与抽象"></a>2.1 依赖与抽象</h3><p>实现开放封闭的核心思想就是面对抽象编程，而不是面对具体编程，因为抽象相对稳定。 让类依赖于固定的抽象，所以对修改是封闭的；而通过面向对象的继承和多态机制，可以实现对抽象体的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。这是实施开放封闭原则的基本思路。</p>
<h3 id="2-2-如何落地开闭原则"><a href="#2-2-如何落地开闭原则" class="headerlink" title="2.2 如何落地开闭原则"></a>2.2 如何落地开闭原则</h3><p>如果当前的设计不符合开放封闭原则，则必须进行重构。常用的设计模式主要有 <strong>模板方法（Template Method）设计模式</strong> 和 <strong>策略（Strategy）设计模式</strong> 。而封装变化，是实现这一原则的重要手段，将经常发生变化的部分封装为一个类。</p>
<h3 id="2-3-开闭原则的重要性"><a href="#2-3-开闭原则的重要性" class="headerlink" title="2.3 开闭原则的重要性"></a>2.3 开闭原则的重要性</h3><ol>
<li><p>开闭原则对测试的影响</p>
<p>开闭原则可是保持原有的测试代码仍然能够正常运行，我们只需要对扩展的代码进行测试就可以了。</p>
</li>
<li><p>开闭原则可以提高复用性</p>
<p>在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。</p>
</li>
<li><p>开闭原则可以提高可维护性</p>
<p>面向对象开发的要求。</p>
</li>
</ol>
<h3 id="2-4-如何使用开闭原则"><a href="#2-4-如何使用开闭原则" class="headerlink" title="2.4 如何使用开闭原则"></a>2.4 如何使用开闭原则</h3><ul>
<li><p>抽象约束</p>
<ul>
<li>第一，通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的<strong>public</strong>方法；</li>
<li>第二，参数类型、引用对象尽量使用接口或者抽象类，而不是实现类； </li>
<li>第三，抽象层尽量保持稳定，一旦确定即不允许修改。</li>
</ul>
</li>
<li><p>元数据（metadata）控制模块行为</p>
<p>元数据就是用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。 </p>
<p>Spring容器就是一个典型的元数据控制模块行为的例子，其中达到极致的就是控制反转（Inversion of Control）</p>
</li>
<li><p>制定项目章程</p>
<p>在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。</p>
</li>
<li><p>封装变化</p>
<p>对变化的封装包含两层含义： </p>
<p>​	第一，将相同的变化封装到一个接口或者抽象类中； </p>
<p>​	第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。</p>
</li>
</ul>
<h2 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3. 案例分析"></a>3. 案例分析</h2><h3 id="3-1-案例一-画形状"><a href="#3-1-案例一-画形状" class="headerlink" title="3.1 案例一: 画形状"></a>3.1 案例一: 画形状</h3><p>需求: 有圆形, 有椭圆形, 根据要求画出相应的形状</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Shape shape)</span> &#123;
        <span class="keyword">if</span> (shape.m_type == <span class="number">1</span>) &#123;
            drawRectangle();
        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shape.m_type == <span class="number">2</span>) &#123;
            drawCircle();
        &#125;
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;画长方形&quot;</span>);
    &#125;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;画圆形&quot;</span>);
    &#125;

    <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;
        <span class="type">int</span> m_type;
    &#125;

    <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;
        Rectangle() &#123;
            <span class="built_in">super</span>.m_type=<span class="number">1</span>;
        &#125;
    &#125;

    <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;
        Circle() &#123;
            <span class="built_in">super</span>.m_type=<span class="number">2</span>;
        &#125;
    &#125;

&#125;</code></pre>

<p>我们来看看, 这个代码, 初看是符合要求了, 再想想, 要是我增加一种形状呢? 比如增加三角形. </p>
<ul>
<li><p>首先, 要增加一个三角形的类, 继承自Shape ;</p>
</li>
<li><p>第二, 要增加一个画三角形的方法drawTrriage() ;</p>
</li>
<li><p>第三, 在draw方法中增加一种类型type&#x3D;3的处理方案</p>
</li>
</ul>
<p> 这就违背了开闭原则-对扩展开发, 对修改关闭. 增加一个类型, 修改了三处代码.</p>
<p>我们来看看合适的设计</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphicEditor1</span> &#123;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Shape shape)</span> &#123;
        shape.draw();
    &#125;

    <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;
        <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;
    &#125;

    <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;
        <span class="meta">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;
            System.out.println(<span class="string">&quot;画矩形&quot;</span>);
        &#125;
    &#125;

    <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;
        <span class="meta">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;
            System.out.println(<span class="string">&quot;画圆形&quot;</span>);
        &#125;
    &#125;

&#125;</code></pre>

<p>各种类型的形状自己规范自己的行为, 而 <code>GraphicEditor.draw()</code> 只负责画出来. 当增加一种类型三角形. 只需要 </p>
<ul>
<li><p>第一: 增加一个三角形的类,实现Shape接口 </p>
</li>
<li><p>第二, 调用draw方法,划出来就可以了.</p>
</li>
</ul>
<p>整个过程都是在扩展, 而没有修改原来的类. 这个设计是符合开闭原则的.</p>
<h3 id="3-2-案例二"><a href="#3-2-案例二" class="headerlink" title="3.2 案例二"></a>3.2 案例二</h3><p>比如现在有一个银行业务, 存钱, 取钱和转账. 最初我们会怎么思考呢?</p>
<ul>
<li>首先有一个银行业务类, 用来处理银行的业务</li>
<li>银行有哪些业务呢? 存钱,取钱,转账, 这都是银行要执行的操作</li>
<li>那外部说我要存钱, 我要取钱,我要转账, 通过一个类型来告诉我们 代码就生成了</li>
</ul>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment">* 银行业务</span>
<span class="comment">*/</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankBusiness</span> &#123;

   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> type)</span> &#123;
       <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;
           save();
       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>) &#123;
           take();
       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>) &#123;
           transfer();
       &#125;
   &#125;

   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;
       System.out.println(<span class="string">&quot;存钱&quot;</span>);
   &#125;

   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">take</span><span class="params">()</span>&#123;
       System.out.println(<span class="string">&quot;取钱&quot;</span>);
   &#125;

   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;
       System.out.println(<span class="string">&quot;转账&quot;</span>);
   &#125;
&#125;</code></pre>

<p>咋一看已经实现了需求. 但是现在有新的需求来了, 银行要增加功能—理财. 理财是银行业务的一种, 自然是新增一个方法. 然后在operate()方法里增加一种类型. 这就是一个糟糕的设计, 增加新功能, 但是却修改了原来的代码.</p>
<p>们设计成接口抽象的形式,源码如下：</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Business</span> &#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Save</span> <span class="keyword">implements</span> <span class="title class_">Business</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;存钱业务&quot;</span>);
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Take</span> <span class="keyword">implements</span> <span class="title class_">Business</span> &#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;取钱业务&quot;</span>);
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> <span class="keyword">implements</span> <span class="title class_">Business</span> &#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;转账业务&quot;</span>);
    &#125;
&#125;


<span class="comment">/**</span>
<span class="comment"> * 银行业务类</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankBusinesses</span> &#123;
    <span class="comment">/**</span>
<span class="comment">     * 处理银行业务</span>
<span class="comment">     * <span class="doctag">@param</span> business</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(Business business)</span> &#123;
        System.out.println(<span class="string">&quot;处理银行业务&quot;</span>);
        business.operate();
    &#125;
&#125;</code></pre>

<p>通过接口抽象的形式方便扩展, 加入要新增理财功能. 只需新增一个理财类, 其他业务代码都不需要修改.</p>
<p>其实, 在日常工作中, 经常会遇到这种情况. 因为我们平时写业务逻辑会更多一些, 而业务就像流水账, 今天一个明天一个一点一点的增加. 所以,当业务增加到3个的时候, 我们就要思考, 如何写能够方便扩展.</p>
<p><strong>总结</strong></p>
<ul>
<li>遵守开闭原则可以提高软件扩展性和维护性。</li>
<li>大部分的设计模式和设计原则都是在实现开闭原则。</li>
</ul>
<h1 id="七、迪米特法则（Demeter-Principle）"><a href="#七、迪米特法则（Demeter-Principle）" class="headerlink" title="七、迪米特法则（Demeter Principle）"></a>七、迪米特法则（Demeter Principle）</h1><h2 id="1-什么是迪米特法则"><a href="#1-什么是迪米特法则" class="headerlink" title="1. 什么是迪米特法则"></a>1. 什么是迪米特法则</h2><p>迪米特法则(Law of Demeter )又叫做最少知识原则，也就是说，一个对象应当对其他对象尽可能少的了解。不和陌生人说话。英文简写为: LoD。</p>
<p>迪米特法则的目的在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p>
<p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。</p>
<h2 id="2-为什么要遵守迪米特法则"><a href="#2-为什么要遵守迪米特法则" class="headerlink" title="2. 为什么要遵守迪米特法则?"></a>2. 为什么要遵守迪米特法则?</h2><p>在面向对象编程中有一些众所周知的抽象概念，比如封装、内聚和耦合，理论上可以用来生成清晰的设计和良好的代码。虽然这些都是非常重要的概念，但它们不够实用，不能直接用于开发环境，这些概念是比较主观的，非常依赖于使用人的经验和知识。对于其他概念，如单一责任原则、开闭原则等，情况也是一样的。迪米特法则的独特之处在于它简洁而准确的定义，它允许在编写代码时直接应用，几乎自动地应用了适当的封装、低内聚和松耦合。</p>
<h2 id="3-迪米特法则的广狭义"><a href="#3-迪米特法则的广狭义" class="headerlink" title="3. 迪米特法则的广狭义"></a>3. 迪米特法则的广狭义</h2><h3 id="3-1-狭义的迪米特法则"><a href="#3-1-狭义的迪米特法则" class="headerlink" title="3.1 狭义的迪米特法则"></a>3.1 狭义的迪米特法则</h3><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>
<p><strong>朋友圈的确定“朋友”条件：</strong></p>
<ul>
<li><p>当前对象本身（this）</p>
</li>
<li><p>以参数形式传入到当前对象方法中的对象.</p>
<p>方法入参是一个对象, 这时这个对象和当前类是朋友</p>
</li>
<li><p>当前对象的实例变量直接引用的对象</p>
<p>定义一个类, 里面的属性引用了其他对象, 那么引用对象的实例和当前实例是朋友</p>
</li>
<li><p>当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友</p>
<p>如果属性是一个对象, 那么属性和对象里的元素都是朋友</p>
</li>
<li><p>当前对象所创建的对象</p>
</li>
</ul>
<p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”。</p>
<p><strong>狭义的迪米特法则的缺点：</strong></p>
<p>在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的业务逻辑无关。 遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。</p>
<h3 id="3-2-广义的迪米特法则在类的设计上的体现"><a href="#3-2-广义的迪米特法则在类的设计上的体现" class="headerlink" title="3.2 广义的迪米特法则在类的设计上的体现"></a>3.2 广义的迪米特法则在类的设计上的体现</h3><ul>
<li>优先考虑将一个类设置成不变类。 </li>
<li>尽量降低一个类的访问权限。  </li>
<li>谨慎使用Serializable。  </li>
<li>尽量降低成员的访问权限。</li>
</ul>
<h2 id="4-迪米特法则在设计模式中的应用"><a href="#4-迪米特法则在设计模式中的应用" class="headerlink" title="4. 迪米特法则在设计模式中的应用"></a>4. 迪米特法则在设计模式中的应用</h2><p>设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则的应用</p>
<p>下面我们已经租房为例, 来研究迪米特法则. 通常 客户要找房子住, 我们就直接建一个房子类, 建一个客户类, 客户找房子即可.</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHouse</span> &#123;
    <span class="comment">// 住房子</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;住房子&quot;</span>);
    &#125;
&#125;


<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;
    <span class="keyword">public</span> String name;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findHourse</span><span class="params">(IHouse house)</span> &#123;
        house.Housing();
    &#125;
&#125;</code></pre>

<p>客户找房子住, 逻辑很简单, 这样是ok的. 虽然违背了迪米特法则, 但符合业务逻辑也说得通. 但是, 通常我们找房子, 不是一下子就能找到的, 我们要找很多家, 这就很费劲, 那不如交给中介. 中介有很多房源, 房东吧房子给了中介, 不需要关心租户是谁, 租户将找房的事交给房东, 他也不用管房东是谁, 而且租户+房东都很省事.</p>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment"> * 房子</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHouse</span> &#123;
    <span class="comment">// 住房子</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;住房子&quot;</span>);
    &#125;
&#125;

<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICustomer</span> &#123;

    <span class="keyword">void</span> <span class="title function_">findHourse</span><span class="params">(IHouse house)</span> ;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">ICustomer</span> &#123;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findHourse</span><span class="params">(IHouse house)</span> &#123;
        house.Housing();
    &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 中介</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Intermediary</span> &#123;
    <span class="comment">// 找房子</span>
    <span class="keyword">public</span> IHouse <span class="title function_">findHouse</span><span class="params">(ICustomer customer)</span>&#123;
        <span class="comment">// 帮租户找房子</span>
        <span class="keyword">return</span> <span class="literal">null</span>;
    &#125;
&#125;</code></pre>

<p>房子,客户是相互独立的, 彼此之间没有引用. 他们之间建立关系是通过中介. 也就是, 客户找中介租房子, 房东吧房子交给租户, 最后中介将找好的房子给到客户. 客户和房东彼此隔离, 符合迪米特法则.</p>
<h2 id="5-迪米特法则实践"><a href="#5-迪米特法则实践" class="headerlink" title="5. 迪米特法则实践"></a>5. 迪米特法则实践</h2><p>那么在实践中如何做到一个对象应该对其他对象有最少的了解呢？如果我们把一个对象看作是一个人，那么要实现“一个人应该对其他人有最少的了解”，做到两点就足够了：</p>
<ul>
<li>只和直接的朋友交流；</li>
<li>减少对朋友的了解。下面就详细说说如何做到这两点。</li>
</ul>
<h3 id="5-1-只和直接的朋友交流"><a href="#5-1-只和直接的朋友交流" class="headerlink" title="5.1 只和直接的朋友交流"></a>5.1 只和直接的朋友交流</h3><p>迪米特法则还有一个英文解释是：talk only to your immediate friends（只和直接的朋友交流）。</p>
<p><strong>什么是朋友呢？</strong></p>
<p>每个对象都必然会与其他的对象有耦合关系，两个对象之间的耦合就会成为朋友关系。那么什么又是直接的朋友呢？出现在<strong>成员变量</strong>、<strong>方法的输入输出参数</strong>中的类就是直接的朋友。迪米特法则要求只和直接的朋友通信。</p>
<blockquote>
<p><strong>注意：</strong><br>只出现在方法体内部的类就不是直接的朋友，如果一个类和不是直接的朋友进行交流，就属于违反迪米特法则。</p>
</blockquote>
<p>我们举一个例子说明什么是朋友，什么是直接的朋友。很简单的例子：老师让班长清点全班同学的人数。这个例子中总共有三个类：老师Teacher、班长GroupLeader和学生Student。</p>
<pre><code class="highlight java">
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacher</span> &#123;
    <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">ITeacher</span>&#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span> &#123;
        <span class="comment">// 全班同学</span>
        List&lt;Student&gt; allStudent = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();
        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());
        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());
        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());
        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());
        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());
        <span class="comment">// 班长清点人数</span>
        groupLeader.count(allStudent);

    &#125;
&#125;

**
 * 班长类
 */
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGroupLeader</span> &#123;

    <span class="comment">// 班长清点人数</span>
    <span class="keyword">void</span> <span class="title function_">count</span><span class="params">(List&lt;Student&gt; students)</span>;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 班长类</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">implements</span> <span class="title class_">IGroupLeader</span>&#123;
    <span class="comment">/**</span>
<span class="comment">     * 班长清点人数</span>
<span class="comment">     * <span class="doctag">@param</span> students</span>
<span class="comment">     */</span>
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">(List&lt;Student&gt; students)</span> &#123;
        <span class="comment">// 班长清点人数</span>
        System.out.println(<span class="string">&quot;上课的学生人数是: &quot;</span> + students.size());
    &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 学生类</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 学生类</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span> &#123;


&#125;

<span class="comment">/**</span>
<span class="comment"> * 客户端</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="comment">// 老师类</span>
        <span class="type">ITeacher</span> <span class="variable">wangTeacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();

        <span class="comment">// 班长</span>
        <span class="type">IGroupLeader</span> <span class="variable">zhangBanzhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();
        wangTeacher.command(zhangBanzhang);
    &#125;
&#125;</code></pre>

<p>运行结果:</p>
<pre><code class="highlight shell">上课的学生人数是: 5</code></pre>

<p>在这个例子中，我们的Teacher有几个朋友？两个，一个是GroupLeader，它是Teacher的command()方法的入参；另一个是Student，因为在Teacher的command()方法体中使用了Student。</p>
<p>那么Teacher有几个是直接的朋友？按照直接的朋友的定义</p>
<blockquote>
<p>出现在成员变量、方法的输入输出参数中的类就是直接的朋友</p>
</blockquote>
<p>只有GroupLeader是Teacher的直接的朋友。</p>
<p>Teacher在command()方法中创建了Student的数组，和非直接的朋友Student发生了交流，所以，上述例子<strong>违反了迪米特法则</strong>。方法是类的一个行为，类竟然不知道自己的行为与其他的类产生了依赖关系，这是不允许的，<strong>严重违反了迪米特法则</strong>！</p>
<p><strong>为了使上述例子符合迪米特法则，我们可以做如下修改：</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacher</span> &#123;
    <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span>;
&#125;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">ITeacher</span> &#123;
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span> &#123;
        <span class="comment">// 班长清点人数</span>
        groupLeader.count();
    &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 班长类</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGroupLeader</span> &#123;
    <span class="comment">// 班长清点人数</span>
    <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span>;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 班长类</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">implements</span> <span class="title class_">IGroupLeader</span> &#123;

    <span class="keyword">private</span> List&lt;Student&gt; students;

    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">(List&lt;Student&gt; students)</span> &#123;
        <span class="built_in">this</span>.students = students;
    &#125;

    <span class="comment">/**</span>
<span class="comment">     * 班长清点人数</span>
<span class="comment">     */</span>
    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> &#123;
        <span class="comment">// 班长清点人数</span>
        System.out.println(<span class="string">&quot;上课的学生人数是: &quot;</span> + students.size());
    &#125;
&#125;


<span class="comment">/**</span>
<span class="comment"> * 学生类</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 学生类</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span> &#123;


&#125;


<span class="comment">/**</span>
<span class="comment"> * 客户端</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="comment">// 老师类</span>
        <span class="type">ITeacher</span> <span class="variable">wangTeacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();

        List&lt;Student&gt; allStudent = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">10</span>);
        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());
        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());
        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());
        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());

        <span class="comment">// 班长</span>
        <span class="type">IGroupLeader</span> <span class="variable">zhangBanzhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>(allStudent);
        wangTeacher.command(zhangBanzhang);
    &#125;
&#125;</code></pre>

<p>运行结果: </p>
<pre><code class="highlight shell">上课的学生人数是: 4</code></pre>

<p>这样修改后，每个类都只和直接的朋友交流，有效减少了类之间的耦合</p>
<h3 id="5-2-减少对朋友的了解"><a href="#5-2-减少对朋友的了解" class="headerlink" title="5.2 减少对朋友的了解"></a>5.2 减少对朋友的了解</h3><p>如何减少对朋友的了解？即：<strong>在一个类中，就是尽量减少一个类对外暴露的方法</strong></p>
<p>举一个简单的例子说明一个类暴露方法过多的情况。一个人用咖啡机煮咖啡的过程，例子中只有两个类，一个是人，一个是咖啡机。</p>
<p>首先是咖啡机类CoffeeMachine，咖啡机制作咖啡只需要三个方法：1.加咖啡豆；2.加水；3.制作咖啡：</p>
<pre><code class="highlight java"><span class="comment">/**</span>
<span class="comment"> * 咖啡机抽象接口</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICoffeeMachine</span> &#123;

    <span class="comment">//加咖啡豆</span>
    <span class="keyword">void</span> <span class="title function_">addCoffeeBean</span><span class="params">()</span>;

    <span class="comment">//加水</span>
    <span class="keyword">void</span> <span class="title function_">addWater</span><span class="params">()</span>;

    <span class="comment">//制作咖啡</span>
    <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span>;
&#125;


<span class="comment">/**</span>
<span class="comment"> * 咖啡机实现类</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> <span class="keyword">implements</span> <span class="title class_">ICoffeeMachine</span>&#123;

    <span class="comment">//加咖啡豆</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCoffeeBean</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;放咖啡豆&quot;</span>);
    &#125;

    <span class="comment">//加水</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWater</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;加水&quot;</span>);
    &#125;

    <span class="comment">//制作咖啡</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;制作咖啡&quot;</span>);
    &#125;
&#125;


<span class="comment">/**</span>
<span class="comment"> * 人, 制作咖啡</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMan</span> &#123;
    <span class="comment">/**</span>
<span class="comment">     * 制作咖啡</span>
<span class="comment">     */</span>
    <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span>;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 人制作咖啡</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">IMan</span> &#123;
    <span class="keyword">private</span> ICoffeeMachine coffeeMachine;

    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">(ICoffeeMachine coffeeMachine)</span> &#123;
        <span class="built_in">this</span>.coffeeMachine = coffeeMachine;
    &#125;

    <span class="comment">/**</span>
<span class="comment">     * 制作咖啡</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;
        coffeeMachine.addWater();
        coffeeMachine.addCoffeeBean();
        coffeeMachine.makeCoffee();
    &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 客户端</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">ICoffeeMachine</span> <span class="variable">coffeeMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>();

        <span class="type">IMan</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>(coffeeMachine);
        man.makeCoffee();

    &#125;
&#125;</code></pre>

<p>运行结果:</p>
<pre><code class="highlight shell">加水
放咖啡豆
制作咖啡</code></pre>

<p>在这个例子中，CoffeeMachine是Man的直接好友，但问题是Man对CoffeeMachine了解的太多了，其实人根本不关心咖啡机具体制作咖啡的过程。所以我们可以作如下优化：</p>
<p>优化后的咖啡机类，只暴露一个work方法，把制作咖啡的三个具体的方法addCoffeeBean、addWater、makeCoffee设为私有.</p>
<pre><code class="highlight java">
<span class="comment">/**</span>
<span class="comment"> * 咖啡机抽象接口</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICoffeeMachine</span> &#123;

    <span class="comment">//咖啡机工作</span>
    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;

&#125;

<span class="comment">/**</span>
<span class="comment"> * 咖啡机实现类</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> <span class="keyword">implements</span> <span class="title class_">ICoffeeMachine</span> &#123;

    <span class="comment">//加咖啡豆</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCoffeeBean</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;放咖啡豆&quot;</span>);
    &#125;

    <span class="comment">//加水</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWater</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;加水&quot;</span>);
    &#125;

    <span class="comment">//制作咖啡</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;
        System.out.println(<span class="string">&quot;制作咖啡&quot;</span>);
    &#125;

    <span class="meta">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;
        addCoffeeBean();
        addWater();
        makeCoffee();
    &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 人, 制作咖啡</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMan</span> &#123;
    <span class="comment">/**</span>
<span class="comment">     * 制作咖啡</span>
<span class="comment">     */</span>
    <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span>;
&#125;


<span class="comment">/**</span>
<span class="comment"> * 人制作咖啡</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">IMan</span> &#123;
    <span class="keyword">private</span> ICoffeeMachine coffeeMachine;

    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">(ICoffeeMachine coffeeMachine)</span> &#123;
        <span class="built_in">this</span>.coffeeMachine = coffeeMachine;
    &#125;

    <span class="comment">/**</span>
<span class="comment">     * 制作咖啡</span>
<span class="comment">     */</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;
        coffeeMachine.work();
    &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 客户端</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
        <span class="type">ICoffeeMachine</span> <span class="variable">coffeeMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>();

        <span class="type">IMan</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>(coffeeMachine);
        man.makeCoffee();

    &#125;
&#125;</code></pre>

<p>这样修改后，通过减少CoffeeMachine对外暴露的方法，减少Man对CoffeeMachine的了解，从而降低了它们之间的耦合。</p>
<p><strong>注意事项</strong></p>
<ul>
<li><p>第一：在类的划分上，应当创建弱耦合的类，类与类之间的耦合越弱，就越有利于实现可复用的目标。 </p>
</li>
<li><p>第二：在类的结构设计上，每个类都应该降低成员的访问权限。 </p>
</li>
<li><p>第三：在类的设计上，只要有可能，一个类应当设计成不变的类。 </p>
</li>
<li><p>第四：在对其他类的引用上，一个对象对其他类的对象的引用应该降到最低。 </p>
</li>
<li><p>第五：尽量限制局部变量的有效范围，降低类的访问权限。</p>
</li>
</ul>
<p>参考链接</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/column/6966429007785459749">https://juejin.cn/column/6966429007785459749</a></p>
</blockquote>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 george_95@126.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'f820fe811764cacedc4f',
            clientSecret: '0ce07abb65f0e79ddb8830f32029b8a9656e0ee0',
            repo: 'georgechan95.github.io',
            owner: 'GeorgeChan95',
            admin: ['GeorgeChan95'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('15',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 George
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
