<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>第十八章-字节码指令集与解析指令 | George&#39;s Blog</title>
  <meta name="google-site-verification" content="RobLWkyyFziZxPJ4I887QROdX8XrYthcJwWTcuH0wwQ" />
  <meta name="msvalidate.01" content="626D541C48E5D151F52CECC2C6714BD4" />
  <meta name="360-site-verification" content="c838adf8357ca2f614d08ad5235a1717" />
  <meta name="keywords" content=" java , jvm ">
  <meta name="description" content="第十八章-字节码指令集与解析指令 | George&#39;s Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="个人简介本人在合肥，从事后端开发工作。 联系方式 邮箱：&#x67;&#101;&#111;&#114;&#x67;&#x65;&#95;&#x39;&#x35;&#x40;&#x31;&#50;&#x36;&#x2e;&#99;&#x6f;&#x6d;  邮件可能几天才看一次，如有联系，请耐心等待。">
<meta property="og:type" content="website">
<meta property="og:title" content="关于">
<meta property="og:url" content="https://georgechan95.github.io/about/index.html">
<meta property="og:site_name" content="George&#39;s Blog">
<meta property="og:description" content="个人简介本人在合肥，从事后端开发工作。 联系方式 邮箱：&#x67;&#101;&#111;&#114;&#x67;&#x65;&#95;&#x39;&#x35;&#x40;&#x31;&#50;&#x36;&#x2e;&#99;&#x6f;&#x6d;  邮件可能几天才看一次，如有联系，请耐心等待。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-21T02:29:45.000Z">
<meta property="article:modified_time" content="2024-12-09T05:22:48.462Z">
<meta property="article:author" content="George">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/favicon.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="George's Blog" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<script src="/js/image-loader.js"></script>
<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>George</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/GeorgeChan95"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:george_95@126.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(106)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="设计模式">
            
            设计模式
            <small>(24)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Docker">
            
            Docker
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Hexo">
            <i class="fold iconfont icon-right"></i>
            Hexo
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Hexo&lt;---&gt;Typora">
            
            Typora
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JUC">
            
            JUC
            <small>(24)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JVM">
            
            JVM
            <small>(27)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="k8s">
            
            k8s
            <small>(12)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="linux">
            
            linux
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="neo4j">
            
            neo4j
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="UML">
            
            UML
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">关于</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="106">
<input type="hidden" id="yelog_site_word_count" value="508.4k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>插入排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二分法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二进制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>合并有序链表</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>科学上网</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>链表</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>冒泡排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>双亲委派机制</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>位运算</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>选择排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github pages</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jenkins</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>juc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jvm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>neo4j</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Rocky</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>sitemap</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SpringBoot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>typora</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ubuntu18</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>UML</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 k8s "
           href="/blog/b42f2c7b.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="012-新建Node节点添加到K8S集群中">012-新建Node节点添加到K8S集群中</span>
            <span class="post-date" title="2025-07-07 20:32:00">2025/07/07</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/6436eaf1.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="011-Kubernetes Ingress-Nginx">011-Kubernetes Ingress-Nginx</span>
            <span class="post-date" title="2025-06-25 19:42:00">2025/06/25</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/d8e3c7b3.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="010-Kubernetes Helm">010-Kubernetes Helm</span>
            <span class="post-date" title="2025-06-21 14:12:00">2025/06/21</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/424f1119.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="009-Kubernetes 集群安全机制">009-Kubernetes 集群安全机制</span>
            <span class="post-date" title="2025-06-14 09:18:00">2025/06/14</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/f2285a2d.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="008-Kubernetes 调度器">008-Kubernetes 调度器</span>
            <span class="post-date" title="2025-06-02 14:40:00">2025/06/02</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/ef156b88.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="007-Kubernetes 存储">007-Kubernetes 存储</span>
            <span class="post-date" title="2025-05-02 10:26:00">2025/05/02</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/970719d6.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="006-Kubernetes Service">006-Kubernetes Service</span>
            <span class="post-date" title="2025-04-28 22:10:00">2025/04/28</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/c790096a.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="005-Kubernetes控制器">005-Kubernetes控制器</span>
            <span class="post-date" title="2025-04-02 20:12:00">2025/04/02</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/79e06aab.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="004-Pod的生命周期">004-Pod的生命周期</span>
            <span class="post-date" title="2025-03-22 09:05:00">2025/03/22</span>
        </a>
        
        
        <a  class="全部文章 Docker "
           href="/blog/b01d5c62.html"
           data-tag="linux,Docker,科学上网"
           data-author="" >
            <span class="post-title" title="Docker配置网络代理实现外网镜像下载">Docker配置网络代理实现外网镜像下载</span>
            <span class="post-date" title="2025-01-08 23:00:00">2025/01/08</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/7f174b3e.html"
           data-tag="linux,科学上网,Rocky"
           data-author="" >
            <span class="post-title" title="Rocky9安装Shadowsocks实现科学上网">Rocky9安装Shadowsocks实现科学上网</span>
            <span class="post-date" title="2025-01-08 21:09:00">2025/01/08</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/b00f53e9.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="003-基于Rocky9.3系统使用kubeadm安装k8s1.29集群">003-基于Rocky9.3系统使用kubeadm安装k8s1.29集群</span>
            <span class="post-date" title="2025-01-03 22:05:00">2025/01/03</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/3c79d8d9.html"
           data-tag="linux,Docker,Rocky"
           data-author="" >
            <span class="post-title" title="002-Rocky9.3系统初始化设置和Docker安装">002-Rocky9.3系统初始化设置和Docker安装</span>
            <span class="post-date" title="2025-01-02 13:25:00">2025/01/02</span>
        </a>
        
        
        <a  class="全部文章 k8s "
           href="/blog/7e3a5200.html"
           data-tag="linux,Rocky"
           data-author="" >
            <span class="post-title" title="001-ESXi8安装Rocky9.3虚拟机">001-ESXi8安装Rocky9.3虚拟机</span>
            <span class="post-date" title="2025-01-02 09:34:00">2025/01/02</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/77d85f50.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="25-责任链模式">25-责任链模式</span>
            <span class="post-date" title="2024-12-03 21:08:00">2024/12/03</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/fcec839d.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="24-策略模式">24-策略模式</span>
            <span class="post-date" title="2024-12-02 18:16:00">2024/12/02</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/6109865a.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="23-状态模式">23-状态模式</span>
            <span class="post-date" title="2024-11-29 19:30:00">2024/11/29</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/58d4db7.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="22-解释器模式">22-解释器模式</span>
            <span class="post-date" title="2024-11-28 22:00:00">2024/11/28</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/a5cf7eb4.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="21-备忘录模式">21-备忘录模式</span>
            <span class="post-date" title="2024-11-27 21:40:00">2024/11/27</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/3148d6be.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="20-中介者模式">20-中介者模式</span>
            <span class="post-date" title="2024-11-26 20:35:00">2024/11/26</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/f06aea0b.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="19-观察者模式">19-观察者模式</span>
            <span class="post-date" title="2024-11-25 21:07:00">2024/11/25</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/7dbd9149.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="18-迭代器模式">18-迭代器模式</span>
            <span class="post-date" title="2024-11-24 00:02:00">2024/11/24</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/4fdf6e52.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="17-访问者模式">17-访问者模式</span>
            <span class="post-date" title="2024-11-23 21:55:00">2024/11/23</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/60fd53f.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="16-命令模式">16-命令模式</span>
            <span class="post-date" title="2024-11-23 20:30:00">2024/11/23</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/4930323d.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="15-模板方法模式">15-模板方法模式</span>
            <span class="post-date" title="2024-11-23 19:40:00">2024/11/23</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/e4235185.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="14-代理模式">14-代理模式</span>
            <span class="post-date" title="2024-11-21 23:16:00">2024/11/21</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/1b225c1f.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="13-享元模式">13-享元模式</span>
            <span class="post-date" title="2024-11-20 23:10:00">2024/11/20</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/906e9e8b.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="12-外观模式">12-外观模式</span>
            <span class="post-date" title="2024-11-20 22:09:00">2024/11/20</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/c456a66a.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="11-组合模式">11-组合模式</span>
            <span class="post-date" title="2024-11-16 17:00:00">2024/11/16</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/90213fc6.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="10-装饰器模式">10-装饰器模式</span>
            <span class="post-date" title="2024-11-16 14:06:00">2024/11/16</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/c7419cfa.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="09-桥接模式">09-桥接模式</span>
            <span class="post-date" title="2024-11-14 20:51:00">2024/11/14</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/f77fc055.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="08-适配器模式">08-适配器模式</span>
            <span class="post-date" title="2024-11-12 22:55:00">2024/11/12</span>
        </a>
        
        
        <a  class="全部文章 neo4j "
           href="/blog/a3b0b090.html"
           data-tag="neo4j,SpringBoot"
           data-author="" >
            <span class="post-title" title="Spring Boot对Neo4j节点关系的增删改查">Spring Boot对Neo4j节点关系的增删改查</span>
            <span class="post-date" title="2024-11-12 21:00:30">2024/11/12</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/3ab9aa56.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="07-建造者模式">07-建造者模式</span>
            <span class="post-date" title="2024-11-11 21:55:00">2024/11/11</span>
        </a>
        
        
        <a  class="全部文章 neo4j "
           href="/blog/7dc0fcde.html"
           data-tag="neo4j,SpringBoot"
           data-author="" >
            <span class="post-title" title="Spring Boot整合Neo4j实现增删改查">Spring Boot整合Neo4j实现增删改查</span>
            <span class="post-date" title="2024-11-07 19:04:30">2024/11/07</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/564adc33.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="06-原型模式">06-原型模式</span>
            <span class="post-date" title="2024-11-06 19:00:00">2024/11/06</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/effeea78.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="05-工厂模式">05-工厂模式</span>
            <span class="post-date" title="2024-11-04 21:00:00">2024/11/04</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/d7e99843.html"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="04-单例模式">04-单例模式</span>
            <span class="post-date" title="2024-11-04 19:00:00">2024/11/04</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/90f1850a.html"
           data-tag="设计模式,UML"
           data-author="" >
            <span class="post-title" title="03-UML类图">03-UML类图</span>
            <span class="post-date" title="2024-11-02 14:57:00">2024/11/02</span>
        </a>
        
        
        <a  class="全部文章 UML "
           href="/blog/c13304c1.html"
           data-tag="设计模式,UML"
           data-author="" >
            <span class="post-title" title="02-UML图绘制工具">02-UML图绘制工具</span>
            <span class="post-date" title="2024-11-02 09:57:00">2024/11/02</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/2e826df1.html"
           data-tag="linux,ubuntu18"
           data-author="" >
            <span class="post-title" title="Docker环境下RTSP流转RTMP和HLS">Docker环境下RTSP流转RTMP和HLS</span>
            <span class="post-date" title="2024-11-01 15:17:33">2024/11/01</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/blog/cd625bba.html"
           data-tag="设计模式,java"
           data-author="" >
            <span class="post-title" title="01-设计模式六大原则">01-设计模式六大原则</span>
            <span class="post-date" title="2024-10-31 17:00:00">2024/10/31</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/1a649f4c.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="13-JUC进阶-ReentrantReadWriteLock与StampedLock">13-JUC进阶-ReentrantReadWriteLock与StampedLock</span>
            <span class="post-date" title="2024-10-19 09:26:00">2024/10/19</span>
        </a>
        
        
        <a  class="全部文章 neo4j "
           href="/blog/5c93903a.html"
           data-tag="linux,neo4j"
           data-author="" >
            <span class="post-title" title="Docker部署Neo4j并导入CSV数据">Docker部署Neo4j并导入CSV数据</span>
            <span class="post-date" title="2024-10-17 15:00:30">2024/10/17</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/ad38e6b1.html"
           data-tag="linux,ubuntu18"
           data-author="" >
            <span class="post-title" title="Ubuntu18.04离线源环境搭建">Ubuntu18.04离线源环境搭建</span>
            <span class="post-date" title="2024-10-17 09:47:33">2024/10/17</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3fdbf0f6.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="12-JUC进阶-从ReentrantLock到AQS源码详解">12-JUC进阶-从ReentrantLock到AQS源码详解</span>
            <span class="post-date" title="2024-10-15 19:42:07">2024/10/15</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3e0d7592.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="11-JUC进阶-Synchronized与锁升级">11-JUC进阶-Synchronized与锁升级</span>
            <span class="post-date" title="2024-10-06 09:28:00">2024/10/06</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4502cffa.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="10-JUC进阶-Java对象内存布局和对象头">10-JUC进阶-Java对象内存布局和对象头</span>
            <span class="post-date" title="2024-10-04 09:54:40">2024/10/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4de6a39b.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="09-JUC进阶-ThreadLocal">09-JUC进阶-ThreadLocal</span>
            <span class="post-date" title="2024-10-01 20:39:10">2024/10/01</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/72329cf5.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="08-JUC进阶-常用的原子操作类(18个)">08-JUC进阶-常用的原子操作类(18个)</span>
            <span class="post-date" title="2024-09-28 13:37:09">2024/09/28</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/5e3757c1.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="07-JUC进阶-CAS">07-JUC进阶-CAS</span>
            <span class="post-date" title="2024-09-26 19:37:00">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/546d628d.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="06-JUC进阶-Volatile与Java内存模型">06-JUC进阶-Volatile与Java内存模型</span>
            <span class="post-date" title="2024-09-25 19:01:01">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/1f2e0014.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="05-JUC进阶-Java内存模型-JMM">05-JUC进阶-Java内存模型-JMM</span>
            <span class="post-date" title="2024-09-23 23:01:07">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/19653fb9.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="04-JUC进阶-LockSupport与线程中断">04-JUC进阶-LockSupport与线程中断</span>
            <span class="post-date" title="2024-09-23 20:51:50">2024/09/23</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/219e52ea.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="03-JUC进阶-Java中的锁的解析">03-JUC进阶-Java中的锁的解析</span>
            <span class="post-date" title="2024-09-21 14:15:20">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/7e2d78eb.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="02-JUC进阶-CompletableFuture">02-JUC进阶-CompletableFuture</span>
            <span class="post-date" title="2024-09-18 22:50:00">2024/09/18</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/3d102971.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="01-JUC进阶-线程基础">01-JUC进阶-线程基础</span>
            <span class="post-date" title="2024-09-18 22:32:00">2024/09/18</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/37d56d14.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="11-CompletableFuture">11-CompletableFuture</span>
            <span class="post-date" title="2024-09-16 16:12:00">2024/09/16</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/31919959.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="10-Fork/Join">10-Fork/Join</span>
            <span class="post-date" title="2024-09-16 13:10:00">2024/09/16</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/a0197c15.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="09-ThreadPool-线程池">09-ThreadPool-线程池</span>
            <span class="post-date" title="2024-09-13 20:10:08">2024/09/13</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/a6760d1f.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="08-阻塞队列BlockingQueue">08-阻塞队列BlockingQueue</span>
            <span class="post-date" title="2024-09-07 17:30:00">2024/09/07</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/838e7581.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore">07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore</span>
            <span class="post-date" title="2024-09-07 13:00:00">2024/09/07</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/f60e37c5.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="06-Callable &amp; Future 接口">06-Callable &amp; Future 接口</span>
            <span class="post-date" title="2024-09-06 22:10:00">2024/09/06</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/f184587f.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="05-公平锁和非公平锁，死锁，可重入锁">05-公平锁和非公平锁，死锁，可重入锁</span>
            <span class="post-date" title="2024-09-05 20:12:00">2024/09/05</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/9a09d992.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="04-集合的线程安全">04-集合的线程安全</span>
            <span class="post-date" title="2024-09-04 21:09:05">2024/09/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/bd2134da.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="03-线程间通信">03-线程间通信</span>
            <span class="post-date" title="2024-09-04 20:06:00">2024/09/04</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/850dac3c.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="02-Lock接口">02-Lock接口</span>
            <span class="post-date" title="2024-08-30 19:27:00">2024/08/30</span>
        </a>
        
        
        <a  class="全部文章 JUC "
           href="/blog/4e6bd685.html"
           data-tag="java,juc"
           data-author="" >
            <span class="post-title" title="01-多线程的基本概念">01-多线程的基本概念</span>
            <span class="post-date" title="2024-08-30 19:03:01">2024/08/30</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1b0522f4.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十五章-分析GC日志">第二十五章-分析GC日志</span>
            <span class="post-date" title="2024-08-28 21:36:08">2024/08/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/944806143.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十四章-JVM运行时参数">第二十四章-JVM运行时参数</span>
            <span class="post-date" title="2024-08-27 18:30:10">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/490498600.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-使用OQL语言查询对象信息">第二十三章-使用OQL语言查询对象信息</span>
            <span class="post-date" title="2024-08-24 15:02:10">2024/08/24</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1471620196.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-浅堆-深堆-内存泄漏">第二十三章-浅堆-深堆-内存泄漏</span>
            <span class="post-date" title="2024-08-24 13:04:37">2024/08/24</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/971417975.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十三章-JVM监控及诊断工具-GUI篇">第二十三章-JVM监控及诊断工具-GUI篇</span>
            <span class="post-date" title="2024-08-16 21:00:00">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2165702380.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十二章-JVM监控及诊断工具-命令行篇">第二十二章-JVM监控及诊断工具-命令行篇</span>
            <span class="post-date" title="2024-08-12 19:36:32">2024/08/12</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2681163762.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十一章-性能监控与调优概述">第二十一章-性能监控与调优概述</span>
            <span class="post-date" title="2024-08-12 19:13:06">2024/08/12</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3537043756.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第二十章-再谈类的加载器">第二十章-再谈类的加载器</span>
            <span class="post-date" title="2024-08-10 13:43:10">2024/08/10</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3387211378.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十九章-类的加载过程详解">第十九章-类的加载过程详解</span>
            <span class="post-date" title="2024-08-02 19:33:27">2024/08/02</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1107503247.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十八章-字节码指令集与解析指令">第十八章-字节码指令集与解析指令</span>
            <span class="post-date" title="2024-08-01 01:40:02">2024/08/01</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2772873157.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十七章-使用javap指令解析class文件">第十七章-使用javap指令解析class文件</span>
            <span class="post-date" title="2024-07-22 23:54:00">2024/07/22</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/143162370.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十六章-Class文件结构">第十六章-Class文件结构</span>
            <span class="post-date" title="2024-07-15 19:54:50">2024/07/15</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/309245330.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十五章-GC日志分析">第十五章-GC日志分析</span>
            <span class="post-date" title="2024-07-13 08:34:00">2024/07/13</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1750792302.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十四章-垃圾收集器">第十四章-垃圾收集器</span>
            <span class="post-date" title="2024-07-10 19:27:00">2024/07/10</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/484946532.html"
           data-tag="算法,合并有序链表"
           data-author="" >
            <span class="post-title" title="合并两个有序链表">合并两个有序链表</span>
            <span class="post-date" title="2024-07-06 09:11:00">2024/07/06</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2929260443.html"
           data-tag="算法,链表"
           data-author="" >
            <span class="post-title" title="链表反转">链表反转</span>
            <span class="post-date" title="2024-07-05 19:45:45">2024/07/05</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/1403776474.html"
           data-tag="算法,选择排序,冒泡排序,插入排序"
           data-author="" >
            <span class="post-title" title="选择-冒泡-插入排序">选择-冒泡-插入排序</span>
            <span class="post-date" title="2024-07-03 11:02:16">2024/07/03</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2561891005.html"
           data-tag="算法,二分法"
           data-author="" >
            <span class="post-title" title="二分搜索">二分搜索</span>
            <span class="post-date" title="2024-06-29 10:04:10">2024/06/29</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/blog/2224151177.html"
           data-tag="算法,二进制,位运算"
           data-author="" >
            <span class="post-title" title="二进制和位运算">二进制和位运算</span>
            <span class="post-date" title="2024-06-20 08:04:00">2024/06/20</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2105268063.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十三章-垃圾回收相关概念">第十三章-垃圾回收相关概念</span>
            <span class="post-date" title="2024-01-14 14:27:00">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/364508352.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十二章-垃圾回收概述和相关算法">第十二章-垃圾回收概述和相关算法</span>
            <span class="post-date" title="2024-01-06 16:28:00">2024/01/06</span>
        </a>
        
        
        <a  class="全部文章 linux "
           href="/blog/2050535563.html"
           data-tag="linux,jenkins"
           data-author="" >
            <span class="post-title" title="Jenkins的安装和搭建自动化部署平台">Jenkins的安装和搭建自动化部署平台</span>
            <span class="post-date" title="2024-01-05 16:00:00">2024/01/05</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/2388209687.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十一章-StringTable(字符串常量池)">第十一章-StringTable(字符串常量池)</span>
            <span class="post-date" title="2023-12-25 17:27:06">2023/12/25</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3385856233.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第十章-执行引擎">第十章-执行引擎</span>
            <span class="post-date" title="2023-12-23 20:03:00">2023/12/23</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/4075763684.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第九章-对象的实例化内存布局与访问定位">第九章-对象的实例化内存布局与访问定位</span>
            <span class="post-date" title="2023-12-21 11:50:00">2023/12/21</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/3720767522.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第八章-直接内存">第八章-直接内存</span>
            <span class="post-date" title="2023-12-20 17:03:00">2023/12/20</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/105864584.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第七章-方法区">第七章-方法区</span>
            <span class="post-date" title="2023-12-14 18:24:00">2023/12/14</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/543408063.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第六章-JVM堆">第六章-JVM堆</span>
            <span class="post-date" title="2023-12-02 08:01:00">2023/12/02</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/554039338.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第五章-本地方法接口">第五章-本地方法接口</span>
            <span class="post-date" title="2023-11-30 17:55:00">2023/11/30</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1123461525.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第四章-虚拟机栈">第四章-虚拟机栈</span>
            <span class="post-date" title="2023-11-28 20:55:00">2023/11/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1626061462.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第三章-运行时数据区">第三章-运行时数据区</span>
            <span class="post-date" title="2023-11-28 19:31:00">2023/11/28</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/222077543.html"
           data-tag="java,jvm,双亲委派机制"
           data-author="" >
            <span class="post-title" title="第二章-JVM类加载子系统">第二章-JVM类加载子系统</span>
            <span class="post-date" title="2023-11-25 14:35:00">2023/11/25</span>
        </a>
        
        
        <a  class="全部文章 JVM "
           href="/blog/1897413233.html"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="第一章-JVM和Java体系结构">第一章-JVM和Java体系结构</span>
            <span class="post-date" title="2023-11-25 10:00:00">2023/11/25</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/4179015178.html"
           data-tag="hexo,github pages,sitemap"
           data-author="" >
            <span class="post-title" title="给博客网站添加站点地图-sitemap">给博客网站添加站点地图-sitemap</span>
            <span class="post-date" title="2023-11-21 20:00:00">2023/11/21</span>
        </a>
        
        
        <a  class="全部文章 Hexo Typora "
           href="/blog/877664098.html"
           data-tag="hexo,typora,github"
           data-author="" >
            <span class="post-title" title="Typora设置图片自动上传Github">Typora设置图片自动上传Github</span>
            <span class="post-date" title="2023-11-20 20:30:00">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/3069199997.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="Hexo主题常用配置">Hexo主题常用配置</span>
            <span class="post-date" title="2023-11-20 00:00:01">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/2016918085.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="Hexo博客安装主题">Hexo博客安装主题</span>
            <span class="post-date" title="2023-11-20 00:00:01">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 Hexo "
           href="/blog/3070587776.html"
           data-tag="hexo,github pages"
           data-author="" >
            <span class="post-title" title="基于Hexo和Github Pages搭建个人博客">基于Hexo和Github Pages搭建个人博客</span>
            <span class="post-date" title="2023-11-18 15:40:20">2023/11/18</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-jvm/第十八章-字节码指令集与解析举例" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">第十八章-字节码指令集与解析指令</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="JVM">JVM</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">java</a>
            
            <a class="color4">jvm</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-08-28 12:17:33'>2024-08-01 01:40</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:14.3k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">一、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. 执行模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. 字节码与数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8C%87%E4%BB%A4%E5%88%86%E6%9E%90"><span class="toc-text">3. 指令分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">二、加载与存储指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="toc-text">1. 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">2. 常用指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%86%8D%E8%B0%88%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-text">3. 再谈操作数栈与局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88Operand-Stacks%EF%BC%89"><span class="toc-text">3.1 操作数栈（Operand Stacks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%EF%BC%88Local-Variables%EF%BC%89"><span class="toc-text">3.2 局部变量表（Local Variables）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="toc-text">3.3 局部变量压栈指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88%E6%8C%87%E4%BB%A4%E5%89%96%E6%9E%90"><span class="toc-text">3.3.1 局部变量压栈指令剖析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="toc-text">3.4 常量入栈指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-text">3.4.1 常量入栈常用指令集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4%E5%89%96%E6%9E%90"><span class="toc-text">3.4.2 常量入栈指令剖析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%87%BA%E6%A0%88%E8%A3%85%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">3.5 出栈装入局部变量表指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E5%87%BA%E6%A0%88%E8%A3%85%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%8C%87%E4%BB%A4%E5%89%96%E6%9E%90"><span class="toc-text">3.5.1 出栈装入局部变量表指令剖析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%AE%97%E6%95%B0%E6%8C%87%E4%BB%A4"><span class="toc-text">三、算数指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8-1"><span class="toc-text">1. 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%86%E7%B1%BB"><span class="toc-text">2. 分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-byte%E3%80%81short%E3%80%81char%E5%92%8Cboolean%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">3. byte、short、char和boolean类型说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%90%E7%AE%97%E6%97%B6%E7%9A%84%E6%BA%A2%E5%87%BA"><span class="toc-text">4. 运算时的溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%90%E7%AE%97%E6%A8%A1%E5%BC%8F"><span class="toc-text">5. 运算模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-NaN%E5%80%BC%E4%BD%BF%E7%94%A8"><span class="toc-text">6. NaN值使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%89%80%E6%9C%89%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="toc-text">7. 所有算术指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="toc-text">四、类型转换指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4%E8%AF%B4%E6%98%8E"><span class="toc-text">1. 类型转换指令说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%BD%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="toc-text">2. 宽化类型转换指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-text">2.1 转换规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-text">2.2 精度损失问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">2.3 补充说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AA%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="toc-text">3. 窄化类型转换指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-text">3.1 转换规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-text">3.2 精度损失问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">3.3 补充说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">五、对象的创建与访问指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%8C%87%E4%BB%A4"><span class="toc-text">1. 创建指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">2. 字段访问指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-text">3. 数组操作指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%8C%87%E4%BB%A4"><span class="toc-text">4. 类型检查指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-text">六、方法的调用与返回指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">1. 方法调用指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-text">2. 方法返回指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-text">七、操作数栈管理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 指令概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="toc-text">2. 实例解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%8E%A7%E5%88%B6%E8%BD%AC%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">八、控制转义指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="toc-text">1. 比较指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-text">2. 条件跳转指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%AF%94%E8%BE%83%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-text">3. 比较条件跳转指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-text">4. 多条件分支跳转指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-text">5. 无条件跳转指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-text">九、异常处理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-athrow%E6%8C%87%E4%BB%A4"><span class="toc-text">1. athrow指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-text">2. 处理异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%82%E5%B8%B8%E8%A1%A8"><span class="toc-text">3. 异常表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-text">十、同步控制指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E7%BA%A7%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">1. 方法级的同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E5%86%85%E6%8C%87%E4%BB%A4%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">2. 方法内指令指令序列的同步</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul>
<li>java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。</li>
<li>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode)以及跟随其后的零至多个代表此操作所需参数(称为操作数, Operands而构成。由于 Java 虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。</li>
<li>由于限制了 Java 虚拟机操作码的长度为一个字节(即 0~255)，这意味着指令集的操作码总数不可能超过256 条。</li>
<li>官方文档:<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></li>
<li>熟悉虚拟机的指令对于动态字节码生成、反编译class文件、Class文件修补都有着非常重要的价值。因此，阅读字节码作为了解 Java 虚拟机的基础技能，需要熟练掌握常见指令。</li>
</ul>
<h2 id="1-执行模型"><a href="#1-执行模型" class="headerlink" title="1. 执行模型"></a>1. 执行模型</h2><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解</p>
<pre><code class="highlight java"><span class="keyword">do</span>&#123;
    自动计算PC寄存器的值加<span class="number">1</span>;
    根据PC寄存器的指示位置，从字节码流中取出操作码;
    <span class="keyword">if</span>(字节码存在操作数) 从字节码流中取出操作数;
    执行操作码所定义的操作;
&#125;<span class="keyword">while</span>(字节码长度&gt;<span class="number">0</span>);</code></pre>



<h2 id="2-字节码与数据类型"><a href="#2-字节码与数据类型" class="headerlink" title="2. 字节码与数据类型"></a>2. 字节码与数据类型</h2><p>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</p>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</p>
<ul>
<li><p>i代表对int类型的数据操作，</p>
</li>
<li><p>l代表long</p>
</li>
<li><p>s代表short</p>
</li>
<li><p>b代表byte</p>
</li>
<li><p>c代表char</p>
</li>
<li><p>f代表float</p>
</li>
<li><p>d代表double</p>
</li>
</ul>
<p>也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</p>
<p>还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。</p>
<p>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。</p>
<h2 id="3-指令分析"><a href="#3-指令分析" class="headerlink" title="3. 指令分析"></a>3. 指令分析</h2><p>由于完全介绍和学习这些指令需要花费大量时间。为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令集按用途大致分成9类。</p>
<ul>
<li><p>加载与存储指令</p>
</li>
<li><p>算术指令</p>
</li>
<li><p>类型转换指令</p>
</li>
<li><p>对象的创建与访问指令</p>
</li>
<li><p>方法调用与返回指令</p>
</li>
<li><p>操作数栈管理指令</p>
</li>
<li><p>比较控制指令</p>
</li>
<li><p>异常处理指令</p>
</li>
<li><p>同步控制指令</p>
</li>
</ul>
<p>（说在前面）在做值相关操作时：</p>
<ul>
<li><p>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。</p>
</li>
<li><p>一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作。</p>
</li>
</ul>
<h1 id="二、加载与存储指令"><a href="#二、加载与存储指令" class="headerlink" title="二、加载与存储指令"></a>二、加载与存储指令</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。</p>
<h2 id="2-常用指令"><a href="#2-常用指令" class="headerlink" title="2. 常用指令"></a>2. 常用指令</h2><ol>
<li>【局部变量压栈指令】将一个局部变量加载到操作数栈：xload、xload_<n>（其中x为i、l、f、d、a，n为0到3）</li>
<li>【常量入栈指令】将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d></li>
<li>【出栈装入局部变量表指令】将一个数值从操作数栈存储到局部变量表：xstore、xstore_<n>（其中x为i、l、f、d、a，n为0到3）；xastore（其中x为i、l、f、d、a、b、c、s）</li>
<li>扩充局部变量表的访问索引的指令：wide。</li>
</ol>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_<n>）。这些指令助记符实际上代表了一组指令（例如iload_<n>代表了<code>iload_0、iload_1、iload_2</code>和<code>iload_3</code>这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</p>
<p>除此之外，它们的语义与原生的通用指令完全一致（例如<code>iload_0</code>的语义与操作数为0时的iload指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<n>代表非负的整数，<i>代表是int类型数据，<l>代表long类型，<f>代表float类型，<d>代表double类型。</p>
<p>操作byte、char、short和boolean类型数据时，经常用int类型的指令来表示。</p>
<h2 id="3-再谈操作数栈与局部变量表"><a href="#3-再谈操作数栈与局部变量表" class="headerlink" title="3. 再谈操作数栈与局部变量表"></a>3. 再谈操作数栈与局部变量表</h2><h3 id="3-1-操作数栈（Operand-Stacks）"><a href="#3-1-操作数栈（Operand-Stacks）" class="headerlink" title="3.1 操作数栈（Operand Stacks）"></a>3.1 操作数栈（Operand Stacks）</h3><p>我们知道，Java字节码是Java虚拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p>
<p>具体来说便是：执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-134709.png" alt="操作数栈1"></p>
<p>以加法指令iadd为例。假设在执行该指令前，栈顶的两个元素分别为int值1和int值2，那么iadd指令将弹出这两个int，并将求得的和int值3压入栈中。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-134734.png" alt="操作数栈2"></p>
<p>由于iadd指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</p>
<h3 id="3-2-局部变量表（Local-Variables）"><a href="#3-2-局部变量表（Local-Variables）" class="headerlink" title="3.2 局部变量表（Local Variables）"></a>3.2 局部变量表（Local Variables）</h3><p>Java方法栈桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p>
<p>实际上，Java虚拟机将局部变量区当成一个数组，依次存放this指针（<strong>仅非静态方法</strong>），所传入的参数，以及字节码中的局部变量。</p>
<p>和操作数栈一样，long类型以及double类型的值将占据两个单元，其余类型仅占据一个单元。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-210722.png" alt="不同类型占局部变量表长度"></p>
<p>举例：</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">long</span> l, <span class="type">float</span> f)</span> &#123;
    &#123;
        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> e;
    &#125;
    &#123;
        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello, World&quot;</span>;
    &#125;
&#125;</code></pre>

<p>对应的图示：</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-210848.png" alt="局部变量表"></p>
<p>this表示当前类的引用，l 和 f 的类型的值占两个槽位，i 和 s 变量由于分别在各自代码块中，没有共同的生命周期，所以占同一个槽位（即槽位复用）</p>
<p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<h3 id="3-3-局部变量压栈指令"><a href="#3-3-局部变量压栈指令" class="headerlink" title="3.3 局部变量压栈指令"></a>3.3 局部变量压栈指令</h3><ul>
<li><code>iload</code> 从局部变量中装载int类型值</li>
<li><code>lload</code> 从局部变量中装载long类型值</li>
<li><code>fload</code> 从局部变量中装载float类型值</li>
<li><code>dload</code> 从局部变量中装载double类型值</li>
<li><code>aload</code> 从局部变量中装载引用类型值（refernce）</li>
<li><code>iload_0</code> ,<code>iload_1</code>,<code>iload_2</code>,<code>iload_3</code> 将局部变量表下标为0, 1, 2, 3的 <code>int类型</code> 的值,加载到操作数栈中</li>
<li><code>lload_0</code> ,<code>lload_1</code> ,<code>lload_2</code> ,<code>lload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>long类型</code> 的值,加载到操作数栈中</li>
<li><code>fload_0</code>, <code>fload_1</code>, <code>fload_2</code>, <code>fload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>float类型</code> 的值,加载到操作数栈中</li>
<li><code>dload_0</code>, <code>dload_1</code>, <code>dload_2</code>, <code>dload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>double类型</code> 的值,加载到操作数栈中</li>
<li><code>aload_0</code>, <code>aload_1</code>, <code>aload_2</code>, <code>aload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>引用类型</code> 的值,加载到操作数栈中</li>
<li><code>iaload</code> 将 int 型数组指定索引的值推送至栈顶, 执行该指令后，将从操作数栈出栈2个参数arrayref和index</li>
<li><code>laload</code> 将 long 型数组指定索引的值推送至栈顶</li>
<li><code>faload</code> 将 float 型数组指定索引的值推送至栈顶</li>
<li><code>daload</code> 将 double 型数组指定索引的值推送至栈顶</li>
<li><code>aaload</code> 将引用型数组指定索引的值推送至栈顶</li>
<li><code>baload</code> 将byte类型或boolean类型值数组指定索引的值推送至栈顶</li>
<li><code>caload</code> 将char型数组指定索引的值推送至栈顶</li>
<li><code>saload</code> 将 short 型数组指定索引的值推送至栈顶</li>
</ul>
<h4 id="3-3-1-局部变量压栈指令剖析"><a href="#3-3-1-局部变量压栈指令剖析" class="headerlink" title="3.3.1 局部变量压栈指令剖析"></a>3.3.1 局部变量压栈指令剖析</h4><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈, 这类指令大体可以分为：</p>
<ul>
<li><p><code>xload_&lt;n&gt;</code>（x为i、l、f、d、a，n为0到3）</p>
</li>
<li><p><code>xload</code>（x为i、l、f、d、a）</p>
</li>
</ul>
<p><strong>说明：</strong>在这里，x的取值表示数据类型。</p>
<p>指令xload_n表示将第n个局部变量压入操作数栈，比如iload_1、fload_0、aload_0等指令。其中aload_n表示将一个对象引用压栈。</p>
<p>指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令iload、fload等。</p>
<p><strong>举例：</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num, Object obj, <span class="type">long</span> count, <span class="type">boolean</span> flag, <span class="type">short</span>[] arr)</span> &#123;
    System.out.println(num);
    System.out.println(obj);
    System.out.println(count);
    System.out.println(flag);
    System.out.println(arr);
&#125;</code></pre>

<p><strong>字节码执行过程：</strong></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-093706.png" alt="字节码执行过程"></p>
<h3 id="3-4-常量入栈指令"><a href="#3-4-常量入栈指令" class="headerlink" title="3.4 常量入栈指令"></a>3.4 常量入栈指令</h3><ul>
<li><code>aconst_null</code> 将null对象引用压入栈</li>
<li><code>iconst_m1</code> 将int类型常量-1压入栈</li>
<li><code>iconst_0</code>, <code>iconst_1</code>, <code>iconst_2</code>,<code>iconst_3</code>,<code>iconst_4</code>,<code>iconst_5</code> 将int类型常量 0, 1, 2, 3, 4, 5 压入栈</li>
<li><code>lconst_0</code>, <code>lconst_1</code>, 将long类型常量0, 1压入栈</li>
<li><code>fconst_0</code>, <code>fconst_1</code> 将float类型常量0, 1压入栈</li>
<li><code>dconst_0</code>, <code>dconst_1</code> 将double类型常量0, 1压入栈</li>
<li><code>bipush</code> 将一个8位带符号整数压入栈(-128~127)</li>
<li><code>sipush</code> 将16位带符号整数压入栈(-32768~32767)</li>
<li><code>ldc index</code> 加载常量池中的无符号byte类型的常量到操作数栈，‌index 最大值是 255, 索引指向的数据类型可以是： <code>int</code>、 <code>float</code> 或 <code>String</code></li>
<li><code>ldc_w index</code>  如果常量池的大小超过255，‌或者需要加载的常量值超过一个byte可以表示的范围，‌这时就需要使用 <code>ldc_w</code> 指令。‌<code>ldc_w</code> 指令可以加载常量池中的宽索引项到操作数栈，‌从而支持更大的常量值。‌索引指向的数据类型可以是： <code>int</code>、 <code>float</code> 或 <code>String</code></li>
<li><code>ldc2_w index</code> 将long或double型常量值从常量池中推送至栈顶（宽索引）（分两次压入，因为 long, double 是 8 个字节）索引指向的数据类型可以是： <code>int</code>、 <code>float</code> 或 <code>String</code></li>
</ul>
<h4 id="3-4-1-常量入栈常用指令集"><a href="#3-4-1-常量入栈常用指令集" class="headerlink" title="3.4.1 常量入栈常用指令集"></a>3.4.1 常量入栈常用指令集</h4><table>
<thead>
<tr>
<th>xconst_n</th>
<th>范围</th>
<th>xconst_null</th>
<th>xconst_m1</th>
<th>xconst_0</th>
<th>xconst_1</th>
<th>xconst_2</th>
<th>xconst_3</th>
<th>xconst_4</th>
<th>xconst_5</th>
</tr>
</thead>
<tbody><tr>
<td><strong>iconst_n</strong></td>
<td>[-1, 5]</td>
<td></td>
<td>iconst_m1</td>
<td>iconst_0</td>
<td>iconst_1</td>
<td>iconst_2</td>
<td>iconst_3</td>
<td>iconst_4</td>
<td>iconst_5</td>
</tr>
<tr>
<td><strong>lconst_n</strong></td>
<td>0, 1</td>
<td></td>
<td></td>
<td>lconst_0</td>
<td>lconst_1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>fconst_n</strong></td>
<td>0, 1, 2</td>
<td></td>
<td></td>
<td>fconst_0</td>
<td>fconst_1</td>
<td>fconst_2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>dconst_n</strong></td>
<td>0, 1</td>
<td></td>
<td></td>
<td>dconst_0</td>
<td>dconst_1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>aconst_n</strong></td>
<td>null, String literal, Class literal</td>
<td>aconst_null</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>bipush</strong></td>
<td>一个字节有符号整数，[-2<sup>7</sup>, 2<sup>7</sup> - 1]，即[-128, 127]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>sipush</strong></td>
<td>两个字节有符号整数，[-2<sup>15</sup>, 2<sup>15</sup> - 1]，即[-32768, 32767]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ldc</strong></td>
<td>1个字节(8位)无符号数，-2<sup>8</sup> - 1, 即不超过255</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ldc_w</strong></td>
<td>宽索引, 接收两个8位参数，能支持的索引范围大于ldc, 索引范围比ldc更大</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ldc2_w</strong></td>
<td>宽索引，long或double</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="3-4-2-常量入栈指令剖析"><a href="#3-4-2-常量入栈指令剖析" class="headerlink" title="3.4.2 常量入栈指令剖析"></a>3.4.2 常量入栈指令剖析</h4><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 const 系列、push 系列和 ldc 指令。</p>
<p>指令const系列：用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：<code>iconst_&lt;i&gt;（i从-1到5）、lconst_&lt;l&gt;（l从0到1）、fconst_&lt;f&gt;（f从0到2）、dconst_&lt;d&gt;（d从0到1）、aconst_null</code>。比如，</p>
<ul>
<li><p><code>iconst_m1</code> 将-1压入操作数栈；</p>
</li>
<li><p><code>iconst_x</code>（x为0到5）将x压入栈；</p>
</li>
<li><p><code>lconst_0</code>、<code>lconst_1</code>分别将长整数0和1压入栈；</p>
</li>
<li><p><code>fconst_0</code>、<code>fconst_1</code>、<code>fconst_2</code> 分别将浮点数0、1、2压入栈；</p>
</li>
<li><p><code>dconst_0</code> 和 <code>dconst_1</code> 分别将double型0和1压入栈；</p>
</li>
<li><p><code>aconst_null</code> 将null压入操作数栈；</p>
</li>
</ul>
<p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i表示整数，l表示长整数，f表示浮点数，d表示双精度浮点，习惯上用a表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</p>
<p>指令push系列：主要包括bipush和sipush。它们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈。</p>
<p>指令ldc系列：如果以上指令都不能满足需求，那么可以使用万能的</p>
<ul>
<li><p>ldc 指令，它可以接收一个8位的参数，该参数指向常量池中的int、float或者String的索引，将指定的内容压入堆栈。</p>
</li>
<li><p>类似的还有ldc_w，它接收两个8位参数，能支持的索引范围大于ldc。</p>
</li>
<li><p>如果要压入的元素是long或者double类型的，则使用ldc2_w指令，使用方式都是类似的</p>
</li>
</ul>
<p>总结如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>常数指令</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>int(boolean,byte,char,short)</td>
<td>iconst</td>
<td>[-1, 5]</td>
</tr>
<tr>
<td></td>
<td>bipush</td>
<td>[-128, 127]</td>
</tr>
<tr>
<td></td>
<td>sipush</td>
<td>[-32768, 32767]</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any int value</td>
</tr>
<tr>
<td>long</td>
<td>lconst</td>
<td>0, 1</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any long value</td>
</tr>
<tr>
<td>float</td>
<td>fconst</td>
<td>0, 1, 2</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any float value</td>
</tr>
<tr>
<td>double</td>
<td>dconst</td>
<td>0, 1</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any double value</td>
</tr>
<tr>
<td>reference</td>
<td>aconst</td>
<td>null</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>String literal, Class literal</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-105330.png" alt="字节码指令示例1"></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-105342.png" alt="字节码指令示例2"></p>
<h3 id="3-5-出栈装入局部变量表指令"><a href="#3-5-出栈装入局部变量表指令" class="headerlink" title="3.5 出栈装入局部变量表指令"></a>3.5 出栈装入局部变量表指令</h3><ul>
<li><p><code>istore</code> 将int类型值存入局部变量</p>
</li>
<li><p><code>lstore</code> 将long类型值存入局部变量</p>
</li>
<li><p><code>fstore</code> 将float类型值存入局部变量</p>
</li>
<li><p><code>dstore</code> 将double类型值存入局部变量</p>
</li>
<li><p><code>astore</code> 将将引用类型或returnAddress类型值存入局部变量</p>
</li>
<li><p><code>istore_0</code>, <code>istore_1</code>, <code>istore_2</code>, <code>istore_3</code> 分别将int类型值存入局部变量0, 1, 2, 3索引位置</p>
</li>
<li><p><code>lstore_0</code>, <code>lstore_1</code>, <code>lstore_2</code>, <code>lstore_3</code> 将long类型值存入局部变量0, 1, 2, 3 索引位置</p>
</li>
<li><p><code>fstore_0</code>, <code>fstore_1</code>, <code>fstore_2</code>, <code>fstore_3</code>, 将float类型值存入局部变量0, 1, 2, 3 索引位置</p>
</li>
<li><p><code>dstore_0</code>, <code>dstore_1</code>, <code>dstore_2</code>, <code>dstore_3</code>, 将double类型值存入局部变量0</p>
</li>
<li><p><code>astore_0</code>, <code>astore_1</code>, <code>astore_2</code>, <code>astore_3</code> 将引用类型或returnAddress类型值存入局部变量0, 1, 2, 3 索引位置</p>
</li>
<li><p><code>iastore</code> 将int类型值存入数组中</p>
</li>
<li><p><code>lastore</code> 将long类型值存入数组中</p>
</li>
<li><p><code>fastore</code> 将float类型值存入数组中</p>
</li>
<li><p><code>dastore</code> 将double类型值存入数组中</p>
</li>
<li><p><code>aastore</code> 将引用类型值存入数组中</p>
</li>
<li><p><code>bastore</code> 将byte类型或者boolean类型值存入数组中</p>
</li>
<li><p><code>castore</code> 将char类型值存入数组中</p>
</li>
<li><p><code>sastore</code> 将short类型值存入数组中</p>
</li>
<li><p>wide指令</p>
</li>
<li><p>wide 使用附加字节扩展局部变量索引</p>
</li>
</ul>
<h4 id="3-5-1-出栈装入局部变量表指令剖析"><a href="#3-5-1-出栈装入局部变量表指令剖析" class="headerlink" title="3.5.1 出栈装入局部变量表指令剖析"></a>3.5.1 出栈装入局部变量表指令剖析</h4><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。这类指令主要以store的形式存在，比如<code>xstore（x为i、l、f、d、a）、xstore_n（x为i、l、f、d、a，n为0至3）</code>。</p>
<ul>
<li><p>其中，指令istore_n将从操作数栈中弹出一个整数，并把它值给局部变量索引n位置。</p>
</li>
<li><p>指令xstore由于没有隐含参数信息，故需要提供一个byte类型的参数类指定目标局部变量表的位置。</p>
</li>
</ul>
<p>说明：一般说来，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的istore_1指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置。由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于3，那么可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-110910.png" alt="字节码指令执行过程"></p>
<h1 id="三、算数指令"><a href="#三、算数指令" class="headerlink" title="三、算数指令"></a>三、算数指令</h1><h2 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h2><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</p>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h2><p>大体上算术指令可以分为两种：对<strong>整型数据进行运算</strong>的指令与对<strong>浮点类型数据进行运算</strong>的指令。</p>
<h2 id="3-byte、short、char和boolean类型说明"><a href="#3-byte、short、char和boolean类型说明" class="headerlink" title="3. byte、short、char和boolean类型说明"></a>3. byte、short、char和boolean类型说明</h2><p>在每一大类中，都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、char和boolean类型的算术指令，对于这些数据的运算，都使用int类型的指令来处理。此外，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-111216.png" alt="java虚拟机中实际类型与运算类型"></p>
<h2 id="4-运算时的溢出"><a href="#4-运算时的溢出" class="headerlink" title="4. 运算时的溢出"></a>4. 运算时的溢出</h2><p>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常ArithmeticException。</p>
<h2 id="5-运算模式"><a href="#5-运算模式" class="headerlink" title="5. 运算模式"></a>5. 运算模式</h2><p><strong>向最接近数舍入模式</strong>：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；</p>
<p><strong>向零舍入模式</strong>：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；</p>
<h2 id="6-NaN值使用"><a href="#6-NaN值使用" class="headerlink" title="6. NaN值使用"></a>6. NaN值使用</h2><p>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值来表示。而且所有使用NaN值作为操作数的算术操作，结果都会返回NaN；</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-111920.png" alt="无穷大与NaN"></p>
<h2 id="7-所有算术指令"><a href="#7-所有算术指令" class="headerlink" title="7. 所有算术指令"></a>7. 所有算术指令</h2><p><strong>整数运算</strong></p>
<ul>
<li><code>iadd</code> 执行int类型的加法</li>
<li><code>ladd</code> 执行long类型的加法</li>
<li><code>isub</code> 执行int类型的减法</li>
<li><code>lsub</code> 执行long类型的减法</li>
<li><code>imul</code> 执行int类型的乘法</li>
<li><code>lmul</code> 执行long类型的乘法</li>
<li><code>idiv</code> 执行int类型的除法</li>
<li><code>ldiv</code> 执行long类型的除法</li>
<li><code>irem</code> 计算int类型除法的余数</li>
<li><code>lrem</code> 计算long类型除法的余数</li>
<li><code>ineg</code> 对一个int类型值进行取反操作</li>
<li><code>lneg</code> 对一个long类型值进行取反操作</li>
<li><code>iinc</code> 把一个常量值加到一个int类型的局部变量上</li>
</ul>
<p><strong>移位操作</strong></p>
<ul>
<li><code>ishl</code> 执行int类型的向左移位操作</li>
<li><code>lshl</code> 执行long类型的向左移位操作</li>
<li><code>ishr</code> 执行int类型的向右移位操作</li>
<li><code>lshr</code> 执行long类型的向右移位操作</li>
<li><code>iushr</code> 执行int类型的向右逻辑移位操作</li>
<li><code>lushr</code> 执行long类型的向右逻辑移位操作</li>
</ul>
<p><strong>按位布尔运算</strong></p>
<ul>
<li><code>iand</code> 对int类型值进行“逻辑与”操作</li>
<li><code>land</code> 对long类型值进行“逻辑与”操作</li>
<li><code>ior</code> 对int类型值进行“逻辑或”操作</li>
<li><code>lor</code> 对long类型值进行“逻辑或”操作</li>
<li><code>ixor</code> 对int类型值进行“逻辑异或”操作</li>
<li><code>lxor</code> 对long类型值进行“逻辑异或”操作</li>
</ul>
<p><strong>浮点运算</strong></p>
<ul>
<li><code>fadd</code> 执行float类型的加法</li>
<li><code>dadd</code> 执行double类型的加法</li>
<li><code>fsub</code> 执行float类型的减法</li>
<li><code>dsub</code> 执行double类型的减法</li>
<li><code>fmul</code> 执行float类型的乘法</li>
<li><code>dmul</code> 执行double类型的乘法</li>
<li><code>fdiv</code> 执行float类型的除法</li>
<li><code>ddiv</code> 执行double类型的除法</li>
<li><code>frem</code> 计算float类型除法的余数</li>
<li><code>drem</code> 计算double类型除法的余数</li>
<li><code>fneg</code> 将一个float类型的数值取反</li>
<li><code>dneg</code> 将一个double类型的数值取反</li>
</ul>
<p><strong>算术指令集</strong></p>
<table>
<thead>
<tr>
<th>算数指令</th>
<th>int(boolean,byte,char,short)</th>
<th>long</th>
<th>float</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>加法指令</td>
<td>iadd</td>
<td>ladd</td>
<td>fadd</td>
<td>dadd</td>
</tr>
<tr>
<td>减法指令</td>
<td>isub</td>
<td>lsub</td>
<td>fsub</td>
<td>dsub</td>
</tr>
<tr>
<td>乘法指令</td>
<td>imul</td>
<td>lmul</td>
<td>fmul</td>
<td>dmul</td>
</tr>
<tr>
<td>除法指令</td>
<td>idiv</td>
<td>ldiv</td>
<td>fdiv</td>
<td>ddiv</td>
</tr>
<tr>
<td>求余指令</td>
<td>irem</td>
<td>lrem</td>
<td>frem</td>
<td>drem</td>
</tr>
<tr>
<td>取反指令</td>
<td>ineg</td>
<td>lneg</td>
<td>fneg</td>
<td>dneg</td>
</tr>
<tr>
<td>自增指令</td>
<td>iinc</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>位运算指令</td>
<td>按位或指令</td>
<td>ior</td>
<td>lor</td>
<td></td>
</tr>
<tr>
<td></td>
<td>按位或指令</td>
<td>ior</td>
<td>lor</td>
<td></td>
</tr>
<tr>
<td></td>
<td>按位与指令</td>
<td>iand</td>
<td>land</td>
<td></td>
</tr>
<tr>
<td></td>
<td>按位异或指令</td>
<td>ixor</td>
<td>lxor</td>
<td></td>
</tr>
<tr>
<td>比较指令</td>
<td></td>
<td>lcmp</td>
<td>fcmpg &#x2F; fcmpl</td>
<td>dcmpg &#x2F; dcmpl</td>
</tr>
</tbody></table>
<p><strong>示例1</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;
	<span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;
	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;
	<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;
&#125;</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145225.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145233.png" alt="2"></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145245.png" alt="3"></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145254.gif" alt="4"></p>
<p><strong>示例2</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;
	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;
	<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;
	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;
	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;
	System.out.println(a + b);
&#125;</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145932.png" alt="1"></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145944.png" alt="2"></p>
<h1 id="四、类型转换指令"><a href="#四、类型转换指令" class="headerlink" title="四、类型转换指令"></a>四、类型转换指令</h1><h2 id="1-类型转换指令说明"><a href="#1-类型转换指令说明" class="headerlink" title="1. 类型转换指令说明"></a>1. 类型转换指令说明</h2><ul>
<li>类型转换指令可以将两种不同的数值类型进行相互转换。</li>
<li>这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</li>
</ul>
<p><strong>宽化类型转换指令</strong></p>
<ul>
<li><code>i2l</code> 把int类型的数据转化为long类型</li>
<li><code>i2f</code> 把int类型的数据转化为float类型</li>
<li><code>i2d</code> 把int类型的数据转化为double类型</li>
<li><code>l2f</code> 把long类型的数据转化为float类型</li>
<li><code>l2d</code> 把long类型的数据转化为double类型</li>
<li><code>f2d</code> 把float类型的数据转化为double类型</li>
</ul>
<p><strong>窄化类型转换</strong></p>
<ul>
<li><code>i2b</code> 把int类型的数据转化为byte类型</li>
<li><code>i2c</code> 把int类型的数据转化为char类型</li>
<li><code>i2s</code> 把int类型的数据转化为short类型</li>
<li><code>l2i</code> 把long类型的数据转化为int类型</li>
<li><code>f2i</code> 把float类型的数据转化为int类型</li>
<li><code>f2l</code> 把float类型的数据转化为long类型</li>
<li><code>d2i</code> 把double类型的数据转化为int类型</li>
<li><code>d2l</code> 把double类型的数据转化为long类型</li>
<li><code>d2f</code> 把double类型的数据转化为float类型</li>
</ul>
<p><strong>类型转换指令集</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>byte</strong></th>
<th><strong>char</strong></th>
<th><strong>short</strong></th>
<th><strong>int</strong></th>
<th><strong>long</strong></th>
<th><strong>float</strong></th>
<th><strong>double</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>int</strong></td>
<td>i2b</td>
<td>i2c</td>
<td>i2s</td>
<td>-</td>
<td>i2l</td>
<td>i2f</td>
<td>i2d</td>
</tr>
<tr>
<td><strong>long</strong></td>
<td>l2i   i2b</td>
<td>l2i   i2c</td>
<td>l2i   i2s</td>
<td>l2i</td>
<td>-</td>
<td>l2f</td>
<td>l2d</td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>f2i   i2b</td>
<td>f2i   i2c</td>
<td>f2i   i2s</td>
<td>f2i</td>
<td>f2l</td>
<td>-</td>
<td>f2d</td>
</tr>
<tr>
<td><strong>double</strong></td>
<td>d2i   i2b</td>
<td>d2i   i2c</td>
<td>d2i   i2s</td>
<td>d2i</td>
<td>d2l</td>
<td>d2f</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="2-宽化类型转换指令"><a href="#2-宽化类型转换指令" class="headerlink" title="2. 宽化类型转换指令"></a>2. 宽化类型转换指令</h2><p><strong>宽化类型转换( Widening Numeric Conversions)</strong></p>
<h3 id="2-1-转换规则"><a href="#2-1-转换规则" class="headerlink" title="2.1 转换规则"></a>2.1 转换规则</h3><p>Java虚拟机直接支持以下数值的宽化类型转换（ widening numeric conversion,小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括</p>
<ul>
<li><p>从int类型到long、float或者 double类型。对应的指令为：i21、i2f、i2d </p>
</li>
<li><p>从long类型到float、 double类型。对应的指令为：l2f、l2d </p>
</li>
<li><p>从float类型到double类型。对应的指令为：f2d</p>
</li>
</ul>
<p>简化为：int–&gt;long–&gt;float-&gt; double</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7206123045855969337">float的表示范围为什么比long大?</a></p>
<h3 id="2-2-精度损失问题"><a href="#2-2-精度损失问题" class="headerlink" title="2.2 精度损失问题"></a>2.2 精度损失问题</h3><ul>
<li><p>宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long,或者从int转换到double,都不会丢失任何信息，转换前后的值是精确相等的。 </p>
</li>
<li><p>从int、long类型数值转换到float，或者long类型数值转换到double时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近含入模式所得到的正确整数值。</p>
</li>
</ul>
<p><strong>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java虚拟机抛出运行时异常</strong></p>
<h3 id="2-3-补充说明"><a href="#2-3-补充说明" class="headerlink" title="2.3 补充说明"></a>2.3 补充说明</h3><p>从byte、char和 short类型到int类型的宽化类型转换实际上是不存在的。对于byte类型转为int,虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交換了两个数据。而将byte转为long时，使用的是i2l,可以看到在内部，byte在这里已经等同于int类型处理，类似的还有 short类型，这种处理方式有两个特点：</p>
<ul>
<li>一方面可以减少实际的数据类型，如果为 short和byte都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short和byte当做int处理也在情理之中。</li>
<li>另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者 short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</li>
</ul>
<h2 id="3-窄化类型转换指令"><a href="#3-窄化类型转换指令" class="headerlink" title="3. 窄化类型转换指令"></a>3. 窄化类型转换指令</h2><p><strong>窄化类型转换( Narrowing Numeric Conversion)</strong></p>
<h3 id="3-1-转换规则"><a href="#3-1-转换规则" class="headerlink" title="3.1 转换规则"></a>3.1 转换规则</h3><p>Java虚拟机也直接支持以下窄化类型转换：</p>
<ul>
<li><p>从主int类型至byte、 short或者char类型。对应的指令有：i2b、i2c、i2s </p>
</li>
<li><p>从long类型到int类型。对应的指令有：l2i </p>
</li>
<li><p>从float类型到int或者long类型。对应的指令有：f2i、f2l </p>
</li>
<li><p>从double类型到int、long或者float类型。对应的指令有：d2i、d2l、d2f</p>
</li>
</ul>
<h3 id="3-2-精度损失问题"><a href="#3-2-精度损失问题" class="headerlink" title="3.2 精度损失问题"></a>3.2 精度损失问题</h3><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p>
<p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p>
<h3 id="3-3-补充说明"><a href="#3-3-补充说明" class="headerlink" title="3.3 补充说明"></a>3.3 补充说明</h3><p>当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则：</p>
<ul>
<li><p>如果浮点值是NaN,那转换结果就是int或long类型的0. </p>
</li>
<li><p>如果浮点值不是无穷大的话，浮点值使用IEEE754的向零含入模式取整，获得整数值v。如果v在目标类型T(int或long)的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数</p>
</li>
</ul>
<p>当将一个double类型窄化转换为float类型时，将遵循以下转换规则，通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断：</p>
<ul>
<li><p>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零 </p>
</li>
<li><p>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大。 </p>
</li>
<li><p>对于double类型的NaN值将按规定转换为float类型的NaN值。</p>
</li>
</ul>
<h1 id="五、对象的创建与访问指令"><a href="#五、对象的创建与访问指令" class="headerlink" title="五、对象的创建与访问指令"></a>五、对象的创建与访问指令</h1><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p>
<ul>
<li><strong>对象操作指令</strong><ul>
<li><code>new</code> 创建一个新对象</li>
<li><code>getfield</code> 从对象中获取字段</li>
<li><code>putfield</code> 设置对象中字段的值</li>
<li><code>getstatic</code> 从类中获取静态字段</li>
<li><code>putstatic</code> 设置类中静态字段的值</li>
<li><code>checkcast</code> 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。如果不是便抛出异常</li>
<li><code>instanceof</code> 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。是则压入 1，否则压入 0</li>
</ul>
</li>
<li><strong>数组操作指令</strong><ul>
<li><code>newarray</code> 分配数据成员类型为基本数据类型的新数组</li>
<li><code>anewarray</code> 分配数据成员类型为引用类型的新数组</li>
<li><code>arraylength</code> 获取数组长度</li>
<li><code>multianewarray</code> 分配新的多维数组</li>
</ul>
</li>
</ul>
<h2 id="1-创建指令"><a href="#1-创建指令" class="headerlink" title="1. 创建指令"></a>1. 创建指令</h2><table>
<thead>
<tr>
<th>创建指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>new</td>
<td>创建类实例</td>
</tr>
<tr>
<td>newarray</td>
<td>创建基本类型数组</td>
</tr>
<tr>
<td>anewarray</td>
<td>创建引用类型数组</td>
</tr>
<tr>
<td>multilanewarra</td>
<td>创建多维数组</td>
</tr>
</tbody></table>
<p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p>
<ul>
<li>创建类实例的指令： <ul>
<li>创建类实例的指令：new</li>
<li>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。</li>
</ul>
</li>
<li>创建数组的指令： <ul>
<li>创建数组的指令：newarray、anewarray、multianewarray</li>
<li>上述创建指令可以用于创建对象或者数组，由于对象和数组在Java中的广泛使用，这些指令的使用频率也非常高。</li>
</ul>
</li>
</ul>
<h2 id="2-字段访问指令"><a href="#2-字段访问指令" class="headerlink" title="2. 字段访问指令"></a>2. 字段访问指令</h2><table>
<thead>
<tr>
<th>字段访问指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>getstatic、putstatic</td>
<td>访问类字段（static字段，或者称为类变量）的指令</td>
</tr>
<tr>
<td>getfield、 putfield</td>
<td>访问类实例字段（非static字段，或者称为实例变量）的指令</td>
</tr>
</tbody></table>
<p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p>
<ul>
<li><p>访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic</p>
</li>
<li><p>访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield</p>
</li>
</ul>
<p>举例：以getstatic指令为例，它含有一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈。</p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderId</span><span class="params">()</span>&#123;
    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();
    order.id = <span class="number">1001</span>;
    System.out.println(order.id);

    Order.name = <span class="string">&quot;ORDER&quot;</span>;
    System.out.println(Order.name);
&#125;

<span class="comment">// Order类代码如下:</span>
<span class="keyword">class</span> <span class="title class_">Order</span>&#123;
    <span class="type">int</span> id;
    <span class="keyword">static</span> String name;
&#125;</code></pre>



<p>setOrderId() 方法对应的字节码指令：</p>
<pre><code class="highlight shell"> 0 new #11 &lt;com/atguigu/java/Order&gt;
 3 dup
 4 invokespecial #12 &lt;com/atguigu/java/Order.&lt;init&gt; : ()V&gt;
 7 astore_1
 8 aload_1
 9 sipush 1001
12 putfield #13 &lt;com/atguigu/java/Order.id : I&gt;
15 getstatic #8 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;
18 aload_1
19 getfield #13 &lt;com/atguigu/java/Order.id : I&gt;
22 invokevirtual #14 &lt;java/io/PrintStream.println : (I)V&gt;
25 ldc #15 &lt;ORDER&gt;
27 putstatic #16 &lt;com/atguigu/java/Order.name : Ljava/lang/String;&gt;
30 getstatic #8 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;
33 getstatic #16 &lt;com/atguigu/java/Order.name : Ljava/lang/String;&gt;
36 invokevirtual #10 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;
39 return</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/28/20240728-104906.png" alt="字节码指令执行过程"></p>
<h2 id="3-数组操作指令"><a href="#3-数组操作指令" class="headerlink" title="3. 数组操作指令"></a>3. 数组操作指令</h2><p>数组操作指令主要有：xastore和xaload指令。具体为：</p>
<ul>
<li><p>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</p>
</li>
<li><p>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>数组指令</th>
<th>byte(boolean)</th>
<th>char</th>
<th>short</th>
<th>long</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xaload</strong></td>
<td>baload</td>
<td>caload</td>
<td>saload</td>
<td>iaload</td>
<td>laload</td>
<td>faload</td>
<td>daload</td>
<td>aaload</td>
</tr>
<tr>
<td><strong>xastore</strong></td>
<td>bastore</td>
<td>castore</td>
<td>sastore</td>
<td>iastore</td>
<td>lastore</td>
<td>fastore</td>
<td>dastore</td>
<td>aastore</td>
</tr>
</tbody></table>
<p>取数组长度的指令：<code>arraylength</code>。该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈。</p>
<p>指令 <code>xaload</code> 表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引 i，栈顶顺位第2个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 a[i] 重新压入栈。</p>
<p><code>xastore</code> 则专门针对数组操作，以 iastore 为例，它用于给一个int数组的给定索引赋值。在iastore执行前，操作数栈顶需要以此准备3个元素：值、索引、数组引用，iastore会弹出这3个值，并将值赋给数组中指定索引的位置。</p>
<h2 id="4-类型检查指令"><a href="#4-类型检查指令" class="headerlink" title="4. 类型检查指令"></a>4. 类型检查指令</h2><p>检查类实例或数组类型的指令：instanceof、checkcast。</p>
<ul>
<li>指令 <code>instanceof</code> 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈</li>
<li>指令 <code>checkcast</code> 用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常</li>
</ul>
<table>
<thead>
<tr>
<th>类型检查指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>instanceof</td>
<td>判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。是则压入 1，否则压入 0</td>
</tr>
<tr>
<td>checkcast</td>
<td>确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。如果不是便抛出异常</td>
</tr>
</tbody></table>
<h1 id="六、方法的调用与返回指令"><a href="#六、方法的调用与返回指令" class="headerlink" title="六、方法的调用与返回指令"></a>六、方法的调用与返回指令</h1><ul>
<li><strong>方法调用指令</strong><ul>
<li>invokevirtual 运行时按照对象的类来调用实例方法</li>
<li>invokespecial 根据编译时类型来调用实例方法</li>
<li>invokestatic 调用类（静态）方法</li>
<li>invokcinterface 调用接口方法</li>
</ul>
</li>
<li><strong>方法返回指令</strong><ul>
<li>ireturn 从方法中返回int类型的数据</li>
<li>lreturn 从方法中返回long类型的数据</li>
<li>freturn 从方法中返回float类型的数据</li>
<li>dreturn 从方法中返回double类型的数据</li>
<li>areturn 从方法中返回引用类型的数据</li>
<li>return 从方法中返回，返回值为void</li>
</ul>
</li>
</ul>
<h2 id="1-方法调用指令"><a href="#1-方法调用指令" class="headerlink" title="1. 方法调用指令"></a>1. 方法调用指令</h2><p>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic，以下5条指令用于方法调用：</p>
<ul>
<li><p><code>invokevirtual</code> 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分派方式。</p>
<ul>
<li><p>首先，对象的实例方法是指定义在类中并用关键字“this”引用对象自身的方法，它们以对象作为调用者进行调用，而且同一个类的不同实例对象所调用的同名函数可能会表现出不同的行为。而调用对象的实例方法需要使用特定的指令来完成，Java语言中最常见的方法分派方式就是使用“invokevirtual”指令。</p>
<p>其次，“invokevirtual”指令支持多态，这也是Java语言中的一大特点。多态是指同一个函数名可以被多个子类继承并实现不同的方法，当程序调用该函数时，编译器不能确定调用的是哪个子类的方法，而是在运行时根据对象的实际类型进行分派，即虚方法分派。</p>
<p>具体来说，在执行“invokevirtual”指令时，虚拟机会根据对象的实际类型找到对应的方法，并进行调用。这个过程称为虚拟方法分派，它可以保证程序的灵活性和可扩展性，也是Java语言中面向对象特性的重要体现。</p>
<p>总之，“invokevirtual”指令用于调用对象的实例方法，根据对象的实际类型进行虚方法分派，支持多态，是Java语言中最常用的方法分派方式之一。</p>
</li>
</ul>
</li>
<li><p><code>invokeinterface</code> 指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</p>
</li>
<li><p><code>invokespecial</code> 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发。</p>
</li>
<li><p><code>invokestatic</code> 指令用于调用命名类中的类方法（static方法）。这是静态绑定的。</p>
</li>
<li><p><code>invokedynamic</code> 指令用于调用动态绑定的方法，这个是JDK1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。<code>invokedynamic</code> 指令的分派逻辑是由用户所设定的引导方法决定的，而前面4条调用指令的分派逻辑都固化在java虚拟机内部。</p>
</li>
</ul>
<h2 id="2-方法返回指令"><a href="#2-方法返回指令" class="headerlink" title="2. 方法返回指令"></a>2. 方法返回指令</h2><p>方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的。</p>
<ul>
<li><p>包括ireturn（当返回值是boolean、byte、char、short和int 类型时使用）、lreturn、freturn、dreturn 和 areturn</p>
</li>
<li><p>另外还有一条return 指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法返回指令</th>
<th>void</th>
<th>int、boolean、byte、char、short</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xreturn</strong></td>
<td>return</td>
<td>ireturn</td>
<td>lreturn</td>
<td>freutrn</td>
<td>dreturn</td>
<td>areturn</td>
</tr>
</tbody></table>
<p>通过ireturn指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p>
<p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p>
<p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p>
<p><strong>举例：</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodReturn</span><span class="params">()</span> &#123;
    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>;
    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;
    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">50</span>;
    
    <span class="keyword">return</span> (i + j) / k;
&#125;</code></pre>



<p><strong>图示：</strong></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/28/20240728-113404.png" alt="方法返回指令"></p>
<h1 id="七、操作数栈管理指令"><a href="#七、操作数栈管理指令" class="headerlink" title="七、操作数栈管理指令"></a>七、操作数栈管理指令</h1><h2 id="1-指令概述"><a href="#1-指令概述" class="headerlink" title="1. 指令概述"></a>1. 指令概述</h2><p>如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p>
<p>这类指令包括如下内容：</p>
<ul>
<li><p>将一个或两个元素从栈顶弹出，并且直接废弃：<code>pop，pop2</code></p>
</li>
<li><p>复制栈顶占一个solt长度的值,并重新压入栈的指令: <code>dup，dup_x1，dup_×2</code></p>
</li>
<li><p>复制栈顶占两个solt长度的值(1个八子节或2个四字节的值),并重新压入栈的指令: <code>dup2，dup2_×1，dup2_×2</code></p>
</li>
<li><p>将栈最顶端的两个Slot数值位置交换：<code>swap</code>。Java虚拟机没有提供交换两个64位数据类型（long、double）数值的指令。</p>
</li>
<li><p>指令<code>nop</code>，是一个非常特殊的指令，它的字节码为0x00。和汇编语言中的nop一样，它表示什么都不做。这条指令一般可用于调试、占位等。</p>
</li>
</ul>
<p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。</p>
<ul>
<li><p>不带_x的指令是复制栈顶数据并压入栈顶。包括两个指令，<code>dup，dup2</code>。dup的系数代表要复制的Slot个数。dup开头的指令用于复制1个Slot的数据。例如1个int或1个reference类型数据dup2开头的指令用于复制2个Slot的数据。例如1个long，或2个int，或1个int+1个float类型数据</p>
</li>
<li><p>带_x的指令是复制栈顶数据并插入栈顶以下的某个位置。共有4个指令，<code>dup_×1，dup2_×1，dup_×2，dup2×2</code>。对于带<em>x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置。因此dup</em>×1插入位置：1+1&#x3D;2，即栈顶2个slot下面dup_×2插入位置：1+2&#x3D;3，即栈顶3个slot下面；dup2×1插入位置：2+1&#x3D;3，即栈顶3个Slot下面</p>
</li>
<li><p><code>pop</code>：将栈顶的1个Slot数值出栈。例如1个short类型数值</p>
</li>
<li><p><code>pop2</code>：将栈顶的2个slot数值出栈。例如1个double类型数值，或者2个int类型数值</p>
</li>
</ul>
<h2 id="2-实例解析"><a href="#2-实例解析" class="headerlink" title="2. 实例解析"></a>2. 实例解析</h2><p><strong>代码示例</strong></p>
<pre><code class="highlight java"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;

<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123; <span class="comment">// 返回结果: 0</span>
    <span class="keyword">return</span> ++index;
&#125;</code></pre>



<p><strong>nextIndex()方法字节码</strong></p>
<pre><code class="highlight shell"> 0 aload_0
 1 dup
 2 getfield #2 &lt;com/atguigu/java/StackOperateTest.index : J&gt;
 5 dup2_x1
 6 lconst_1
 7 ladd
 8 putfield #2 &lt;com/atguigu/java/StackOperateTest.index : J&gt;
11 lreturn</code></pre>



<p><strong>字节码解析</strong></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/28/20240728-182711.png" alt="操作数栈指令解析"></p>
<h1 id="八、控制转义指令"><a href="#八、控制转义指令" class="headerlink" title="八、控制转义指令"></a>八、控制转义指令</h1><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为</p>
<ul>
<li><p>比较指令</p>
<ul>
<li><code>lcmp</code> 比较long类型值</li>
<li><code>fcmpl</code> 比较float类型值（当遇到NaN时，返回-1）</li>
<li><code>fcmpg</code> 比较float类型值（当遇到NaN时，返回1）</li>
<li><code>dcmpl</code> 比较double类型值（当遇到NaN时，返回-1）</li>
<li><code>dcmpg</code> 比较double类型值（当遇到NaN时，返回1）</li>
</ul>
</li>
<li><p>条件跳转指令</p>
<ul>
<li><code>ifeq</code> 如果等于0，则跳转</li>
<li><code>ifne</code> 如果不等于0，则跳转</li>
<li><code>iflt</code> 如果小于0，则跳转</li>
<li><code>ifge</code> 如果大于等于0，则跳转</li>
<li><code>ifgt</code> 如果大于0，则跳转</li>
<li><code>ifle</code> 如果小于等于0，则跳转</li>
</ul>
</li>
<li><p>比较条件跳转指令</p>
<ul>
<li><code>if_icmpeq</code> 如果两个int值相等，则跳转</li>
<li><code>if_icmpne</code> 如果两个int类型值不相等，则跳转</li>
<li><code>if_icmplt</code> 如果一个int类型值小于另外一个int类型值，则跳转</li>
<li><code>if_icmpge</code> 如果一个int类型值大于或者等于另外一个int类型值，则跳转</li>
<li><code>if_icmpgt</code> 如果一个int类型值大于另外一个int类型值，则跳转</li>
<li><code>if_icmple</code> 如果一个int类型值小于或者等于另外一个int类型值，则跳转</li>
<li><code>ifnull</code> 如果等于null，则跳转</li>
<li><code>ifnonnull</code> 如果不等于null，则跳转</li>
<li><code>if_acmpeq</code> 如果两个对象引用相等，则跳转</li>
<li><code>if_acmpne</code> 如果两个对象引用不相等，则跳转</li>
</ul>
</li>
<li><p>多条件分支跳转指令</p>
<ul>
<li><code>tableswitch</code> 通过索引访问跳转表，并跳转</li>
<li><code>lookupswitch</code> 通过键值匹配访问跳转表，并执行跳转操作</li>
</ul>
</li>
<li><p>无条件跳转指令等</p>
<ul>
<li><code>goto</code> 无条件跳转</li>
<li><code>goto_w</code> 无条件跳转（宽索引）</li>
</ul>
</li>
</ul>
<h2 id="1-比较指令"><a href="#1-比较指令" class="headerlink" title="1. 比较指令"></a>1. 比较指令</h2><p>比较指令的作用是比较占栈顶两个元素的大小，并将比较结果入栈。比较指令有： <code>dcmpg</code>、<code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code>lcmp</code>。与前面讲解的指令类似，首字符d表示double类型，f表示float, l表示long。</p>
<p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有 fcmpg 和 fcmpl 两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p>
<p>指令 dcmpl 和 dcmpg 也是类似的，根据其命名可以推测其含义，在此不再赘述。</p>
<p>数值类型的数据，才可以谈大小！boolean、引用数据类型不能比较大小。</p>
<p><strong>举例</strong></p>
<pre><code class="highlight java"><span class="comment">//结合比较指令</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compare2</span><span class="params">()</span> &#123;
    <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">9</span>;
    <span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">10</span>;
    System.out.println(f1 &lt; f2);<span class="comment">//true</span>
&#125;</code></pre>

<p><strong>字节码:</strong></p>
<pre><code class="highlight txt"> 0 ldc #2 &lt;9.0&gt;
 2 fstore_1
 3 ldc #3 &lt;10.0&gt;
 5 fstore_2
 6 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;
 9 fload_1
10 fload_2
11 fcmpg
12 ifge 19 (+7)
15 iconst_1
16 goto 20 (+4)
19 iconst_0
20 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;
23 return</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-192344.png" alt="字节码指令执行过程"></p>
<p><strong>解析:</strong></p>
<p>指令 fcmp和fcmpl都从中弹出两个操作数，并将它们做比较，设栈顶的元素为v2，顶顺位第2位的元素为v1：若v1&#x3D;v2，则压入0；若v1&gt;v2，则压入1；若v1&lt;v2，则压入-1。</p>
<p>两个指令的不同之处在于，如果遇到NaN值， fcmpg会压入1,而fcmpl会压入-1</p>
<h2 id="2-条件跳转指令"><a href="#2-条件跳转指令" class="headerlink" title="2. 条件跳转指令"></a>2. 条件跳转指令</h2><p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p>
<p>条件跳转指令有：ifeq，iflt，ifle，ifne，ifgt，ifge，ifnull，ifnonnull。这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）。</p>
<p>它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</p>
<table>
<thead>
<tr>
<th>&lt;</th>
<th>&lt;&#x3D;</th>
<th>&#x3D;&#x3D;</th>
<th>!&#x3D;</th>
<th>&gt;&#x3D;</th>
<th>&gt;</th>
<th>null</th>
<th>not null</th>
</tr>
</thead>
<tbody><tr>
<td>iflt</td>
<td>ifle</td>
<td>ifeq</td>
<td>ifng</td>
<td>ifge</td>
<td>ifgt</td>
<td>ifnull</td>
<td>ifnonnull</td>
</tr>
</tbody></table>
<p>与前面运算规则一致：</p>
<ul>
<li><p>对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成</p>
</li>
<li><p>对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转</p>
</li>
</ul>
<p>由于各类型的比较最终都会转为int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</p>
<h2 id="3-比较条件跳转指令"><a href="#3-比较条件跳转指令" class="headerlink" title="3. 比较条件跳转指令"></a>3. 比较条件跳转指令</h2><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p>
<p>这类指令有：<code>if_icmpeq</code>、<code>if_icmpne</code>、<code>if_icmplt</code>、<code>if_icmpgt</code>、<code>if_icmple</code>、<code>if_icmpge</code>、<code>if_acmpeq</code> 和 <code>if_acmpne</code>。其中指令助记符加上“if_”后，以字符“i”开头的指令针对 int 型整数操作（也包括short和byte类型），以字符“a”开头的指令表示对象引用的比较。</p>
<table>
<thead>
<tr>
<th>&lt;</th>
<th>&lt;&#x3D;</th>
<th>&#x3D;&#x3D;</th>
<th>!&#x3D;</th>
<th>&gt;&#x3D;</th>
<th>&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>if_icmplt</td>
<td>if_icmple</td>
<td>if_icmpeq、if_acmpeq</td>
<td>if_icmpne、if_acmpne</td>
<td>if_icmpge</td>
<td>if_icmpgt</td>
</tr>
</tbody></table>
<p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。如果预设条件成立，则执行跳转，否则，继续执行下一条语句。</p>
<p><strong>示例</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifCompare3</span><span class="params">()</span> &#123;
        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();
        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();
        System.out.println(obj1 == obj2);<span class="comment">//false</span>
        System.out.println(obj1 != obj2);<span class="comment">//true</span>
    &#125;</code></pre>

<p><strong>字节码</strong></p>
<pre><code class="highlight txt"> 0 new #10 &lt;java/lang/Object&gt;
 3 dup
 4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;
 7 astore_1
 8 new #10 &lt;java/lang/Object&gt;
11 dup
12 invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;
15 astore_2
16 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;
19 aload_1
20 aload_2
21 if_acmpne 28 (+7)
24 iconst_1
25 goto 29 (+4)
28 iconst_0
29 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;
32 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;
35 aload_1
36 aload_2
37 if_acmpeq 44 (+7)
40 iconst_1
41 goto 45 (+4)
44 iconst_0
45 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;
48 return</code></pre>



<h2 id="4-多条件分支跳转指令"><a href="#4-多条件分支跳转指令" class="headerlink" title="4. 多条件分支跳转指令"></a>4. 多条件分支跳转指令</h2><p>多条件分支跳转指令是专为switch-case语句设计的，主要有 <code>tableswitch</code> 和 <code>lookupswitch</code> 。</p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tableswitch</td>
<td>用于switch条件跳转，case值连续</td>
</tr>
<tr>
<td>lookupswitch</td>
<td>用于switch条件跳转，case值不连续</td>
</tr>
</tbody></table>
<p>从助记符上看，两者都是switch语句的实现，它们的区别：</p>
<ul>
<li><p><code>tableswitch</code> 要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，因此效率比较高。</p>
</li>
<li><p><code>lookupswitch</code> 内部存放着各个离散的case-offset对，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，因此效率较低。</p>
</li>
</ul>
<p>指令tableswitch的示意图如下图所示。由于tableswitch的case值是连续的，因此只需要记录最低值和最高值，以及每一项对应的offset偏移量，根据给定的index值通过简单的计算即可直接定位到offset。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-200001.png" alt="table-switch"></p>
<p><strong>示例:</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swtich2</span><span class="params">(<span class="type">int</span> select)</span>&#123;
    <span class="type">int</span> num;
    <span class="keyword">switch</span>(select)&#123;
        <span class="keyword">case</span> <span class="number">100</span>:
            num = <span class="number">10</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">500</span>:
            num = <span class="number">20</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">200</span>:
            num = <span class="number">30</span>;
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            num = <span class="number">40</span>;
    &#125;
&#125;</code></pre>

<p><strong>字节码</strong></p>
<pre><code class="highlight txt"> 0 iload_1
 1 tableswitch 1 to 3
	1:  28 (+27)
	2:  34 (+33)
	3:  37 (+36)
	default:  43 (+42)
28 bipush 10
30 istore_2
31 goto 46 (+15)
34 bipush 20
36 istore_2
37 bipush 30
39 istore_2
40 goto 46 (+6)
43 bipush 40
45 istore_2
46 return</code></pre>



<p>指令 lookupswitch 处理的是离散的case值，但是出于效率考虑，将case-offset对按照case值大小排序，给定index时，需要查找与index相等的case，获得其offset，如果找不到则跳转到default。指令lookupswitch如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-200220.png" alt="lookupswitch"></p>
<p><strong>示例</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swtich2</span><span class="params">(<span class="type">int</span> select)</span>&#123;
    <span class="type">int</span> num;
    <span class="keyword">switch</span>(select)&#123;
        <span class="keyword">case</span> <span class="number">100</span>:
            num = <span class="number">10</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">500</span>:
            num = <span class="number">20</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">200</span>:
            num = <span class="number">30</span>;
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            num = <span class="number">40</span>;
    &#125;
&#125;</code></pre>

<p><strong>字节码</strong></p>
<pre><code class="highlight txt"> 0 iload_1
 1 lookupswitch 3
	100:  36 (+35)
	200:  48 (+47)
	500:  42 (+41)
	default:  54 (+53)
36 bipush 10
38 istore_2
39 goto 57 (+18)
42 bipush 20
44 istore_2
45 goto 57 (+12)
48 bipush 30
50 istore_2
51 goto 57 (+6)
54 bipush 40
56 istore_2
57 return</code></pre>



<h2 id="5-无条件跳转指令"><a href="#5-无条件跳转指令" class="headerlink" title="5. 无条件跳转指令"></a>5. 无条件跳转指令</h2><p>目前主要的无条件跳转指令为goto。指令goto接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</p>
<p>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令goto_w，它和goto有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围。</p>
<p><em>指令jsr、jsr_w、ret虽然也是无条件跳转的，但主要用于try-finally语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令。</em></p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>goto</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>goto_w</td>
<td>无条件跳转（宽索引）</td>
</tr>
<tr>
<td>jsr</td>
<td>跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶</td>
</tr>
<tr>
<td>jsr_w</td>
<td>跳转至指定32位offer位置，并将jsr_w下一条指令地址压入栈顶</td>
</tr>
<tr>
<td>ret</td>
<td>返回至由指定的局部变量所给出的指令位置（一般与jsr、jsr_w联合使用）</td>
</tr>
</tbody></table>
<h1 id="九、异常处理指令"><a href="#九、异常处理指令" class="headerlink" title="九、异常处理指令"></a>九、异常处理指令</h1><p><strong>异常处理指令</strong></p>
<ul>
<li><code>athrow</code> 抛出异常或错误。将栈顶异常抛出</li>
<li><code>jsr</code> 跳转到子例程</li>
<li><code>jsr_w</code> 跳转到子例程（宽索引）</li>
<li><code>ret</code> 从子例程返回</li>
</ul>
<h2 id="1-athrow指令"><a href="#1-athrow指令" class="headerlink" title="1. athrow指令"></a>1. athrow指令</h2><p>在Java程序中显示抛出异常的操作（throw语句）都是由athrow指令来实现。</p>
<p>除了使用throw语句显示抛出异常情况之外，JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 <code>idiv</code> 或 <code>ldiv</code> 指令中抛出ArithmeticException异常。</p>
<p><strong>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</strong></p>
<p><strong>注意：</strong></p>
<p>如果使用throw new 异常名称()这种形式来抛出异常，那就会在代码中出现athrow指令，而在方法上面添加throw 异常名称这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性Exceptions，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-201555.png" alt="image-20240731201553896"></p>
<p><strong>示例:</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">throwOne</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">throws</span> RuntimeException,IOException&#123;
    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;参数值为1&quot;</span>);
    &#125;
&#125;</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-201731.png" alt="image-20240731201731105"></p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-201747.png" alt="image-20240731201746649"></p>
<h2 id="2-处理异常"><a href="#2-处理异常" class="headerlink" title="2. 处理异常"></a>2. 处理异常</h2><p>在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（早期使用jsr、ret指令），而是采用异常表来完成的。</p>
<h2 id="3-异常表"><a href="#3-异常表" class="headerlink" title="3. 异常表"></a>3. 异常表</h2><p>如果一个方法定义了一个try-catch 或者try-finally的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。比如：</p>
<ul>
<li><p>起始位置</p>
</li>
<li><p>结束位置</p>
</li>
<li><p>程序计数器记录的代码处理的偏移地址</p>
</li>
<li><p>被捕获的异常类在常量池中的索引</p>
</li>
</ul>
<p>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程。</p>
<p>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标</p>
<p><strong>示例:</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryCatch</span><span class="params">()</span>&#123;
    <span class="keyword">try</span>&#123;
        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/hello.txt&quot;</span>);
        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);

        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;hello!&quot;</span>;
    &#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;
        e.printStackTrace();
    &#125;
    <span class="keyword">catch</span>(RuntimeException e)&#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre>

<p><strong>字节码</strong></p>
<pre><code class="highlight txt"> 0 new #8 &lt;java/io/File&gt;
 3 dup
 4 ldc #9 &lt;d:/hello.txt&gt;
 6 invokespecial #10 &lt;java/io/File.&lt;init&gt; : (Ljava/lang/String;)V&gt;
 9 astore_1
10 new #11 &lt;java/io/FileInputStream&gt;
13 dup
14 aload_1
15 invokespecial #12 &lt;java/io/FileInputStream.&lt;init&gt; : (Ljava/io/File;)V&gt;
18 astore_2
19 ldc #13 &lt;hello!&gt;
21 astore_3
22 goto 38 (+16)
25 astore_1
26 aload_1
27 invokevirtual #15 &lt;java/io/FileNotFoundException.printStackTrace : ()V&gt;
30 goto 38 (+8)
33 astore_1
34 aload_1
35 invokevirtual #16 &lt;java/lang/RuntimeException.printStackTrace : ()V&gt;
38 return</code></pre>

<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-202434.png" alt="异常表"></p>
<h1 id="十、同步控制指令"><a href="#十、同步控制指令" class="headerlink" title="十、同步控制指令"></a>十、同步控制指令</h1><p>Java虚拟机支持两种同步结构：方法级的同步和方法内部一段指令序列的同步，这两种同步都是使用monitor来支持的. </p>
<h2 id="1-方法级的同步"><a href="#1-方法级的同步" class="headerlink" title="1. 方法级的同步"></a>1. 方法级的同步</h2><p><strong>方法级的同步：是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 <code>ACC_SYNCHRONIZED</code>访问标志 得知一个方法是否声明为同步方法；</p>
<p>当调用方法时，调用指令将会检查方法的 <strong>ACC_SYNCHRONIZED访问标志</strong> 是否设置。</p>
<ul>
<li><p>如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</p>
</li>
<li><p>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</p>
</li>
<li><p>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，<strong>那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放</strong>。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<pre><code class="highlight java"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;
<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;
	i++;
&#125;</code></pre>

<p>对应的字节码：</p>
<pre><code class="highlight txt"> 0 aload_0
 1 dup
 2 getfield #2 &lt;com/atguigu/java1/SynchronizedTest.i : I&gt;
 5 iconst_1
 6 iadd
 7 putfield #2 &lt;com/atguigu/java1/SynchronizedTest.i : I&gt;
10 return</code></pre>

<p>这段代码和普通的无同步操作的代码没有什么不同，没有使用 <code>monitorenter</code> 和 <code>monitorexit</code> 进行同步区控制。</p>
<p>这是因为，对于同步方法而言，当虚拟机通过方法的访问标示符判断是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。</p>
<p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-203639.png" alt="方法级同步"></p>
<p>因此，对于同步方法而言，monitorenter 和 monitorexit 指令是隐式存在的，并未直接出现在字节码中。</p>
<h2 id="2-方法内指令指令序列的同步"><a href="#2-方法内指令指令序列的同步" class="headerlink" title="2. 方法内指令指令序列的同步"></a>2. 方法内指令指令序列的同步</h2><p>同步一段指令集序列：通常是由java中的 synchronized语句块 来表示的。jvm的指令集有 <code>monitorenter</code> 和 <code>monitorexit</code> 两条指令来支持synchronized关键字的语义。</p>
<p>当一个线程进入同步代码块时，它使用 monitorenter 指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块。</p>
<p>当线程退出同步块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p>
<p>指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的。</p>
<p><strong>示例:</strong></p>
<pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subtract</span><span class="params">()</span>&#123;

    <span class="keyword">synchronized</span> (obj)&#123;
        i--;
    &#125;
&#125;</code></pre>

<p><strong>字节码</strong></p>
<pre><code class="highlight txt">0: aloade
 1: dup
 2: astore_1
 3: monitorenter
 4: aload_0
 5: dup
 6: getfield #2 //Field i:I
 9: iconst_1
10: isub
11: putfield #2 //Field i:I
14: aload_1
15: monitorexit
16: goto 24
19: astore_2
26: aload_1
21: monitorexit
22: aload_2
23: athrow
24: return

Exception table:
	from to target type
	4	 16	   19  any
	19	 22    19  any</code></pre>

<p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p>
<p>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 george_95@126.com </span>
    </div>
</article>





    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'f820fe811764cacedc4f',
            clientSecret: '0ce07abb65f0e79ddb8830f32029b8a9656e0ee0',
            repo: 'georgechan95.github.io',
            owner: 'GeorgeChan95',
            admin: ['GeorgeChan95'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('15',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 George
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
